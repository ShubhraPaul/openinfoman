<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="urn:ihe:iti:csd:2013" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:csd="urn:ihe:iti:csd:2013" xmlns:xforms="http://www.w3.org/2002/xforms">
  <head>
    <style type="text/css">
          div {
          border-radius: 1em 1em 1em 1em;
          }
          .function {
          background-color: #feedff;
          width:90%;
          magin-top:2em;
          padding-bottom:1em;
          padding-left:1em;
	  box-shadow:0 6px 2px 0 #CCCCCC;
          }
	  .source {
	  overflow:auto;
	  }
          .attribute{
          border-radius: 1em 1em 1em 1em;
          background-color: #FBFBEF;                    
          font-style: italic;
          font-weight: lighter;
          height: auto;
          float:right;
          margin-right:2em;
          margin-left: 1em;
          padding: 2em;
	  box-shadow:0 4px 2px 0 #CCCCCC;
          }
          .callout{
          background: none repeat scroll 0 0 #EEEEEE;
          margin: 1em;
          overflow: auto;
          padding: 1em 2em;
          width: auto;
	  box-shadow:0 6px 2px 0 #CCCCCC;
          }
          .callout h2 {
          background-color: #EEFFFF;
          border-radius: 0.5em 0.5em 0.5em 0.5em;
          padding: 0.2em 0.2em 0.2em 1em;
          }
          pre {
          font-family: "Courier New",Courier,monospace;
          font-size: 0.8em;
	  overflow:scroll;
          }
	  li i.urn {
	  display:inline-block;
	  min-width:18em;
	  max-width:18em;
	  width:18em;
	  }
        </style>
  </head>
  <body>
    <div class="function">
      <h2>Stored Functions</h2>
      <ul>
        <li>
          <i class="urn">urn:ihe:iti:csd:2014:adhoc</i>
          <a style="position:relative;left:2em" href="#urn:ihe:iti:csd:2014:adhoc"> 
    Performs an ad-hoc search on a CSD document
  </a>
        </li>
        <li>
          <i class="urn">urn:ihe:iti:csd:2014:stored-function:facility-search</i>
          <a style="position:relative;left:2em" href="#urn:ihe:iti:csd:2014:stored-function:facility-search"> 
    
    Performs a search for all facilities by name, type, address or ID.   
    
    
      The...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:modtimes</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:modtimes"> 
    Gets the maximum modification times for each of the four directories
  </a>
        </li>
        <li>
          <i class="urn">urn:ihe:iti:csd:2014:stored-function:organization-search</i>
          <a style="position:relative;left:2em" href="#urn:ihe:iti:csd:2014:stored-function:organization-search"> 
    
    Performs a search for all organizations by name, coded type, address or ID.   
    
    
...</a>
        </li>
        <li>
          <i class="urn">urn:ihe:iti:csd:2014:stored-function:provider-search</i>
          <a style="position:relative;left:2em" href="#urn:ihe:iti:csd:2014:stored-function:provider-search">
     Performs a search for all providers by name, coded type, address or ID. 
     The result set c...</a>
        </li>
        <li>
          <i class="urn">urn:ihe:iti:csd:2014:stored-function:service-search</i>
          <a style="position:relative;left:2em" href="#urn:ihe:iti:csd:2014:stored-function:service-search"> 
    
    Performs a search for all search by coded type or ID.   
    
    
      The result set c...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:delete_duplicate</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:delete_duplicate"> 
    Deletes duplicate record reference.  This is done by removing a &lt;csd:otherID/&gt; element on the ...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:delete_potential_duplicate</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:delete_potential_duplicate"> 
    Deletes potential duplicate record reference.  This is done by removing a &lt;csd:otherID/&gt; eleme...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:extract_hierachy</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:extract_hierachy"> 
    Performs an organization hierarch extraction from a source document into the target document. ...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:facility_create</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:facility_create">Create or update a facility entity.   Request parameters should be one or more CSD facility entities</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:mark_duplicate</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:mark_duplicate"> 
    Marks a record as a duplicate with another record.  This is done by adding a &lt;csd:otherID/&gt; el...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:mark_potential_duplicate</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:mark_potential_duplicate"> 
    Marks a record as a potential duplicate with another record.  This is done by adding a &lt;csd:ot...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:identifier_merge</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:identifier_merge"> 
    Performs a merge from the indicated source document(s) into the target document.   Any entitie...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:organization_create</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:organization_create">Create or update a organization entity.   Request parameters should be one or more CSD organization ...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:provider_create</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:provider_create">Create or update a provider entity.   Request parameters should be one or more CSD provider entities</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:service_create</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:service_create">Create or update a service entity.   Request parameters should be one or more CSD service entities</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman:simple_merge</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman:simple_merge"> 
    Performs a simple merge from the indicated source document(s) into the target document.  

   ...</a>
        </li>
        <li>
          <i class="urn">urn:dhis2.org:csd:stored-function:aggregate_hw_export</i>
          <a style="position:relative;left:2em" href="#urn:dhis2.org:csd:stored-function:aggregate_hw_export"> 
    Returns DHIS2 DXF quaterly report of number of health workers by facility 
    
    Reuqest pa...</a>
        </li>
        <li>
          <i class="urn">urn:dhis2.org:csd:stored-function:csd2dxf</i>
          <a style="position:relative;left:2em" href="#urn:dhis2.org:csd:stored-function:csd2dxf"> 
    Returns DHIS2 DXF Metadata representation of CSD facilties and organizations for import into a...</a>
        </li>
        <li>
          <i class="urn">urn:dhis.org:transform_to_dxf:v2.19</i>
          <a style="position:relative;left:2em" href="#urn:dhis.org:transform_to_dxf:v2.19"> 
    Returns DHIS2 DXF Metadata representation of CSD providers, facilties and organizations for im...</a>
        </li>
        <li>
          <i class="urn">urn:dhis2.org:csd:stored-function:dxf2csd</i>
          <a style="position:relative;left:2em" href="#urn:dhis2.org:csd:stored-function:dxf2csd"> 
    Updates the CSD document with a transform of the DHIS2 DXF.  
  </a>
        </li>
        <li>
          <i class="urn">urn:dhis2.org:csd:stored-function:dxf2svs</i>
          <a style="position:relative;left:2em" href="#urn:dhis2.org:csd:stored-function:dxf2svs"> 
    Update SVS lists from a DHIS2 MetaData Export
  </a>
        </li>
        <li>
          <i class="urn">urn:dhis.org:extract_from_dxf:v2.19</i>
          <a style="position:relative;left:2em" href="#urn:dhis.org:extract_from_dxf:v2.19">
    
This extracts all organisation units matching the given facility conditions as a CSD facility ...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rapidpro:get_csv_for_import</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rapidpro:get_csv_for_import"> 
    Creates selection menu of all the CSD organizations and faciltiies with a specified parent.  D...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rapidpro:get_json_for_import</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rapidpro:get_json_for_import"> 
    Get JSON representation of CSD for import to RapidPro via API
  </a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rapidpro:phone_stats</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rapidpro:phone_stats"> 
    Statistics on phone numbers
  </a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rapidpro:select_facility</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rapidpro:select_facility"> 
    Creates selection menu of all the CSD organizations and faciltiies with a specified parent.  D...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:bulk_health_worker_read_otherids_json</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:bulk_health_worker_read_otherids_json">bulk_health_worker_read_otherids_json</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_get_urns</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_get_urns">facility_get_urns</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_address">facility_indices_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_contact_point">facility_indices_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_organization</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_organization">facility_indices_organization</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_otherid">facility_indices_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_service</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_service">facility_indices_service</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_name_search</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_name_search"> 
    
    Performs a search for all facilities by name, type, address or ID.   
    
    
      The...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_read_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_read_address">facilty_read_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_read_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_read_contact_point">facility_read_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_read_organization</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_read_organization">facility_read_organization</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_read_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_read_otherid">facility_read_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_read_service</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_read_service">facility_read_service</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_get_urns</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_get_urns">health_worker_get_urns</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_address">health_worker_indices_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_contact_point">health_worker_indices_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_credential</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_credential">health_worker_indices_credential</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_name</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_name">health_worker_indices_name</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_operating_hours</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_operating_hours">health_worker_indices_operating_hours</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_org_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_org_address">health_worker_indices_org_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_org_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_org_contact_point">health_worker_indices_org_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_otherid">health_worker_indices_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_provider_facility</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_provider_facility">health_worker_indices_provider_facility</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_provider_organization</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_provider_organization">health_worker_indices_provider_organization</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_service</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_service">health_worker_indices_service</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_address">health_worker_read_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_contact_point">health_worker_read_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_credential</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_credential">health_worker_read_credential</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_name</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_name">health_worker_read_name</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_operating_hours</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_operating_hours">health_worker_read_operating_hours</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_org_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_org_address">health_worker_read_org_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_org_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_org_contact_point">health_worker_read_org_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherid">health_worker_read_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherids</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherids">health_worker_read_otherids</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherids_json</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherids_json">health_worker_read_otherids_json</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider">health_worker_read_provider</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider_facility</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider_facility">health_worker_read_provider_facility</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider_organization</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider_organization">health_worker_read_provider_organization</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_service</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_service">health_worker_read_service</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_urn_search_by_id</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_urn_search_by_id">health_worker_urn_search_by_id</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_get_urns</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_get_urns">organization_get_urns</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_address">organization_indices_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_contact_point">organization_indices_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_credential</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_credential">organization_indices_credential</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_otherid">organization_indices_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_name_search</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_name_search"> 
    
    Performs a search for all organizations by name, coded type, address or ID.   
    
    
...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_read_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_read_address">facilty_read_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_read_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_read_contact_point">organization_read_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_read_credential</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_read_credential">organization_read_credential</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_read_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_read_otherid">organization_read_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:provider_name_search</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:provider_name_search">
     Performs a search for all providers by name, coded type, address or ID. 
     The result set c...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:service_get_urns</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:service_get_urns">service_get_urns</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_create_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_create_address">facility_create_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_create_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_create_contact_point">facility_create_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_create_geocode</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_create_geocode">facility_create_geocode</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_create_language</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_create_language">facility_create_language</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_create_operating_hours</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_create_operating_hours">facility_create_operating_hours</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_create_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_create_otherid">facility_create_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_address">facility_delete_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_contact_point">facility_delete_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_geocode</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_geocode">facility_delete_geocode</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_language</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_language">facility_delete_language</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_name</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_name">facility_delete_name</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_operating_hours</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_operating_hours">facility_delete_operating_hours</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_otherid">facility_delete_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_update_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_update_address">facility_update_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_update_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_update_contact_point">facility_update_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_update_name</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_update_name">facility_update_name</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_update_operating_hours</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_update_operating_hours">facility_update_operating_hours</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_update_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_update_otherid">facility_update_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_address">health_worker_create_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_contact_point">health_worker_create_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_credential</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_credential">health_worker_create_credential</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_name</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_name">health_worker_create_name</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_operating_hours</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_operating_hours">health_worker_create_operating_hours</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_org_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_org_address">health_worker_create_org_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_org_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_org_contact_point">health_worker_create_org_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_otherid">health_worker_create_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider">health_worker_create_provider</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider_facility</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider_facility">health_worker_create_provider_facility</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider_organization</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider_organization">health_worker_create_provider_organization</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_service</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_service">health_worker_create_service</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_address">health_worker_delete_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_contact_point">health_worker_delete_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_credential</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_credential">health_worker_delete_credential</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_name</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_name">health_worker_delete_name</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_operating_hours</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_operating_hours">health_worker_delete_operating_hours</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_org_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_org_address">health_worker_delete_org_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_org_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_org_contact_point">health_worker_delete_org_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_otherid">health_worker_delete_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider">health_worker_delete_provider</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider_facility</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider_facility">health_worker_delete_provider_facility</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider_organization</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider_organization">health_worker_delete_provider_organization</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_service</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_service">health_worker_delete_service</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_address">health_worker_update_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_contact_point">health_worker_update_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_credential</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_credential">health_worker_update_credential</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_name</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_name">health_worker_update_name</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_operating_hours</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_operating_hours">health_worker_update_operating_hours</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_org_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_org_address">health_worker_update_org_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_org_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_org_contact_point">health_worker_update_org_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_otherid">health_worker_update_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider">health_worker_update_provider</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider_facility</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider_facility">health_worker_update_provider_facility</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider_organization</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider_organization">health_worker_update_provider_organization</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_service</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_service">health_worker_update_service</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:facility_create_address</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:facility_create_address">facility_create_address</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_create_contact_point</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_create_contact_point">organization_create_contact_point</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_create_credential</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_create_credential">organization_create_credential</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr:stored-function:organization_create_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr:stored-function:organization_create_otherid">organization_create_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rapidpro:get_json_for_import</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rapidpro:get_json_for_import"> 
    Get JSON representation of CSD for import to RapidPro via API
  </a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-liberia:mhero-merge</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-liberia:mhero-merge"> 
    Performs merge for Liberia preserving any mHero/RapidPRO identifiers for existing providers.
 ...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-fhir:fhir_fac_by_organizational_hierarchy_value_set</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-fhir:fhir_fac_by_organizational_hierarchy_value_set">
    Provider XML representation of organizational-facility hierarchy a FHIR value set resource.  

...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-fhir:fhir_location_read</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-fhir:fhir_location_read">
    Provider XML representation of a faciltiy as a FHIR location resource.  

  </a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-fhir:fhir_organization_read</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-fhir:fhir_organization_read">
    Provider XML representation of a organization as a FHIR organization resource.  

  </a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-fhir:fhir_practitioner_read</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-fhir:fhir_practitioner_read">
    Provider XML representation of a provider as a FHIR practitioner resource.  

  </a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rapidpro:select_hfr_facility</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rapidpro:select_hfr_facility"> 
    Creates selection menu of all the CSD organizations with a specified parent.  Designed as part...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rapidpro:select_village</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rapidpro:select_village"> 
    Creates selection menu of all the CSD organizations and faciltiies with a specified parent.  D...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-tz:hfr_facilities_to_csd</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-tz:hfr_facilities_to_csd"> 
    Updates the CSD document by an import from Health Facility Registry export of the Organization...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-tz:rm_org_hierarchy_to_csd</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-tz:rm_org_hierarchy_to_csd"> 
    Updates the CSD document by an import from Resource Map's export of the Organizational hierarc...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-namibia:stored-function:staff_list</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-namibia:stored-function:staff_list">
    Create a staff list for Namibia by facility
  </a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-whomds:stored-function:mds_completeness_healthworker</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-whomds:stored-function:mds_completeness_healthworker">Health Worker WHO MDS completeness report</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-whomds:stored-function:mds_completeness_healthworker_csv</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-whomds:stored-function:mds_completeness_healthworker_csv">Health Worker WHO MDS completeness report as CSV</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-r:stored-function:duplicate_record_field_metrics</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-r:stored-function:duplicate_record_field_metrics">
    Gets metrics on specified data fields to determine applicability of these fields for deduplicat...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-ldif:provider_search</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-ldif:provider_search">
    Gets LDIF (for LDAP) representaiton of provider search results
  </a>
        </li>
        <li>
          <i class="urn"/>
          <a style="position:relative;left:2em" href="#">
    Peforms a search request on a provider's common name according to the OpenSearch 1.1 Specificat...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rwanda:stored-function:rwanda_lookup_epid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rwanda:stored-function:rwanda_lookup_epid">rwanda_lookup_epid</a>
        </li>
        <li>
          <i class="urn">urn:moh.gov.rw:extract_orgunits_rwanda:v2.19</i>
          <a style="position:relative;left:2em" href="#urn:moh.gov.rw:extract_orgunits_rwanda:v2.19">
    
    Extracts Organisation Unit hierarchy and Facility/Site list from DATIM (DHIS2) as CSD Orga...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-opensearch:provider_common_name</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-opensearch:provider_common_name">
    Peforms a search request on a provider's common name according to the OpenSearch 1.1 Specificat...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-opensearch:provider_credenital</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-opensearch:provider_credenital">
    Peforms a search request on a provider's credential number according to the OpenSearch 1.1 Spec...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-anon:wiki-star-bible</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-anon:wiki-star-bible"> 
    Anonymizes data using biblical names for person names and star names for places (sourced from ...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-ilr:validate_provider_facility_service</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-ilr:validate_provider_facility_service">
    Validates a healthcare worker's entity ID.   If optional facility and service information is pr...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rapidpro:get_csv_for_import</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rapidpro:get_csv_for_import"> 
    Creates selection menu of all the CSD organizations and faciltiies with a specified parent.  D...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rapidpro:get_json_for_import</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rapidpro:get_json_for_import"> 
    Get JSON representation of CSD for import to RapidPro via API
  </a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rapidpro:phone_stats</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rapidpro:phone_stats"> 
    Statistics on phone numbers
  </a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-rapidpro:select_facility</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-rapidpro:select_facility"> 
    Creates selection menu of all the CSD organizations and faciltiies with a specified parent.  D...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_birth</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_birth">nigeria_health_worker_indices_demogrpahic_birth</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_citizenship</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_citizenship">nigeria_health_worker_indices_demogrpahic_citizenship</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_photo</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_photo">nigeria_health_worker_indices_demographic_photo</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_birth</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_birth">nigeria_health_worker_read_demographic_birth</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_citizenship</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_citizenship">nigeria_health_worker_read_demographic_citizenship</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_photo</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_photo">nigeria_health_worker_read_demographic_photo</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_otherid">nigeria_health_worker_read_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:opensearch_name</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:opensearch_name">
    Peforms a search request on a provider's common name according to the OpenSearch 1.1 Specificat...</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_birth</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_birth">nigeria_health_worker_create_demographic_birth</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_citizenship</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_citizenship">nigeria_health_worker_create_demographic_citizenship</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_photo</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_photo">nigeria_health_worker_create_demogrpahic_photo</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_other_id</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_other_id">nigeria_health_worker_create_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_provider_credenital</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_provider_credenital">nigeria_health_worker_create_provider_credential</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demographic_birth</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demographic_birth">nigeria_health_worker_delete_demogrpahic_birth</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demogrpahic_citizenship</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demogrpahic_citizenship">nigeria_health_worker_delete_demogrpahic_citizenship</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demographic_photo</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demographic_photo">nigeria_health_worker_delete_demogrpahic_photo</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demographic_birth</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demographic_birth">nigeria_health_worker_update_demogrpahic_birth</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demogrpahic_citizenship</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demogrpahic_citizenship">nigeria_health_worker_update_demogrpahic_citizenship</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demographic_photo</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demographic_photo">nigeria_health_worker_update_demogrpahic_phto</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_otherid</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_otherid">nigeria_health_worker_update_otherid</a>
        </li>
        <li>
          <i class="urn">urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_provider_credenital</i>
          <a style="position:relative;left:2em" href="#urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_provider_credenital">nigeria_health_worker_update_provider_credential</a>
        </li>
      </ul>
    </div>
    <a id="urn:ihe:iti:csd:2014:adhoc"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:ihe:iti:csd:2014:adhoc</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Performs an ad-hoc search on a CSD document
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare namespace csd  =  "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;


let $expr :=$careServicesRequest/adhoc/text()

return 
  if ($expr) 
  then xquery:eval($expr,map{"":/.})
  else ()
</pre></span>
      </div>
    </div>
    <a id="urn:ihe:iti:csd:2014:stored-function:facility-search"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:ihe:iti:csd:2014:stored-function:facility-search</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    
    Performs a search for all facilities by name, type, address or ID.   
    
    
      The result set consists of all facilities matching the  search parameters ( id, primaryName, name, codedType and address ).
     
        
      The results set may be further restricted according to the limit parameters (start, max, record/@status and record/@updated).  An ordering of the result set is not specified.
    
    
    Response
    Results are returned as a valid CSD document with a root document element of &lt;CSD/&gt;.  The results set is contained entirely within the &lt;facilityDirectory/&gt; element and consists of the full content of the &lt;facility/&gt; elements of matching facilities as maintained by the Care Services InfoManager.
    
    Parameters Query
    Parameters are defined as the content of following elements:
    
       &lt;id/&gt; csd:uniqueID: (optional) If present and the @entityID attribute contains a non-empty value, it is a ID which uniquely identifies a facility. This is an exact match.  
      
      &lt;primaryName/&gt; xs:string: (optional) If present and contains a non-empty value, then the result set should be restricted to those facilities whose &lt;primaryName/&gt; contains this value. Case insensitive.
      &lt;name/&gt; xs:string: (optional) If present and contains a non-empty value, then the result set should be restricted to those facilities which have a &lt;primaryName/&gt; or &lt;otherName/&gt; element containing this value. Case insensitive.      
      &lt;codedType/&gt; csd:codedtype:  If present and contains a non-empty value the result set should be restricted to those facilities whose &lt;codedType/@code&gt; equals this value for the coding schema specified by the @codingScheme attribute.  Case insensitive.
      
       &lt;address/&gt; csd:address: (optional) Contains of any-number of child &lt;addressLine/&gt; elements as follows:
        
          Text content xs:string: (optional) If present and contains a non-empty value, then the results set should be restricted to those facilities whose have an &lt;addressLine/&gt; with specified @component containing this value exactly.  Case insensitive.
           
          @component xs:string : (Required attribute) The component of the address we are searching. Case insensitive.
          
      
      &lt;start/&gt;  xs:int: (optional) The starting index for results returned. Defaults to 1, which indexes the first facility matching the search parameters
      &lt;max/&gt;  xs:int: (optional) The maximum number of results returned.  A value of less than zero implies no maximum.
      
	&lt;record/&gt;  csd:record : (optional) A child element to limit results according to
	
	  @status xs:string: (optional) If present and contains a non-empty value, the result set should be restricted to those facilities whose record/@status equals this value.  Case insensitive.
	  @updated xs:dateTime: (optional) If present and contains a non-empty value, the result set should be restricted to those facilities whose record/@updated is at least the given value.
	
      
    
    Example Request
    
         &lt;careServicesRequest&gt;
           &lt;function urn='urn:ihe:iti:csd:2014:stored-function:facility-search'&gt;
               &lt;codedType code='OPC' codingScheme="USDVA"/&gt;
               &lt;address&gt;
                 &lt;addressLine component='city'&gt;Chapel Hill&lt;/addressLine&gt;
	       &lt;/address&gt;
               &lt;max&gt;5&lt;/max&gt;
           &lt;/function&gt;
         &lt;/careServicesRequest&gt;         
      
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare  variable $careServicesRequest as item() external;



(: 
   The query will be executed against the root element of the CSD document.
    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
&lt;CSD xmlns:csd="urn:ihe:iti:csd:2013"  &gt;
  &lt;organizationDirectory/&gt;
  &lt;serviceDirectory/&gt;
  &lt;facilityDirectory&gt;
    {
      let $facs0 := if (exists($careServicesRequest/id))
	then csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id)
      else /CSD/facilityDirectory/*
         
      let $facs1 := if (exists($careServicesRequest/primaryName))
	then csd_bl:filter_by_primary_name($facs0,$careServicesRequest/primaryName)
      else $facs0
         
      let $facs2 := if (exists($careServicesRequest/name))
	then csd_bl:filter_by_name($facs1,$careServicesRequest/name)
      else $facs1
    
      let $facs3 := if(exists($careServicesRequest/codedType))
	then csd_bl:filter_by_coded_type($facs2,$careServicesRequest/codedType) 
      else $facs2
   
      let $facs4 := if(exists($careServicesRequest/address/addressLine))
	then csd_bl:filter_by_address($facs3, $careServicesRequest/address/addressLine) 
      else $facs3

      let $facs5 := if (exists($careServicesRequest/record))
	then csd_bl:filter_by_record($facs4,$careServicesRequest/record)      
      else $facs4

      let $facs6 := if(exists($careServicesRequest/otherID))
	then csd_bl:filter_by_other_id($facs5,$careServicesRequest/otherID)      
      else $facs5


      let $facs7 :=  if (exists($careServicesRequest/organizations/organization)) 
	then (csd_bl:filter_by_organizations($facs6,$careServicesRequest/organizations/organization)      )
      else  ($facs6)
	

      return if (exists($careServicesRequest/start)) then
	if (exists($careServicesRequest/max)) 
	  then csd_bl:limit_items($facs7,$careServicesRequest/start,$careServicesRequest/max)         
	else csd_bl:limit_items($facs7,$careServicesRequest/start,&lt;max/&gt;)         
      else
	if (exists($careServicesRequest/max)) 
	  then csd_bl:limit_items($facs7,&lt;start/&gt;,$careServicesRequest/max)         
	else $facs7


    }     
  &lt;/facilityDirectory&gt;
  &lt;providerDirectory/&gt;
&lt;/CSD&gt;
    </pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:modtimes"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:modtimes</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Gets the maximum modification times for each of the four directories
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>declare namespace csd = 'urn:ihe:iti:csd:2013';
declare variable $careServicesRequest as item() external;
let $ptime := max( for $dt in /csd:CSD/csd:providerDirectory/csd:provider/csd:record/@updated return xs:dateTime($dt))
let $otime := max( for $dt in /csd:CSD/csd:organizationDirectory/csd:provider/csd:record/@updated return xs:dateTime($dt))
let $ftime := max( for $dt in /csd:CSD/csd:facilityDirectory/csd:provider/csd:record/@updated return xs:dateTime($dt))
let $stime := max( for $dt in /csd:CSD/csd:serviceDirectory/csd:provider/csd:record/@updated return xs:dateTime($dt))
let $time := max (($ptime,$otime,$ftime,$stime))
return 
  &lt;csd:CSD updated="{$time}"&gt;
    &lt;csd:providerDirectory updated="{$ptime}"/&gt;
    &lt;csd:facilityDirectory updated="{$ftime}"/&gt;
    &lt;csd:organizationDirectory updated="{$otime}"/&gt;
    &lt;csd:serviceDirectory updated="{$stime}"/&gt;
  &lt;/csd:CSD&gt;</pre></span>
      </div>
    </div>
    <a id="urn:ihe:iti:csd:2014:stored-function:organization-search"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:ihe:iti:csd:2014:stored-function:organization-search</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    
    Performs a search for all organizations by name, coded type, address or ID.   
    
    
      The result set consists of all organizations matching the  search parameters ( id, primaryName, name, codedType and address ).
     
        
      The results set may be further restricted according to the limit parameters (start, max, record/@status and record/@updated).  An ordering of the result set is not specified.
    
    
    Response
    Results are returned as a valid CSD document with a root document element of &lt;CSD/&gt;.  The results set is contained entirely within the &lt;organizationDirectory/&gt; element and consists of the full content of the &lt;organization/&gt; elements of matching organizations as maintained by the Care Services InfoManager.
    
    Parameters Query
    Parameters are defined as the content of following elements:
    
       &lt;id/&gt; csd:uniqueID: (optional) If present and the @entityID attribute contains a non-empty value, it is a ID which uniquely identifies an organization. This is an exact match.  
      
      &lt;primaryName/&gt; xs:string: (optional) If present and contains a non-empty value, then the result set should be restricted to those organizations whose &lt;primaryName/&gt; contains this value. Case insensitive.
      &lt;name/&gt; xs:string: (optional) If present and contains a non-empty value, then the result set should be restricted to those organizations which have a &lt;primaryName/&gt; or &lt;otherName/&gt; element containing this value. Case insensitive.      
      &lt;codedType/&gt; csd:codedtype:  If present and contains a non-empty value the result set should be restricted to those organizations whose &lt;codedType/@code&gt; equals this value for the coding schema specified by the @codingScheme attribute.  Case insensitive.
      
       &lt;address/&gt; csd:address: (optional) Contains of any-number of child &lt;addressLine/&gt; elements as follows:
        
          Text content xs:string: (optional) If present and contains a non-empty value, then the results set should be restricted to those organizations whose have an &lt;addressLine/&gt; with specified @component containing this value exactly.  Case insensitive.
           
          @component xs:string : (Required attribute) The component of the address we are searching. Case insensitive.
          
      
      &lt;start/&gt;  xs:int: (optional) The starting index for results returned. Defaults to 1, which indexes the first organization matching the search parameters
      &lt;max/&gt;  xs:int: (optional) The maximum number of results returned.  A value of less than zero implies no maximum.
      
	&lt;record/&gt;  csd:record : (optional) A child element to limit results according to
	
	  @status xs:string: (optional) If present and contains a non-empty value, the result set should be restricted to those organizations whose record/@status equals this value.  Case insensitive.
	  @updated xs:dateTime: (optional) If present and contains a non-empty value, the result set should be restricted to those organizations whose record/@updated is at least the given value.
	
      
    
    Example Request
    
         &lt;careServicesRequest&gt;
           &lt;function urn='urn:ihe:iti:csd:2014:stored-function:service-search'&gt;
               &lt;codedType codingScheme="moh.gov.rw" code="FBO" /&gt;
               &lt;address&gt;
                 &lt;addressLine component='city'&gt;Kigali&lt;/addressLine&gt;
	       &lt;/address&gt;
               &lt;max&gt;5&lt;/max&gt;
           &lt;/function&gt;
         &lt;/careServicesRequest&gt;         
      
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 


&lt;CSD xmlns:csd="urn:ihe:iti:csd:2013"  &gt;
  &lt;organizationDirectory&gt;
    {
      let $orgs0 := if (exists($careServicesRequest/id))
	then csd_bl:filter_by_primary_id(/CSD/organizationDirectory/*,$careServicesRequest/id)
      else /CSD/organizationDirectory/*
         
      let $orgs1 := if (exists($careServicesRequest/primaryName))
	then csd_bl:filter_by_primary_name($orgs0,$careServicesRequest/primaryName)
      else $orgs0
         
      let $orgs2 := if(exists($careServicesRequest/name))
	then csd_bl:filter_by_name($orgs1,$careServicesRequest/name)
      else $orgs1
    
      let $orgs3 := if(exists($careServicesRequest/codedType))
	then csd_bl:filter_by_coded_type($orgs2,$careServicesRequest/codedType)
      else $orgs2
   
      let $orgs4 :=if (exists($careServicesRequest/address/addressLine))
	then csd_bl:filter_by_address($orgs3, $careServicesRequest/address/addressLine)
      else $orgs3
      
      let $orgs5 := if (exists($careServicesRequest/record))
	then csd_bl:filter_by_record($orgs4,$careServicesRequest/record)
      else $orgs4

      let $orgs6 := if (exists($careServicesRequest/otherID))
	then csd_bl:filter_by_other_id($orgs5,$careServicesRequest/otherID)
      else $orgs5

      let $orgs7 := if (exists($careServicesRequest/parent))
	then csd_bl:filter_by_parent($orgs5,$careServicesRequest/parent)
      else $orgs6

      return if (exists($careServicesRequest/start)) then
	if (exists($careServicesRequest/max))
	  then csd_bl:limit_items($orgs7,$careServicesRequest/start,$careServicesRequest/max)
	else csd_bl:limit_items($orgs7,$careServicesRequest/start,&lt;max/&gt;)
      else
	if (exists($careServicesRequest/max))
	  then csd_bl:limit_items($orgs7,&lt;start/&gt;,$careServicesRequest/max)
	else $orgs7

    }     
  &lt;/organizationDirectory&gt;
  &lt;serviceDirectory/&gt;
  &lt;facilityDirectory/&gt;
  &lt;providerDirectory/&gt;
&lt;/CSD&gt;
</pre></span>
      </div>
    </div>
    <a id="urn:ihe:iti:csd:2014:stored-function:provider-search"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:ihe:iti:csd:2014:stored-function:provider-search</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
     Performs a search for all providers by name, coded type, address or ID. 
     The result set consists of all providers matching the search parameters ( id,
        otherID, commonName,codedType and address ). 
     The results set may be further restricted according to the limit parameters
        (start, max, record/@status and record/@updated). An ordering of
      the result set is not specified. 
    
      Response Results are returned as a valid CSD document with a root document element of
      &lt;CSD/&gt;. The results set is contained entirely within the &lt;providerDirectory/&gt;
      element and consists of the full content of the &lt;provider/&gt; elements of matching
      providers as maintained by the Care Services InfoManager. 
    Parameters Query Parameters are defined as the content of following elements: 
       &lt;id/&gt; csd:uniqueID: (optional) If present and the @entityID attribute contains a
        non-empty value, it is a ID which uniquely identifies a provider. This is an exact match. 
       &lt;otherID/&gt; csd:otherID: (optional) If present and the
        @assigningAuthorityName attribute contains a non-empty value, then the result set is
        restricted to only those providers which have a &lt;otherID/&gt; with the given
        assigingAuthorityName and @code  &lt;commonName/&gt; xsd:string: (optional)
        If present and contains a non-empty value, then the result set should be restricted to those
        providers which have a &lt;demographic/name/commonName/&gt; containing this value. Case
        insensitive.
      &lt;codedType/&gt; csd:codedtype: If present and contains a non-empty value the
        result set should be restricted to those providers whose &lt;codeType/@code&gt; equals this
        value for the coding schema specified by the @codingScheme attribute. Case insensitive. 
       &lt;address/&gt; csd:address: (optional) Contains of any-number of child
        &lt;addressLine/&gt; elements as follows: 
          Text content xsd:string: (optional) If present and contains a non-empty value,
            then the results set should be restricted to those providers whose have an
            &lt;addressLine/&gt; with specified @component containing this value exactly. Case
            insensitive. 
          @component xsd:string : (Required attribute) The component of the address we
            are searching. Case insensitive.
        
      
      &lt;start/&gt;  xsd:int: (optional) The starting index for results returned.
        Defaults to 1, which indexes the first provider matching the search parameters
      &lt;max/&gt;  xsd:int: (optional) The maximum number of results returned. A value
        of less than zero implies no maximum.
       &lt;record/&gt;  csd:record : (optional) A child element to limit results
        according to 
          @status xsd:string: (optional) If present and contains a non-empty value, the
            result set should be restricted to those providers whose record/@status equals this
            value. Case insensitive.
          @updated xsd:dateTime: (optional) If present and contains a non-empty value,
            the result set should be restricted to those providers whose record/@updated is at least
            the given value.
        
      
    
    Example Request
    
         &lt;careServicesRequest&gt;
           &lt;function urn='urn:ihe:iti:csd:2014:stored-function:service-search'&gt;
               &lt;codedType code="2221" codingScheme="ISCO-08" /&lt;
               &lt;address&gt;
                 &lt;addressLine component='city'&gt;Kigali&lt;/addressLine&gt;
	       &lt;/address&gt;
               &lt;max&gt;5&lt;/max&gt;
           &lt;/function&gt;
         &lt;/careServicesRequest&gt;         
      
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

&lt;CSD xmlns:csd="urn:ihe:iti:csd:2013"  &gt;
  &lt;organizationDirectory/&gt;
  &lt;serviceDirectory/&gt;
  &lt;facilityDirectory/&gt;
  &lt;providerDirectory&gt;
    {

      let $provs0 := if (exists($careServicesRequest/id))
	then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id)
      else /CSD/providerDirectory/*

      let $provs1 := if(exists($careServicesRequest/otherID))
	then csd_bl:filter_by_other_id($provs0,$careServicesRequest/otherID)
      else $provs0
         
      let $provs2 := if(exists($careServicesRequest/commonName))
	then csd_bl:filter_by_common_name($provs1,$careServicesRequest/commonName)
      else $provs1
    
      let $provs3 := if (exists($careServicesRequest/codedType))
	then csd_bl:filter_by_coded_type($provs2,$careServicesRequest/codedType) 
      else $provs2
   
      let $provs4 := if (exists($careServicesRequest/address/addressLine))
	then csd_bl:filter_by_demographic_address($provs3, $careServicesRequest/address/addressLine) 
      else $provs3

      let $provs5 :=  if (exists($careServicesRequest/record)) 
	then csd_bl:filter_by_record($provs4,$careServicesRequest/record)      
      else  $provs4

      let $provs6 :=  if (exists($careServicesRequest/facilities/facility)) 
	then csd_bl:filter_by_facilities($provs5,$careServicesRequest/facilities/facility)
      else  $provs5

      let $provs7 :=  if (exists($careServicesRequest/organizations/organization)) 
	then csd_bl:filter_by_organizations($provs6,$careServicesRequest/organizations/organization)      
      else  $provs6

      let $provs7a := if(exists($careServicesRequest/language))
	then csd_bl:filter_by_languages($provs7,$careServicesRequest/language)
      else $provs7
    


      return if (exists($careServicesRequest/start)) then
	if (exists($careServicesRequest/max)) 
	  then csd_bl:limit_items($provs7a,$careServicesRequest/start,$careServicesRequest/max)         
	else csd_bl:limit_items($provs7a,$careServicesRequest/start,&lt;max/&gt;)         
      else
	if (exists($careServicesRequest/max)) 
	  then csd_bl:limit_items($provs7a,&lt;start/&gt;,$careServicesRequest/max)         
	else $provs7a

    }     
  &lt;/providerDirectory&gt;
&lt;/CSD&gt;
</pre></span>
      </div>
    </div>
    <a id="urn:ihe:iti:csd:2014:stored-function:service-search"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:ihe:iti:csd:2014:stored-function:service-search</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    
    Performs a search for all search by coded type or ID.   
    
    
      The result set consists of all serices matching the  search parameters ( id and codedType ).
     
        
      The results set may be further restricted according to the limit parameters (start, max, record/@status and record/@updated).  An ordering of the result set is not specified.
    
    
    Response
    Results are returned as a valid CSD document with a root document element of &lt;CSD/&gt;.  The results set is contained entirely within the &lt;serviceDirectory/&gt; element and consists of the full content of the &lt;service/&gt; elements of matching services as maintained by the Care Services InfoManager.
    
    Parameters Query
    Parameters are defined as the content of following elements:
    
       &lt;id/&gt; csd:uniqueID: (optional) If present and the @entityID attribute contains a non-empty value, it is a ID which uniquely identifies a service. This is an exact match.  
      
      &lt;codedType/&gt; csd:codedtype:  If present and contains a non-empty value the result set should be restricted to those services whose &lt;codedType/@code&gt; equals this value for the coding schema specified by the @codingScheme attribute.  Case insensitive.
      
      &lt;start/&gt;  xs:int: (optional) The starting index for results returned. Defaults to 1, which indexes the first service matching the search parameters
      &lt;max/&gt;  xs:int: (optional) The maximum number of results returned.  A value of less than zero implies no maximum.
      
	&lt;record/&gt;  csd:record : (optional) A child element to limit results according to
	
	  @status xs:string: (optional) If present and contains a non-empty value, the result set should be restricted to those serivces whose record/@status equals this value.  Case insensitive.
	  @updatedxs:dateTime: (optional) If present and contains a non-empty value, the result set should be restricted to those serivces whose record/@updated is at least the given value.
	
      
    
    Example Request
    
         &lt;careServicesRequest&gt;
           &lt;function urn='urn:ihe:iti:csd:2014:stored-function:service-search'&gt;
             &lt;codedType code="76499" codingScheme="HCPCS" /&gt;
             &lt;start&gt;101&lt;/max&gt;
           &lt;/function&gt;
         &lt;/careServicesRequest&gt;         
      
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

&lt;CSD xmlns:csd="urn:ihe:iti:csd:2013"  &gt;
  &lt;organizationDirectory/&gt;
  &lt;serviceDirectory&gt;
    {
      let $svcs0 := if (exists($careServicesRequest/id))
	then csd_bl:filter_by_primary_id(/CSD/serviceDirectory/*,$careServicesRequest/id)
      else /CSD/serviceDirectory/*
    	
      let $svcs1 := if(exists($careServicesRequest/codedType))
	then csd_bl:filter_by_coded_type($svcs0,$careServicesRequest/codedType) 
      else $svcs0

      let $svcs2 :=  if (exists($careServicesRequest/record))
	then csd_bl:filter_by_record($svcs1,$careServicesRequest/record)
      else $svcs1

      return if (exists($careServicesRequest/start)) then
	if (exists($careServicesRequest/max)) 
	  then csd_bl:limit_items($svcs2,$careServicesRequest/start,$careServicesRequest/max)         
	else csd_bl:limit_items($svcs2,$careServicesRequest/start,&lt;max/&gt;)         
      else
	if (exists($careServicesRequest/max)) 
	  then csd_bl:limit_items($svcs2,&lt;start/&gt;,$careServicesRequest/max)         
	else $svcs2

    }     
  &lt;/serviceDirectory&gt;
  &lt;facilityDirectory/&gt;
  &lt;providerDirectory/&gt;
&lt;/CSD&gt;
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:delete_duplicate"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:delete_duplicate</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Deletes duplicate record reference.  This is done by removing a &lt;csd:otherID/&gt; element on the duplicate record that  references the master record.  
    
    This a &lt;csd:otherID/&gt; is characterized as follows:
    
      The @assigningAuthorityName attribute will be the fixed valueurn:openhie.org:openinfoman attribute of the master record      
      The @code attribute will be the fixed value 'duplicate' to indicate this is for marking a duplicate
      The text() value will be the entity ID used to reference to the master record for the entity
    

    A Care Services Request can be submitted to delete the mark that the record as duplicate with the following request parameters:
    
      &lt;masterEntity/&gt; should have attribute @entityID which contains the entity ID of the master record that the duplicate record should refer to
      &lt;duplicateEntity/&gt; should have attribute @entityID which contains the entity ID of the  duplicate record
    

  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_lsc = "https://github.com/openhie/openinfoman/csd_lsc";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
declare namespace csd  =  "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;

let $doc_name := string($careServicesRequest/@resource)
let $doc := csd_dm:open_document($doc_name)

let $masterID := $careServicesRequest/masterEntity/@entityID

let $dupID := $careServicesRequest/duplicateEntity/@entityID
let $dupEntity :=  if (exists($dupID)) then (/csd:CSD/*/*[@entityID = $dupID])[1] else ()


let $dupRef := $dupEntity/csd:otherID[@assigningAuthorityName='urn:openhie.org:openinfoman' and @code='duplicate' and text()=$masterID]

return 
  if (exists($dupRef))
  then delete node $dupRef
  else ()
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:delete_potential_duplicate"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:delete_potential_duplicate</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Deletes potential duplicate record reference.  This is done by removing a &lt;csd:otherID/&gt; element on the potetnial duplicate record which references the master record.  
    
    This a &lt;csd:otherID/&gt; is characterized as follows:
    
      The @assigningAuthorityName attribute will be the fixed valueurn:openhie.org:openinfoman attribute of the master record      
      The @code attribute will be the fixed value 'duplicate' to indicate this is for marking a duplicate
      The text() value will be the entity ID used to reference to the master record for the entity
    

    A Care Services Request can be submitted to delete the mark that the record as potential duplicate with the following request parameters:
    
      &lt;masterEntity/&gt; should have attribute @entityID which contains the entity ID of the master record that the duplicate record should refer to
      &lt;duplicateEntity/&gt; should have attribute @entityID which contains the entity ID of the  duplicate record
    

  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_lsc = "https://github.com/openhie/openinfoman/csd_lsc";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
declare namespace csd  =  "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;

let $doc_name := string($careServicesRequest/@resource)
let $doc := csd_dm:open_document($doc_name)

let $masterID := $careServicesRequest/masterEntity/@entityID

let $dupID := $careServicesRequest/duplicateEntity/@entityID
let $dupEntity :=  if (exists($dupID)) then (/csd:CSD/*/*[@entityID = $dupID])[1] else ()


let $dupRef := $dupEntity/csd:otherID[@assigningAuthorityName='urn:openhie.org:openinfoman' and @code='potential-duplicate' and text()=$masterID]

return 
  if (exists($dupRef))
  then delete node $dupRef
  else ()
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:extract_hierachy"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:extract_hierachy</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Performs an organization hierarch extraction from a source document into the target document.  Any existing elements in the target document are overwritten by those from the source document(s).

    There are two required parameters:
    
      
	The document is indicated via &lt;document/%gt; element.    If  @resource attribute of the &lt;document/&gt; should be the name of a document available to OpenInfoMan.   Otherwise the content of the &lt;document/&gt; should be a valid CSD document.
      
    

    Under each  &lt;document/&gt; is the required elements:
    
      
	Aa &lt;csd:organization/&gt; element to indicate the part of the hiearchy that should be extracted.  
      
    
    Under each  &lt;document/&gt; are two optional elements:
    
      
	keepParents
	0..1 keepParents  element has integer attribute @value.  Defaults to 1 which means we keep the parents of the indicated organization when we extract.
      
      
	processFacilities
	0..1 processFacilities  element has integer attribute @value.  Defaults to 1 which means we also include the facilities associated to the organizations in the extracted hierarchy.
      
    


All parent nodes of the indicated organziation 
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_lsc = "https://github.com/openhie/openinfoman/csd_lsc";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace functx = "http://www.functx.com";
import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare namespace csd  =  "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;



let $dest_doc := /.
let $dest := $careServicesRequest/@resource


return for $doc in $careServicesRequest/documents/document
  let $name := $doc/@resource
  let $src_doc :=
    if (not (functx:all-whitespace($name)))
    then if (not ($name = $dest)) then csd_dm:open_document($name) else ()
    else $doc/csd:CSD
  let $req_org_id :=  $doc/csd:organization/@entityID 

    
  let $processFacilities := 
    if (exists($doc/processFacilities/@value))
    then ($doc/processFacilities/@value = 1)
    else true()
  let $keepParents := 
    if (exists($doc/keepParents/@value))
    then ($doc/keepParents/@value = 1)
    else true()
    
  let $all_orgs := $src_doc/csd:CSD/csd:organizationDirectory/csd:organization
  let $org := $all_orgs[@entityID = $req_org_id]

  let $orgs := 
    if (not(exists($org)))
    then () (: nothing to extract:) 
    else
      (
	if ($keepParents)
	then csd_bl:get_parent_orgs($all_orgs,$org)
	else ()
	,
	$org
	,
	csd_bl:get_child_orgs($all_orgs,$org)
      )

  let $facs := 
    if (not ($processFacilities) )
    then ()
    else 
      for $org in $orgs
      return  $src_doc/csd:CSD/csd:facilityDirectory/csd:facility[./csd:organizations/csd:organization/@entityID = $org/@entityID]
	


  return
    (
      csd_lsc:update_directory($dest_doc/csd:CSD/csd:organizationDirectory,$orgs)
      ,csd_lsc:update_directory($dest_doc/csd:CSD/csd:facilityDirectory,$facs)
    )



</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:facility_create"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:facility_create</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">Create or update a facility entity.   Request parameters should be one or more CSD facility entities</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
(:
import module namespace random = "http://basex.org/modules/random";
:)
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
for $fac in $careServicesRequest/facility
  let $existing := if (exists($fac/@entityID)) then csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$fac) else ()
  return
    if (exists($existing)) 
    then replace node $existing with $fac
    else insert node $fac into /CSD/facilityDirectory
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:mark_duplicate"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:mark_duplicate</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Marks a record as a duplicate with another record.  This is done by adding a &lt;csd:otherID/&gt; element to the record that is duplicate which references the master record.  
    
    This a &lt;csd:otherID/&gt; is characterized as follows:
    
      The @assigningAuthorityName attribute will be the fixed valueurn:openhie.org:openinfoman attribute of the master record      
      The @code attribute will be the fixed value 'duplicate' to indicate this is for marking a duplicate
      The text() value will be the entity ID used to reference to the master record for the entity
    

    A Care Services Request can be submitted to mark the record as duplicate with the following request parameters:
    
      &lt;masterEntity/&gt; should have attribute @entityID which contains the entity ID of the master record that the duplicate record should refer to
      &lt;duplicateEntity/&gt; should have attribute @entityID which contains the entity ID of the  duplicate record
    

  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_lsc = "https://github.com/openhie/openinfoman/csd_lsc";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
declare namespace csd  =  "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;

let $doc_name := string($careServicesRequest/@resource)
let $doc := csd_dm:open_document($doc_name)

let $masterID := $careServicesRequest/masterEntity/@entityID
let $masterEntity := if (exists($masterID)) then  (/csd:CSD/*/*[@entityID = $masterID])[1] else ()

let $dupID := $careServicesRequest/duplicateEntity/@entityID
let $dupEntity :=  if (exists($dupID)) then (/csd:CSD/*/*[@entityID = $dupID])[1] else ()


let $masterRef := &lt;csd:otherID assigningAuthorityName='urn:openhie.org:openinfoman' code='duplicate'&gt;{string($masterID)}&lt;/csd:otherID&gt;

return 
  if (not(exists($masterEntity)) or not( exists($dupEntity)))
  then ()
  else 
    let $existingRef := ($dupEntity/csd:otherID[@assigningAuthorityName = 'urn:openhie.org:openinfoman' and @code='duplicate'])[1]
    return 
      (
	if (exists($existingRef))
	then (replace node $existingRef with $masterRef)
	else (insert node $masterRef before ($dupEntity/*)[1])
      ,
        for $entity in /csd:CSD/*/*[./csd:otherID[@assigningAuthorityName='urn:openhie.org:openinfoman' and @code='duplicate' and ./text()=$dupID]]
	let $e_existingRef := ($entity/csd:otherID[@assigningAuthorityName='urn:openhie.org:openinfoman' and @code='duplicate' and  ./text()=$dupID])[1]
	return 
	  if (not($e_existingRef = $existingRef)  )
	  then replace node $e_existingRef with $masterRef
	  else () (:avoid double replacelement in edge case in which a record is marked as duplicate to itself:)
     )


</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:mark_potential_duplicate"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:mark_potential_duplicate</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Marks a record as a potential duplicate with another record.  This is done by adding a &lt;csd:otherID/&gt; element to the record that is the potential duplicate which references the master record.  
    
    This a &lt;csd:otherID/&gt; is characterized as follows:
    
      The @assigningAuthorityName attribute will be the fixed valueurn:openhie.org:openinfoman attribute of the master record      
      The @code attribute will be the fixed value 'potential-duplicate' to indicate this is for marking a potential duplicate
      The text() value will be the entity ID used to reference to the master record for the entity
    

    A Care Services Request can be submitted to mark the record as potential duplicate with the following request parameters:
    
      &lt;masterEntity/&gt; should have attribute @entityID which contains the entity ID of the master record that the potential duplicate record should refer to
      &lt;duplicateEntity/&gt; should have attribute @entityID which contains the entity ID of the  duplicate record
    

  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_lsc = "https://github.com/openhie/openinfoman/csd_lsc";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
declare namespace csd  =  "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;

let $doc_name := string($careServicesRequest/@resource)
let $doc := csd_dm:open_document($doc_name)

let $masterID := $careServicesRequest/masterEntity/@entityID
let $masterEntity := if (exists($masterID)) then  (/csd:CSD/*/*[@entityID = $masterID])[1] else ()

let $dupID := $careServicesRequest/duplicateEntity/@entityID
let $dupEntity :=  if (exists($dupID)) then (/csd:CSD/*/*[@entityID = $dupID])[1] else ()


let $masterRef := &lt;csd:otherID assigningAuthorityName='urn:openhie.org:openinfoman' code='potential-duplicate'&gt;{string($masterID)}&lt;/csd:otherID&gt;

return 
  if (not(exists($masterEntity)) or not( exists($dupEntity)))
  then ()
  else 
    let $existingRef := ($dupEntity/csd:otherID[@assigningAuthorityName = 'urn:openhie.org:openinfoman' and @code='potential-duplicate' and text() = $masterID])[1]
    return 
      (
	if (exists($existingRef))
	then (replace node $existingRef with $masterRef)
	else (insert node $masterRef before ($dupEntity/*)[1])
      ,
        for $entity in /csd:CSD/*/*[./csd:otherID[@assigningAuthorityName='urn:openhie.org:openinfoman' and @code='potential-duplicate' and ./text()=$dupID]]
	let $e_existingRef := ($entity/csd:otherID[@assigningAuthorityName='urn:openhie.org:openinfoman' and @code='potential-duplicate' and  ./text()=$dupID])[1]
	return (replace node $e_existingRef with $masterRef)
     )


</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:identifier_merge"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:identifier_merge</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Performs a merge from the indicated source document(s) into the target document.   Any entities in the target document are overwritten by the corresponding entity in the source document except that &lt;csd:otherID/&gt; elements are preserved.

    Documents are indicated via &lt;document/%gt; elements under the top-level &lt;documents/&gt; element.   
    The  @resource attribute of the &lt;document/&gt; should be the name of a document available to OpenInfoMan.   Otherwise the content of the &lt;document/&gt; should be a valid CSD document.


    The following optional elements are allowed under each &lt;document/%gt; element :
    
      insertNew 0..1 insertNew has integer attribute @value. Defaults to 1 which means we insert any new entities from the source documents if they are not already a part of the destination document
    

  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_lsc = "https://github.com/openhie/openinfoman/csd_lsc";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace functx = "http://www.functx.com";
declare namespace csd  =  "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;



let $dest_doc := /.
let $dest := $careServicesRequest/@resource
for $doc in $careServicesRequest/documents/document
  let $insertNew := 
    if (exists($doc/insertNew/@value))
    then ($doc/insertNew/@value = 1)
    else true()

  let $name := string($doc/@resource)
  let $src_doc :=
    if (not (functx:all-whitespace($name)))
    then if (not ($name = $dest)) then csd_dm:open_document( $name) else ()
    else $doc
  return 
    (
    let $src_dir := $src_doc/csd:CSD/csd:organizationDirectory
    let $dest_dir := $dest_doc/csd:CSD/csd:organizationDirectory
    return
      for $e in $src_dir/csd:organization 
      let $existing := $dest_dir/csd:organization[@entityID = $e/@entityID]
      return 
	if (exists($existing)) 
        then
          let $new := 
	    &lt;csd:organization entityID="{$e/@entityID}"&gt;
	      {$existing/csd:otherID}  
	      {$e/*}
	    &lt;/csd:organization&gt;
	  return replace node $existing with $new 
        else if ($insertNew) then insert node $e into $dest_dir else ()
    ,
    let $src_dir := $src_doc/csd:CSD/csd:providerDirectory
    let $dest_dir := $dest_doc/csd:CSD/csd:providerDirectory
    return
      for $e in $src_dir/csd:provider 
      let $existing := $dest_dir/csd:provider[@entityID = $e/@entityID]
      return 
	if (exists($existing)) 
	then
          let $new := 
	    &lt;csd:provider entityID="{$e/@entityID}"&gt;
	      {$existing/csd:otherID}  
	      {$e/*}
	    &lt;/csd:provider&gt;
	  return replace node $existing with $new 
        else if ($insertNew) then insert node $e into $dest_dir else ()
    ,
    let $src_dir := $src_doc/csd:CSD/csd:serviceDirectory
    let $dest_dir := $dest_doc/csd:CSD/csd:serviceDirectory
    return
      for $e in $src_dir/csd:service 
      let $existing := $dest_dir/csd:service[@entityID = $e/@entityID]
      return 
	if (exists($existing)) 
	then
          let $new := 
	    &lt;csd:service entityID="{$e/@entityID}"&gt;
	      {$existing/csd:otherID}  
	      {$e/*}
	    &lt;/csd:service&gt;
	  return replace node $existing with $new 
        else if ($insertNew) then insert node $e into $dest_dir else ()
    ,
    let $src_dir := $src_doc/csd:CSD/csd:facilityDirectory
    let $dest_dir := $dest_doc/csd:CSD/csd:facilityDirectory
    return
      for $e in $src_dir/csd:facility 
      let $existing := $dest_dir/csd:facility[@entityID = $e/@entityID]
      return 
	if (exists($existing)) 
	then
          let $new := 
	    &lt;csd:facility entityID="{$e/@entityID}"&gt;
	      {$existing/csd:otherID}  
	      {$e/*}
	    &lt;/csd:facility&gt;
	  return replace node $existing with $new 
        else if ($insertNew) then insert node $e into $dest_dir else ()

    )




</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:organization_create"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:organization_create</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">Create or update a organization entity.   Request parameters should be one or more CSD organization entities</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
(:
import module namespace random = "http://basex.org/modules/random";
:)
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
for $org in $careServicesRequest/organization
  let $existing := if (exists($org/@entityID)) then csd_bl:filter_by_primary_id(/CSD/organizationDirectory/*,$org) else ()
  return
    if (exists($existing)) 
    then replace node $existing with $org
    else insert node $org into /CSD/organizationDirectory
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:provider_create"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:provider_create</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">Create or update a provider entity.   Request parameters should be one or more CSD provider entities</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
(:
import module namespace random = "http://basex.org/modules/random";
:)
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
for $prov in $careServicesRequest/provider
  let $existing := if (exists($prov/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$prov) else ()
  return
    if (exists($existing)) 
    then replace node $existing with $prov
    else insert node $prov into /CSD/providerDirectory
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:service_create"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:service_create</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">Create or update a service entity.   Request parameters should be one or more CSD service entities</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
(:
import module namespace random = "http://basex.org/modules/random";
:)
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
for $srvc in $careServicesRequest/service
  let $existing := if (exists($srvc/@entityID)) then csd_bl:filter_by_primary_id(/CSD/serviceDirectory/*,$srvc) else ()
  return
    if (exists($existing)) 
    then replace node $existing with $srvc
    else insert node $srvc into /CSD/serviceDirectory
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman:simple_merge"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman:simple_merge</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Performs a simple merge from the indicated source document(s) into the target document.  

    Documents are indicated via &lt;document/%gt; elements under the top-level &lt;documents/&gt; element.   
    If  @resource attribute of the &lt;document/&gt; should be the name of a document available to OpenInfoMan.   Otherwise the content of the &lt;document/&gt; should be a valid CSD document.

    The following optional elements are allowed:
    
      overwriteExisting 0..1 overwriteExisting has integer attribute @value. Defaults to 1 which aany existing elements in the target document are overwritten by those from the source document(s).
    

  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_lsc = "https://github.com/openhie/openinfoman/csd_lsc";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace functx = "http://www.functx.com";
declare namespace csd  =  "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;


let $overwriteExisting := 
  if (exists($careServicesRequest/overwriteExisting/@value))
  then ($careServicesRequest/overwriteExisting/@value = 1)
  else true()


let $dest_doc := /.
let $dest := $careServicesRequest/@resource

for $doc  in $careServicesRequest/documents/document
  let $name := $doc/@resource
  let $src_doc :=
    if (not (functx:all-whitespace($name)))
    then if (not ($name = $dest)) then csd_dm:open_document($name) else ()
    else $doc
  return  
    csd_lsc:refresh_doc($dest_doc, $src_doc,$overwriteExisting) 



</pre></span>
      </div>
    </div>
    <a id="urn:dhis2.org:csd:stored-function:aggregate_hw_export"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:dhis2.org:csd:stored-function:aggregate_hw_export</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Returns DHIS2 DXF quaterly report of number of health workers by facility 
    
    Reuqest parameters:
      assigningAuthorityName: the assignining authority name for the csd:facility/csd:otherID in which the DHIS code is stored
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

let $facilities := /csd:CSD/csd:facilityDirectory/csd:facility
let $active_providers := /csd:CSD/csd:providerDirectory/csd:provider[./csd:record/@status = "106-001"]

let $year := year-from-date(current-date())
let $month := month-from-date(current-date())
let $quarter := 
  if ($month &lt; 4) then "1"
  else if ($month &lt; 7) then "2"
  else if ($month &lt; 10) then "3"
  else "4"
let $period := concat($year , 'Q',$quarter)

return 
  &lt;dxf xmlns="http://dhis2.org/schema/dxf/2.0"&gt; 
    &lt;dataValueSet&gt;
      {
	for $fac in $facilities
	let $fac_id := upper-case(string($fac/@entityID))
	let $facurn := substring($fac_id,10)
	let $fac_providers := $active_providers[./csd:facilities/csd:facility[upper-case(./@entityID)=$fac_id]]
	let $count := count($fac_providers)
	where $facurn  and $count &gt; 0   
	return &lt;dataValue period="{$period}" orgUnit="{$facurn}" dataElement="numProviders" value="{$count}" /&gt;
      }
    &lt;/dataValueSet&gt;
  &lt;/dxf&gt;</pre></span>
      </div>
    </div>
    <a id="urn:dhis2.org:csd:stored-function:csd2dxf"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:dhis2.org:csd:stored-function:csd2dxf</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Returns DHIS2 DXF Metadata representation of CSD facilties and organizations for import into a DHIS2 instance 
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace dxf2csd = "http://dhis2.org/csd/dxf/2.0";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace svs_lsvs = "https://github.com/openhie/openinfoman/svs_lsvs";

declare namespace svs = "urn:ihe:iti:svs:2008";
declare namespace csd = "urn:ihe:iti:csd:2013";
declare namespace dxf = "http://dhis2.org/csd/dxf/2.0";

declare variable $careServicesRequest as item() external; 

let $doc_name := string($careServicesRequest/@resource)
let $doc := csd_dm:open_document($doc_name)

let $facilities := $doc/csd:CSD/csd:facilityDirectory/csd:facility
let $svcs := $doc/csd:CSD/csd:serviceDirectory/csd:service
let $orgs := $doc/csd:CSD/csd:organizationDirectory/csd:organization


let $fac_type_ids := ("1.3.6.1.4.1.21367.200.103")

let $org_unit_groups :=   
  for $fac_type_id in $fac_type_ids	  
  let $fac_types :=  svs_lsvs:get_single_version_value_set(string($fac_type_id) )	  
  return
    for $concept in $fac_types//svs:Concept
    let $code := string($concept/@code)
    let $scheme := string($concept/@codeSystem)
    let $name := string($concept/@displayName)
    return &lt;dxf:organisationUnitGroup code="{$code}" name="{$name}" codeSystem="{$scheme}"/&gt;

return 
    &lt;dxf:metaData&gt;
      &lt;dxf:organisationUnits&gt;
        {
	  for $org in dxf2csd:ensure_properly_ordered_orgs($orgs)
	  return dxf2csd:make_org_from_org($doc,$org) 
	}
        {
	  for $fac in $facilities
	  return dxf2csd:make_org_from_fac($doc,$fac) 
	}
      &lt;/dxf:organisationUnits&gt;


      &lt;dxf:organisationUnitGroups&gt;
        { 
	  for $org_unit_group in $org_unit_groups
	  let $code := string($org_unit_group/@code)
	  let $scheme := string($org_unit_group/@codeSystem)
	  let $name := string($org_unit_group/@name)
	  let $short_name := substring(string($org_unit_group/@name),1,50)
	    return 
	    &lt;dxf:organisationUnitGroup code="{$code}" name="{$name}" shortName="{$short_name}"&gt;
	      &lt;dxf:organisationUnits&gt;
		{
		  for $fac in $facilities[./csd:codedType[@codingScheme = $scheme and @code = $code]]
		  let $uuid := dxf2csd:extract_uuid_from_entityid($fac/@entityID)
		  let $fac_name := $fac/csd:primaryName/text()
		  let $id := string($fac/@entityID)
		  return     
		     &lt;dxf:organisationUnit uuid="{$uuid}" id="{$id}" name="{$fac_name}" /&gt;
		}
	      &lt;/dxf:organisationUnits&gt;
	    &lt;/dxf:organisationUnitGroup&gt;
	}
      &lt;/dxf:organisationUnitGroups&gt;

      { 
      if (count($org_unit_groups) &gt; 0)
      then
        &lt;dxf:organisationUnitGroupSets&gt;
	  &lt;dxf:organisationUnitGroupSet name='Facility Type'&gt;
	    &lt;dxf:description&gt;Facility Type&lt;/dxf:description&gt;
	    &lt;dxf:compulsory&gt;true&lt;/dxf:compulsory&gt;
	    &lt;dxf:dataDimension&gt;true&lt;/dxf:dataDimension&gt;
	    &lt;dxf:organisationUnitGroups&gt;
	      {
		for $org_unit_group in $org_unit_groups
		let $code := string($org_unit_group/@code)
		let $scheme := string($org_unit_group/@codeSystem)
		let $name := string($org_unit_group/@name)
		return   &lt;dxf:organisationUnitGroup code="{$code}" name="{$name}" /&gt;
	      }
	    &lt;/dxf:organisationUnitGroups&gt;
	  &lt;/dxf:organisationUnitGroupSet&gt;	
	&lt;/dxf:organisationUnitGroupSets&gt;
      else () 
      }

    &lt;/dxf:metaData&gt;
</pre></span>
      </div>
    </div>
    <a id="urn:dhis.org:transform_to_dxf:v2.19"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        application/zip<br/>
	URN: urn:dhis.org:transform_to_dxf:v2.19</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Returns DHIS2 DXF Metadata representation of CSD providers, facilties and organizations for import into a DHIS2 instance 
    
    Request parameters are:
    
      
	csd:organization
	0..1 csd:organization element with @entityID attribute.  If present, will generate only the organisation unit hierarchy
	underneath the specified organization. Will also include all the parent organization units.  
      
      
	processUsers
	0..1 processUsers  element has integer attribute @value.  Defaults to 1 which means we process provides as DHIS2 users.
      
      
	preserveUUIDs
	0..1 processUUIDs  element has integer attribute @value.  Defaults to 1 which means we preserve DHIS2 UUIDs, if present, when creating the DXF metadata for import.
      
    
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace dxf2csd = "http://dhis2.org/csd/dxf/2.0";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace svs_lsvs = "https://github.com/openhie/openinfoman/svs_lsvs";
import module namespace util = "https://github.com/openhie/openinfoman-dhis/util";
import module namespace functx = "http://www.functx.com";
import module namespace archive = "http://basex.org/modules/archive";

declare namespace svs = "urn:ihe:iti:svs:2008";
declare namespace csd = "urn:ihe:iti:csd:2013";
declare namespace dxf = "http://dhis2.org/schema/dxf/2.0";

declare variable $careServicesRequest as item() external; 

let $doc_name := string($careServicesRequest/@resource)
let $processUsers := 
  if (exists($careServicesRequest/processUsers/@value))
  then ($careServicesRequest/processUsers/@value = 1)
  else true()
let $preserveUUIDs := 
  if (exists($careServicesRequest/preserveUUIDs/@value))
  then ($careServicesRequest/preserveUUIDs/@value = 1)
  else true()

let $onlyDirectChildren := 
  if (exists($careServicesRequest/onlyDirectChildren/@value))
  then ($careServicesRequest/onlyDirectChildren/@value = 1)
  else true()

let $zip := 
  if (exists($careServicesRequest/zip/@value))
  then ($careServicesRequest/zip/@value = 1)
  else true()
let $req_org_id :=    $careServicesRequest/csd:organization/@entityID 
let $req_ou_group_schemes:= distinct-values($careServicesRequest/orgUnitGroupSchemes/orgUnitGroupScheme/text())


let $t0 :=
  (
    trace($processUsers,'Process users: '),
    trace($preserveUUIDs,'Preserve UUIDs: '),
    trace($onlyDirectChildren,'Only Direct Children: '),
    trace($zip,'Zip: '),
    trace($req_org_id,'Requested Org EntityID: '),
    trace($req_ou_group_schemes,'Request Org Group Schemes: ')
  )

let $doc := csd_dm:open_document($doc_name)
  (:the organziation we want to import to:)



let $svcs := $doc/csd:CSD/csd:serviceDirectory/csd:service

let $orgs := 
  if (functx:all-whitespace($req_org_id))
  then dxf2csd:ensure_properly_ordered_orgs($doc/csd:CSD/csd:organizationDirectory/csd:organization)
  else 
    let $all_orgs := $doc/csd:CSD/csd:organizationDirectory/csd:organization
    let $org := $all_orgs[@entityID = $req_org_id]
    return 
      if (not(exists($org)))
      then ()
      else
	if ($onlyDirectChildren)
	then (util:get_parent_orgs($all_orgs,$org),$org,$all_orgs[./csd:parent[@entityID = $req_org_id]])
	else (util:get_parent_orgs($all_orgs,$org),$org,util:get_child_orgs($all_orgs,$org))  (: this comes back properly ordered for DHIS2 import :)


let $facilities := 
  if (functx:all-whitespace($req_org_id))
  then $doc/csd:CSD/csd:facilityDirectory/csd:facility
  else  $doc/csd:CSD/csd:facilityDirectory/csd:facility[./csd:organizations/csd:organization = $orgs]

let $provs := 
  if ($processUsers)
  then $doc/csd:CSD/csd:providerDirectory/csd:provider
  else ()



let $ou_oids := 
  for $dhis_url in distinct-values(($orgs/csd:record/@sourceDirectory,$facilities/csd:record/@sourceDirectory))
  let $namespace_uuid := util:uuid_generate($dhis_url,$util:namespace_uuid)
  let $oid := concat('2.25.',util:hexdec(util:uuid_generate('rootoid',$namespace_uuid)))	
  return $oid

    
let $dxf := 
    &lt;dxf:metaData&gt;
      &lt;dxf:users&gt;
      {
	for $prov in $provs

	let $dhis_url := string(($prov/csd:record/@sourceDirectory)[1])
	let $dhis_id :=  ($prov/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/users") and @code="id"])[1]/text()	  
	let $namespace_uuid := util:uuid_generate($dhis_url,$util:namespace_uuid)
	let $oid := concat('2.25.',util:hexdec(util:uuid_generate('rootoid',$namespace_uuid)))	

	let $name := ($prov/csd:demographic/csd:name/csd:commonName)[1]/text()
	let $surname := ($prov/csd:demographic/csd:name/csd:surname)[1]/text()
	let $firstname := ($prov/csd:demographic/csd:name/csd:forename)[1]/text()
	let $username := dxf2csd:extract_uuid_from_entityid(string($prov/@entityID))
	let $phone := ($prov/csd:contactPoint/csd:codedType[@code="BP" and @codingScheme="urn:ihe:iti:csd:2013:contactPoint"])[1]/text()
	let $email := ($prov/csd:contactPoint/csd:codedType[@code="EMAIL" and @codingScheme="urn:ihe:iti:csd:2013:contactPoint"])[1]/text()
	let $ag_oid := concat($oid,'.4')
	let $ur_oid := concat($oid,'.1')
	let $urs := 
	   for $o_id in $prov/csd:codedType[@codingScheme = $ur_oid]
	   return &lt;dxf:userRole id="{string($o_id/@code)}"/&gt;
	let $uags := 
	   for $o_id in $prov/csd:codedType[@codingScheme = $ag_oid]
	   return &lt;dxf:userAuthorityGroup id="{string($o_id/@code)}"/&gt;
	let $p_orgs := 
	  for $org in $prov/csd:organizations/csd:organization
	  let $ou_uuid := 
	    if ($preserveUUIDs) 
	    then ($facilities[@entityID = $org/@entityID]/csd:otherID[@assigningAuthorityName = concat($dhis_url,"/api/organisationUnits") and @code="uuid"])[1]/text()
	    else ()
	  return 
	    if (functx:all-whitespace($ou_uuid)) 
	    then () 
	    else  &lt;dxf:organisationUnit uuid="{$ou_uuid}"/&gt;

	      
	return
	  &lt;dxf:user name="{$name}" &gt;
	    {if (functx:all-whitespace($dhis_id)) then () else  @id}
	    &lt;dxf:surname&gt;{$surname}&lt;/dxf:surname&gt;
	    &lt;dxf:firstName&gt;{$firstname}&lt;/dxf:firstName&gt;
	    {if (functx:all-whitespace($email)) then () else &lt;dxf:email&gt;{$email}&lt;/dxf:email&gt;}
	    {if (functx:all-whitespace($phone)) then () else &lt;dxf:phoneNumber&gt;{$email}&lt;/dxf:phoneNumber&gt;}
	    &lt;dxf:userCredenitals&gt;
	      &lt;dxf:username&gt;{$username}&lt;/dxf:username&gt; 
	      &lt;dxf:userRoles&gt;{$urs}&lt;/dxf:userRoles&gt;
	      &lt;dxf:userAuthorityGroups&gt;{$uags}&lt;/dxf:userAuthorityGroups&gt;
	    &lt;/dxf:userCredenitals&gt;
	    &lt;dxf:organisationUnits&gt;
	      {$p_orgs}
	    &lt;/dxf:organisationUnits&gt;
	  &lt;/dxf:user&gt;
        }
      &lt;/dxf:users&gt;

      &lt;dxf:userRoles&gt;
	{
	  let $oids := 
	    for $dhis_url in distinct-values($provs/csd:record/@sourceDirectory)
	    let $namespace_uuid := util:uuid_generate($dhis_url,$util:namespace_uuid)
	    let $oid := concat('2.25.',util:hexdec(util:uuid_generate('rootoid',$namespace_uuid)))	
	    return $oid
	  
	  return 
	  for $oid in $oids
            let $ur_oid := concat($oid,'.1')
	    let $svs := svs_lsvs:get_single_version_value_set($ur_oid)
	    return
	      if (not(exists($svs)))
	      then ()
              else 
		for $val in $svs//svs:concept
		return 
		  &lt;dxf:userRole name="{$val/@displayName}" id="{$val/@code}"&gt;
		    &lt;dxf:description&gt;{string($val/@displayName)}&lt;/dxf:description&gt;
		  &lt;/dxf:userRole&gt;
	}
      &lt;/dxf:userRoles&gt;
      &lt;dxf:userAuthorityGroups&gt;
	{
	  let $oids := 
	    for $dhis_url in distinct-values($provs/csd:record/@sourceDirectory)
	    let $namespace_uuid := util:uuid_generate($dhis_url,$util:namespace_uuid)
	    let $oid := concat('2.25.',util:hexdec(util:uuid_generate('rootoid',$namespace_uuid)))	
	    return $oid
	  
	  return 
	  for $oid in $oids
            let $ag_oid := concat($oid,'.4')
	    let $svs := svs_lsvs:get_single_version_value_set($ag_oid)
	    return
	      if (not(exists($svs)))
	      then ()
              else 
		for $val in $svs//svs:concept
		return 
		  &lt;dxf:userAuthorityGroup name="{$val/@displayName}" id="{$val/@code}"&gt;
		    &lt;dxf:description&gt;{string($val/@displayName)}&lt;/dxf:description&gt;
		  &lt;/dxf:userAuthorityGroup&gt;
	}
      &lt;/dxf:userAuthorityGroups&gt;





      &lt;dxf:organisationUnits&gt;
        {	 
	  let $processOrgUnit := function($org) {
	    let $dhis_url := string($org/csd:record/@sourceDirectory)
	    let $dhis_uuid :=
	      if ($preserveUUIDs) 
	      then ($org/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="uuid"])[1]/text()
	      else ()
	    let $dhis_code := ($org/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="code"])[1]/text()
	   
	    let $level_code := string(($org/csd:codedType[@codingScheme=concat("urn:" ,$dhis_url,"/api/organisationUnitLevels")])[1]/@code)
	    let $level := 
	      if (not(functx:all-whitespace($level_code)))
	      then $level_code
	      else dxf2csd:get_level($doc,$org)

	    let $name := $org/csd:primaryName/text()

	    let $uuid :=
	      if ($preserveUUIDs)
	      then 
	        if (not(functx:all-whitespace($dhis_uuid)))
		then $dhis_uuid
	        else ()
	      else ()

	    let $entity_uuid := 
	      if (functx:all-whitespace($dhis_uuid))
	      then dxf2csd:extract_uuid_from_entityid(string($org/@entityID))
	      else string($dhis_uuid)


	    let $dhis_code := ($org/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="code"])[1]/text()

	    let $id_code := ($org/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="id"])[1]/text()
	    let $id :=
	      if (not(functx:all-whitespace($id_code)))
	      then $id_code
	      else dxf2csd:extract_id_from_entityid(string($org/@entityID)) 

	    let $created := dxf2csd:fixup_date($org/csd:record/@created)
	    let $lm := dxf2csd:fixup_date($org/csd:record/@updated)

	    let $porg_id := $org/csd:parent/@entityID
	    let $porg := $orgs[@entityID = $porg_id]
	    let $porg_dhis_uuid := ($porg/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="uuid"])[1]
	    let $parent :=
	      if (functx:all-whitespace($porg_id))
	      then () (: no parent :)
	      else if (not(functx:all-whitespace($porg_dhis_uuid)))
	      then &lt;dxf:parent uuid="{$porg_dhis_uuid}"/&gt;
  	      else &lt;dxf:parent id="{dxf2csd:extract_id_from_entityid(string($porg_id))}"/&gt;
	    let $avs :=
	      &lt;dxf:attributeValues&gt;
	        &lt;dxf:attributeValue&gt;
	  	  &lt;dxf:attribute name="entityID"/&gt;
		  &lt;dxf:value&gt;{$entity_uuid}&lt;/dxf:value&gt;
	        &lt;/dxf:attributeValue&gt;
	      &lt;/dxf:attributeValues&gt;
		    
	    return 
	      &lt;dxf:organisationUnit 
                level="{$level}"
		name="{$name}"
		shortName="{substring($name,1,50)}"
		id="{$id}"
		lastUpdated="{$lm}"
		created="{$created}"
		&gt;
		{
		  if (($preserveUUIDs) and (not(functx:all-whitespace($uuid))))
		  then attribute uuid {$uuid}
		  else ()
	        }
		{ 
	          if (functx:all-whitespace($dhis_code))
		  then ()
	          else attribute code {$dhis_code}
		}
		{$parent}
		{$avs}
		&lt;dxf:openingDate&gt;1970-01-01&lt;/dxf:openingDate&gt; 
	      &lt;/dxf:organisationUnit&gt;
	  }	  

	  let $orgunit_funcs :=     
  	    for $orgUnit in $orgs
	    return function() {$processOrgUnit($orgUnit)}

	  return async:fork-join($orgunit_funcs)

	}
        {
	  let $processFac := function($fac) {
	    let $dhis_url := string($fac/csd:record/@sourceDirectory)
	    let $dhis_uuid := ($fac/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="uuid"])[1]
	    let $dhis_id := ($fac/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="id"])[1]
            let $dhis_code := ($fac/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="code"])[1]/text()
	    return 
  	      let $level := dxf2csd:get_level($doc,$fac)
	      let $name := $fac/csd:primaryName/text()
	      let $uuid := 
	        if (functx:all-whitespace($dhis_uuid))
	        then dxf2csd:extract_uuid_from_entityid(string($fac/@entityID))
	        else string($dhis_uuid)
              let $id := 
	        if (functx:all-whitespace($dhis_id))
	        then dxf2csd:extract_id_from_entityid(string($fac/@entityID)) 
	        else string($dhis_id)
	      let $created := dxf2csd:fixup_date($fac/csd:record/@created)
	      let $lm := dxf2csd:fixup_date($fac/csd:record/@updated)

	      (: in CSD we can have multiple "parents" but not so DXF.  We just choose the first one    :)
	      let $org_id := ($orgs[@entityID = ($fac/csd:organizations/csd:organization)[1]/@entityID ])[1]
	      let $org := $orgs[@entity_id = $org_id]
	      let $org_dhis_uuid := ($org/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="uuid"])[1]
	      let $parent := 
	        if (functx:all-whitespace($org_id))
	        then ()  (: no parent :)
	        else if (not(functx:all-whitespace($org_dhis_uuid)))
	          then &lt;dxf:parent id="{$org_dhis_uuid}"/&gt;
	          else &lt;dxf:parent id="{dxf2csd:extract_id_from_entityid(string($org_id))}"/&gt;
	      let $avs :=
	        &lt;dxf:attributeValues&gt;
  		  &lt;dxf:attributeValue&gt;  
		    &lt;dxf:attribute name="entityID"/&gt;
		    &lt;dxf:value&gt;{$uuid}&lt;/dxf:value&gt;
		  &lt;/dxf:attributeValue&gt;
	        &lt;/dxf:attributeValues&gt;
	
	      return 
	        &lt;dxf:organisationUnit 
                  level="{$level}"
		  name="{$name}"
		  shortName="{substring($name,1,50)}"
		  lastUpdated="{$lm}"
		  created="{$created}"
		  &gt;
		  {
		    if (not(functx:all-whitespace($uuid)))
		    then attribute uuid {$uuid}
		    else ()
	          }
		  {
		    if (not(functx:all-whitespace($id)))
		    then attribute id {$id}
		    else ()
	          }
		  { 
		   if (functx:all-whitespace($dhis_code))
		   then ()
		   else attribute code {$dhis_code}
		  }
		 {$parent}
		 {$avs}
		 &lt;dxf:openingDate&gt;1970-01-01&lt;/dxf:openingDate&gt; 
	       &lt;/dxf:organisationUnit&gt;
	  }

	  let $fac_funcs :=     
  	    for $fac in $facilities
	    let $dhis_url := string($fac/csd:record/@sourceDirectory)
	    let $dhis_uuid := ($fac/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="uuid"])[1]
	    let $dhis_id := ($fac/csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="id"])[1]
	    let $org := 
	      if (functx:all-whitespace($dhis_uuid))
	      then ()
	      else ($orgs[./csd:otherID[@assigningAuthorityName=concat($dhis_url,"/api/organisationUnits") and @code="uuid" and ./text() = $dhis_uuid]])[1]
	    where not(exists($org)) 	    (: remove the facilities that have already been created from a DHIS2 org unit:)

	    return function() {$processFac($fac)}

	  return async:fork-join($fac_funcs)

	}
      &lt;/dxf:organisationUnits&gt;


      &lt;dxf:organisationUnitGroups&gt;    
        {
	  
	  let $ou_group_schemes := distinct-values((
	    $req_ou_group_schemes,
	    for $oid in $ou_oids return  concat($oid,'.3')
	      ))
	    
	  for $ou_group_scheme in $ou_group_schemes
	  let $types :=  svs_lsvs:get_single_version_value_set(string($ou_group_scheme) )	  

	  let $org_unit_groups :=   
  	    for $concept in $types//svs:Concept
	    let $code := string($concept/@code)
	    let $scheme := string($concept/@codeSystem)
	    let $name := string($concept/@displayName)
	    return &lt;dxf:organisationUnitGroup code="{$code}" name="{$name}" /&gt;

	  for $org_unit_group in $org_unit_groups
	  let $code := string($org_unit_group/@code)
	  let $scheme := string($org_unit_group/@codeSystem)
	  let $name := string($org_unit_group/@name)
	  let $short_name := substring(string($org_unit_group/@name),1,50)
	    return 
	    &lt;dxf:organisationUnitGroup code="{$code}" name="{$name}" shortName="{$short_name}"&gt;
	      &lt;dxf:organisationUnits&gt;
		{
		  for $ent in ($facilities,$orgs)[./csd:codedType[@codingScheme = $scheme and @code = $code]]
		  let $uuid := dxf2csd:extract_uuid_from_entityid($ent/@entityID)
		  let $ent_name := $ent/csd:primaryName/text()
		  let $id := dxf2csd:extract_id_from_entityid(string($ent/@entityID)) 
		  return     
		     &lt;dxf:organisationUnit uuid="{$uuid}" id="{$id}" name="{$ent_name}" /&gt;
		}
	      &lt;/dxf:organisationUnits&gt;
	    &lt;/dxf:organisationUnitGroup&gt;
	}
      &lt;/dxf:organisationUnitGroups&gt;


      &lt;dxf:organisationUnitLevels&gt;
	{
	  
	  for $oid in $ou_oids
            let $level_oid := concat($oid,'.2')
	    let $svs := svs_lsvs:get_single_version_value_set($level_oid)
	    return
	      if (not(exists($svs)))
	      then ()
              else 
		for $val in $svs//svs:concept
		return 
		  &lt;dxf:organisationUnitLevel name="{$val/@displayName}" id="{$val/@code}"/&gt;

	}
       
      &lt;/dxf:organisationUnitLevels&gt;

    &lt;/dxf:metaData&gt;


let $out := 
  if ($zip)
  then archive:create(   &lt;archive:entry&gt;csd_dxf.xml&lt;/archive:entry&gt;, serialize($dxf))
  else $dxf

return $out</pre></span>
      </div>
    </div>
    <a id="urn:dhis2.org:csd:stored-function:dxf2csd"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:dhis2.org:csd:stored-function:dxf2csd</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Updates the CSD document with a transform of the DHIS2 DXF.  
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace dxf2csd = "http://dhis2.org/csd/dxf/2.0";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";


declare variable $careServicesRequest as item() external;


let $csd := dxf2csd:extract-directory($careServicesRequest/dxf,$careServicesRequest/oid)
let $doc_name := string($careServicesRequest/@resource)
let $doc := csd_dm:open_document($doc_name)
return  csd_dm:add($csd,$doc_name)

</pre></span>
      </div>
    </div>
    <a id="urn:dhis2.org:csd:stored-function:dxf2svs"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:dhis2.org:csd:stored-function:dxf2svs</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Update SVS lists from a DHIS2 MetaData Export
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace dxf2csd = "http://dhis2.org/csd/dxf/2.0";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace svs_lsvs = "https://github.com/openhie/openinfoman/svs_lsvs";

declare namespace dxf = "http://dhis2.org/schema/dxf/2.0";
declare namespace svs = "urn:ihe:iti:svs:2008";

declare variable $careServicesRequest as item() external;



let $version := concat(year-from-date(current-date()),'.',month-from-date(current-date()),'.',day-from-date(current-date()))

return (
  let $list_name := "DHIS2 Organization Unit Levels"
  let $id := dxf2csd:oid_orgtype($careServicesRequest/oid/text())
  let $svs := 
  &lt;svs:ValueSet id="{$id}" version="{$version}" displayName="{$list_name}"&gt;
    &lt;svs:ConceptList xml:lang="en-US"&gt;
      {
	for $level in $careServicesRequest/dxf/dxf:metaData/dxf:organisationUnitLevels/dxf:organisationUnitLevel
	return   &lt;svs:Concept code="{$level/@level}" displayName="{$level/@name}" codeSystem="{$id}"/&gt;
      }
    &lt;/svs:ConceptList&gt;
  &lt;/svs:ValueSet&gt;
  return svs_lsvs:insert($svs)
  ,
  let $list_name := "DHIS2 User Role List"
  let $id := dxf2csd:oid_hwtype($careServicesRequest/oid/text())
  let $svs := 
  &lt;svs:ValueSet id="{$id}" version="{$version}" displayName="{$list_name}"&gt;
    &lt;svs:ConceptList xml:lang="en-US"&gt;
      {
        for $role in $careServicesRequest/dxf/dxf:metaData/dxf:userRoles/dxf:userRole
        return   &lt;svs:Concept code="{$role/@id}" displayName="{$role/@name}" codeSystem="{$id}"/&gt;
      }
    &lt;/svs:ConceptList&gt;
  &lt;/svs:ValueSet&gt;
  return svs_lsvs:insert($svs)
)

</pre></span>
      </div>
    </div>
    <a id="urn:dhis.org:extract_from_dxf:v2.19"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:dhis.org:extract_from_dxf:v2.19</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    
This extracts all organisation units matching the given facility conditions as a CSD facility entity.  
It also extracts all organisation units a CSD organization entity.  
In the case that a CSD facility entity is created, it will have as an organizational association to it's corresponding organization entity.
These two entities will have distinct entity IDs (UUIDs)

This Also creates SVS for relevant terminologies (e.g. Organisation Unit Groups and Levels )

Imports: DHIS2 metadata export of Organsation Units, Organisation Unit Group,  Organisation Unit Group Set, Organization Unit Level from DHIS2 2.19

This optionally processes DHIS2 Users as health workers (CSD Providers).
In order to do so, you will need to have included Users, UserRoles and UserAuthorityGroups in your DXF2 meta-data extract.

    
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>declare namespace csd = "urn:ihe:iti:csd:2013"; 

declare namespace svs = "urn:ihe:iti:svs:2008";
declare namespace dxf = "http://dhis2.org/schema/dxf/2.0";
declare namespace adx = "http://www.openhie.org/adx";

import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace svs_lsvs = "https://github.com/openhie/openinfoman/svs_lsvs";
import module namespace functx = "http://www.functx.com";
import module namespace util = "https://github.com/openhie/openinfoman-dhis/util";
import module namespace async = "http://basex.org/modules/async";

declare variable $careServicesRequest as item() external; 



let $dhis_url := replace($careServicesRequest/URL/text(),'/+$','')
let $namespace_uuid := util:uuid_generate($dhis_url,$util:namespace_uuid)

let $dxf := $careServicesRequest/dxf
let $facility_group_codes := $careServicesRequest/groupCodes/groupCode/text()
let $facility_levels := $careServicesRequest/levels/level/text()
let $do_hws :=  ($careServicesRequest/usersAreHealthWorkers/text() = '1')
let $do_srvcs :=  ($careServicesRequest/dataelementsAreServices/text() = '1')

let $t_oid := $careServicesRequest/oid/text()  
let $oid :=      
  if (not(functx:all-whitespace($t_oid)))
  then $t_oid
  else 
    (:generate it from the uuid :)
    concat('2.25.',util:hexdec(util:uuid_generate('rootoid',$namespace_uuid)))

let $orgUnits := $dxf/dxf:metaData/dxf:organisationUnits/dxf:organisationUnit
let $orgGroups := $dxf/dxf:metaData/dxf:organisationUnitGroups/dxf:organisationUnitGroup
let $userRoles := $dxf/dxf:metaData/dxf:userRoles
let $dataSets := $dxf/dxf:metaData/dxf:dataSets
let $dataElements := $dxf/dxf:metaData/dxf:dataElements
let $catCombos := $dxf/dxf:metaData/dxf:categoryCombos
  
let $doc_name := string($careServicesRequest/@resource)
let $doc := csd_dm:open_document($doc_name)
let $org_dir := $doc/csd:CSD/csd:organizationDirectory
let $fac_dir := $doc/csd:CSD/csd:facilityDirectory
let $prov_dir := $doc/csd:CSD/csd:providerDirectory
let $srvc_dir := $doc/csd:CSD/csd:serviceDirectory

let $now := current-dateTime()



(: cache some node calculations :)
let $org_otherids := $org_dir/csd:organization/csd:otherID[@code='id']
let $orggroups_by_ou := $orgGroups/dxf:organisationUnits/dxf:organisationUnit

let $process_orgunit := function($orgUnit) {
  let $level := xs:integer($orgUnit/@level)
  let $id := $orgUnit/@id
  let $uuid := string($orgUnit/@uuid)

  let $displayName:=string($orgUnit/@name)
  let $org_code:=string($orgUnit/@code)
  let $pid:=string($orgUnit/dxf:parent/@id)

  let $lm := util:fixup_date($orgUnit/@lastUpdated)
  let $created := util:fixup_date($orgUnit/@created)
  let $groups := $orggroups_by_ou[@id = $id]/../..  (:clause should expect to match more than one. go to grandparent orgUnitGroup's :)
(:  let $groups := $orgGroups[./dxf:organisationUnits/dxf:organisationUnit[@id = $id]] :)
  let $group_codes := $groups/@code

  (:if there is an existing CSD UUID / entityID in DHIS2 we should keep it to referencer the org unit :)
  let $entity_uuid :=((($orgUnit/dxf:attributeValues/dxf:attributeValue[./dxf:attribute[@name='entityID']])[1])/dxf:value[1])/text()
  let $facEntityID := concat("urn:uuid:",util:uuid_generate(concat('facility:',$id),$namespace_uuid))
  let $orgEntityID :=
    if (not(functx:all-whitespace($entity_uuid)))
    then concat("urn:uuid:",$entity_uuid)
    else if (not(functx:all-whitespace($uuid)))
    then concat("urn:uuid:",$uuid)  
    else  concat("urn:uuid:",util:uuid_generate(concat('organization:',$id),$namespace_uuid))

          
  (:the parent org may be:
     1) in the dxf document being imported (highest precedence)
     2) in the destination csd document
     3) nowhere 

    in the case of 1) we want the parent's csd entity id to match the entity id of the parent org unit being imported
       case 1) happens if $porg is found
    in the case of 2) we want to use the parent id of the 
       in case is if $porg is not found but there is a csd:organization with the correct entity if in the dest. doc
    in the case of 3) we want to put it under our global root element for the import
    :)
    
  let $porg := ($orgUnits[@id=$pid])[1]
  let $parentEntityID :=     
    if (exists($porg))  (: there is a matching parent organization in the imported dxf document :)
    then  
      (:see if there is a DHIS2 attribute for the csd_entity ID :)
      let $p_entity_uuid :=((($porg/dxf:attributeValues/dxf:attributeValue[./dxf:attribute[@name='entityID']])[1])/dxf:value[1])/text()
      let $p_uuid := string($porg/@uuid)
      return
        if (not(functx:all-whitespace($p_entity_uuid))) 
        then concat("urn:uuid:",$p_entity_uuid)
	else if (not(functx:all-whitespace($p_uuid)))
        then concat("urn:uuid:",$p_uuid)
        else concat("urn:uuid:",util:uuid_generate(concat('organization:',$pid),$namespace_uuid))
    else (: we didn't find a matching parent organization in the dxf document, but may already be in target:)
      let $peorg := ($org_otherids[./text() = $pid])[1]/..  (: get the parent csd:organization element :)
(:      let $peorg := ($org_dir/csd:organization[./csd:otherID[@code='id' and ./text() = $pid]])[1] :)
      return
	if (exists($peorg))
        then $peorg/@entityID
        else ()

(:   let $puuid :=
     if (exists($porg))
     then  $porg/@uuid
     else if (exists($peorg))
     then  $peorg/@entityID
     else false
:)	  

  let $mainname := &lt;csd:primaryName&gt;{$displayName}&lt;/csd:primaryName&gt;

  (:set up local identifiers:)
  let $other_ids := (
    &lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/organisationUnits" code="id"&gt;{string($id)}&lt;/csd:otherID&gt;
    ,
    if (not(functx:all-whitespace($org_code)))
    then &lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/organisationUnits" code="code"&gt;{string($org_code)}&lt;/csd:otherID&gt;
    else ()
    ,
    if (not(functx:all-whitespace($uuid)))
    then &lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/organisationUnits" code="uuid"&gt;{string($uuid)}&lt;/csd:otherID&gt;
    else ()
    )

  (:set up codes:)
  let $level_code := &lt;csd:codedType code="{$level}" codingScheme="urn:{$dhis_url}/api/organisationUnitLevels"/&gt;
  let $group_cts :=
    for $group_code in $group_codes
    return &lt;csd:codedType codingScheme="urn:{$dhis_url}/api/organisationUnitGroups" code="{$group_code}" /&gt;

  let $geo_data :=
     (
       util:get_geocode($orgUnit)
       ,util:get_shape($orgUnit)
     )
  let $name := &lt;csd:primaryName&gt;{string($orgUnit/@name)}&lt;/csd:primaryName&gt;
  let $record :=  &lt;csd:record created="{$created}" updated="{$lm}" status="Active" sourceDirectory="{$dhis_url}"/&gt;
    

  (:first we extract all org units matching our facility conditions :)
  let $fac_srvcs :=
    if (not($do_srvcs))
    then ()
    else 
      (: get data sets that are associated to this org unit :)
      let $dsets := $dataSets/dxf:dataSet[dxf:organisationUnits/dxf:organisationUnit/@id = $id]
      return 
	(
	  (:each data set is a service :)
	  for $ds in $dsets
	  let $ds_id := string($ds/@id)
	  let $ds_uuid := string($ds/@uuid)
	  let $ds_entityID :=
	    if (not(functx:all-whitespace($ds_uuid)))
	    then concat("urn:uuid:",$ds_uuid)  
	    else  concat("urn:uuid:",util:uuid_generate(concat('service:',$ds_id),$namespace_uuid))
	  return &lt;csd:service entityID="{$ds_entityID}"/&gt;    
	  ,
	  (:each data element is a service :)
	  let $des :=
            for $dset in $dsets
	    return $dataElements/dxf:dataElement[@id = $dset/dxf:dataElements/dxf:dataElement/@id]
	  return 
            for $de in  $des
	    let $de_id := $de/@id
	    let $de_uuid := $de/@uuid
	    let $srvc_entity_id := 
	      if (not(functx:all-whitespace($de_uuid)))
	      then concat("urn:uuid:",$de_uuid)
	      else concat("urn:uuid:",util:uuid_generate(concat('service:',$de_id),$namespace_uuid))
	    return &lt;csd:service entityID="{$srvc_entity_id}"/&gt;
	  )

  let $fac_entity :=
    if (($group_codes = $facility_group_codes) or ( $level = $facility_levels)) 
    then
      &lt;csd:facility entityID="{$facEntityID}"&gt;
	{$other_ids}
	{$level_code}
	{$group_cts}
	{$mainname}
	{$geo_data}
	&lt;csd:organizations&gt;&lt;csd:organization entityID="{$orgEntityID}"&gt;{$fac_srvcs}&lt;/csd:organization&gt;&lt;/csd:organizations&gt;
	{$record}
      &lt;/csd:facility&gt;
    else ()

  (:next we create an organization for each organisation unit.

    NOTE: this means that each organisation unit which matches as a facility will have two CSD 
          entities created a facility and an organization.  These two entities will have distinct
          UUIDs.  
   :)
     (:Should put in a CP to point geo codes for orgs as service delivery area :)

  let $org_entity :=
  &lt;csd:organization entityID="{$orgEntityID}"&gt;
      {$other_ids}
      {$level_code}
      {$group_cts}
      {$mainname}
      {$geo_data}
      &lt;csd:parent  entityID="{$parentEntityID}"/&gt;
      {$record}
    &lt;/csd:organization&gt;
  return ($org_entity,$fac_entity)

}


let $entities :=  
  let $orgunit_funcs :=     
    for $orgUnit in $orgUnits
    return function() {$process_orgunit($orgUnit)}
  return async:fork-join($orgunit_funcs)



let $process_users := function($user) {  
    let $id := string($user/@id)
    let $entityID := concat("urn:uuid:",util:uuid_generate(concat('provider:',$id),$namespace_uuid))
    let $ur_oid := concat($oid,'.1')
    let $ag_oid := concat($oid,'.4')
    let $uuid := string($user/@uuid)
    let $code:=string($user/dxf:userCredentials/@code)
    let $fore := $user/dxf:firstName/text()
    let $sur := $user/dxf:surname/text()
    let $email := $user/dxf:email/text()
    let $phone := $user/dxf:phoneNumber/text()
    let $lm := util:fixup_date($user/@lastUpdated)
    let $created := util:fixup_date($user/@created)
    let $urs := $user/dxf:userCredentials/dxf:userRoles/dxf:userRole
    let $ags := $user/dxf:userCredentials/dxf:userAuthorityGroups/dxf:userAuthorityGroup


    let $entity_uuid :=((($user/dxf:attributeValues/dxf:attributeValue[./dxf:attribute[@name='entityID']])[1])/dxf:value[1])/text()
    let $provEntityID :=
      if (not(functx:all-whitespace($entity_uuid)))
      then concat("urn:uuid:",$entity_uuid)
      else if (not(functx:all-whitespace($uuid)))
      then concat("urn:uuid:",$uuid)  
      else  concat("urn:uuid:",util:uuid_generate(concat('provider:',$id),$namespace_uuid))

    return 
    &lt;csd:provider entityID="{$provEntityID}"&gt;
      &lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/users" code="id"&gt;{$id}&lt;/csd:otherID&gt;
      {
	if (not(functx:all-whitespace($code)))
	then &lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/users" code="code"&gt;{$code}&lt;/csd:otherID&gt;
        else ()
      }
      {
	if (not(functx:all-whitespace($uuid)))
	then &lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/users" code="uuid"&gt;{$uuid}&lt;/csd:otherID&gt;
	else ()
      }
      {
	for $ag in $ags
	return 
	&lt;csd:codedType code="{$ag/@id}" codingScheme="{$ag_oid}"/&gt;
      }
      {
	for $ur in $urs
	return 
	&lt;csd:codedType code="{$ur/@id}" codingScheme="{$ur_oid}"/&gt;
      }
      {
	if (count(($urs,$ags)) = 0) 
	  then &lt;csd:codedType code="NOROLE" codingScheme="{$ur_oid}"/&gt;
	else ()

      }
      &lt;csd:demographic&gt;
	&lt;csd:name&gt;
	  &lt;csd:commonName&gt;{$sur}, {$fore}&lt;/csd:commonName&gt;
	  &lt;csd:forename&gt;{$fore}&lt;/csd:forename&gt;
	  &lt;csd:surname&gt;{$sur}&lt;/csd:surname&gt;
	&lt;/csd:name&gt;
	{
	  if ($phone) then
	  &lt;csd:contactPoint&gt;
	    &lt;csd:codedType code="BP" codingScheme="urn:ihe:iti:csd:2013:contactPoint"&gt;{$phone}&lt;/csd:codedType&gt;
	  &lt;/csd:contactPoint&gt;
        else ()
	}
	{
	  if ($email) then
	  &lt;csd:contactPoint&gt;
	    &lt;csd:codedType code="EMAIL" codingScheme="urn:ihe:iti:csd:2013:contactPoint"&gt;{$email}&lt;/csd:codedType&gt;
	  &lt;/csd:contactPoint&gt;
	else ()
	}
      &lt;/csd:demographic&gt;
      {
	let $torgs := $user/dxf:organisationUnits/dxf:organisationUnit
	let $orgs := 
          for $torg in $torgs 
	  let $tid :=  $torg/@id
	  let $torg1 := ($orgUnits[@id=$tid])[1]
	  let $entity_uuid :=((($torg1/dxf:attributeValues/dxf:attributeValue[./dxf:attribute[@name='entityID']])[1])/dxf:value[1])/text()

    	  let $orgEntityID :=
	     if (not(functx:all-whitespace($entity_uuid)))
	     then concat("urn:uuid:" , $entity_uuid)
	     else concat("urn:uuid:",util:uuid_generate(concat('organization:',string($torg/@id)),$namespace_uuid))
          where  (exists($entities[@entityID = $orgEntityID]) or exists( $org_dir/csd:organization[@entityID = $orgEntityID]))
	  return &lt;csd:organization entityID="{$orgEntityID}"/&gt;
	  
	return 
	  if (count($orgs) &gt; 0) then
	  &lt;csd:organizations&gt;{$orgs}&lt;/csd:organizations&gt;
	  else ()
      }
      {
	let $tfacs := $user/dxf:organisationUnits/dxf:organisationUnit
	let $facs := 
          for $tfac in $tfacs 
	  let $tfac_id := $tfac/@id
    	  let $facEntityID := concat("urn:uuid:",util:uuid_generate(concat('facility:',string($tfac_id)),$namespace_uuid))
	  let $fac_srvcs := 
	    if (not($do_srvcs))
	    then ()
	    else 
	      for $r in $urs
	      let $r_id := $r/@id
	      let $role := ($userRoles/dxf:userRole[@id = $r_id])[1]
	      for $ds_ref in $role/dxf:dataSets/dxf:dataSet
	        let $ds_id := $ds_ref/@id
		let $ds := ($dataSets/dxf:dataSet[@id = $ds_id])[1]
		let $ds_orgunit := $ds/dxf:organisationUnits/dxf:organisationUnit[@id = $tfac_id]
		for $de in  $ds_orgunit/../../dxf:dataElements/dxf:dataElement
		  let $de_id := $de/@id
		  let $de_uuid := $de/@uuid
		  let $srvc_entity_id := 
		    if (not(functx:all-whitespace($de_uuid)))
		    then concat("urn:uuid:",$de_uuid)
		    else concat("urn:uuid:",util:uuid_generate(concat('service:',$de_id),$namespace_uuid))
	          return &lt;csd:service entityID="{$srvc_entity_id}"/&gt;
	  where  (exists($entities[@entityID = $facEntityID]) or exists( $org_dir/csd:facility[@entityID = $facEntityID]))
	  return &lt;csd:facility entityID="{$facEntityID}"&gt;{$fac_srvcs}&lt;/csd:facility&gt;
	  
	return 
	  if (count($facs) &gt; 0) then
	  &lt;csd:facilities&gt;{$facs}&lt;/csd:facilities&gt;
	  else ()
      }
    &lt;csd:record created="{$created}" updated="{$lm}" status="106-001" sourceDirectory="{$dhis_url}"/&gt;
    &lt;/csd:provider&gt;
}


let $process_dataelements := function($de) {
    let $de_id := string($de/@id)
    let $name := string($de/@name)
    let $code := string($de/@code)
(:    let $entityID := concat("urn:uuid:",util:uuid_generate(concat('service:',$de_id),$namespace_uuid)) :)
    let $cat_id := $de/dxf:categoryCombo/@id
    let $cc :=  ($catCombos/dxf:categoryCombo[@id = $cat_id])[1]
    let $cc_code := string($cc/@code)
    let $created := util:fixup_date($de/@created)
    let $lm := util:fixup_date($de/@lastUpdated)

    let $uuid := string($de/@uuid)
    let $entity_uuid :=((($de/dxf:attributeValues/dxf:attributeValue[./dxf:attribute[@name='entityID']])[1])/dxf:value[1])/text()
    let $srvcEntityID :=
      if (not(functx:all-whitespace($entity_uuid)))
      then concat("urn:uuid:",$entity_uuid)
      else if (not(functx:all-whitespace($uuid)))
      then concat("urn:uuid:",$uuid)  
      else  concat("urn:uuid:",util:uuid_generate(concat('service:',$de_id),$namespace_uuid))
 

(:
    let $cc_id := $cc/@id
    let $cc_oid := string-join(for $cp in string-to-codepoints(string($cc_id)) return string($cp))
:)  
    let $disaggregatorSet := 
      for $disag in  $cc/dxf:categories/dxf:category
      let $disag_id := $disag/@id
      let $disag_code := $disag/@code
      let $disag_oid := string-join(for $cp in string-to-codepoints(string($disag_code)) return string($cp))
      let $doid :=  concat($oid , '.6.' , $disag_oid )
      let $attr_display:= string($disag/@name)
      let $attr := $disag_code
	(:need to be able to make it into an attribute for compatibility with ADX :)
(:
        try {
	  attribute {xs:string($disag_code)} {()}
	} catch * {
	  ''
	}
:)
      let $attr_name := string($attr)
      where ( not(functx:all-whitespace($attr_name))  and  not($attr_display = 'default')) 
      return &lt;adx:disaggregator  id="{$doid}" refid="{$disag_id}" code="{$attr_name}"&gt;{$attr_display}&lt;/adx:disaggregator&gt;

    return 
      &lt;csd:service entityID="{$srvcEntityID}"&gt;
	&lt;csd:primaryName&gt;{$name}&lt;/csd:primaryName&gt;
	&lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/dataElements" code="id"&gt;{$de_id}&lt;/csd:otherID&gt;
	{     
	  if (not(functx:all-whitespace($uuid)))
	  then &lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/dataElements" code="uuid"&gt;{string($uuid)}&lt;/csd:otherID&gt;
	  else ()
	}
	{ if (not(functx:all-whitespace($code)))
	  then &lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/dataElements" code="code"&gt;{$code}&lt;/csd:otherID&gt;
	  else ()
	}

	{
	  if (count($disaggregatorSet) = 0) 
	  then ()
	  else 
	    &lt;csd:extension urn="urn:http://www.openhie.org/adx" type="disaggregators"&gt;
	      &lt;adx:disaggregatorSet id="{$cat_id}" code="{$cc_code}"&gt;
		{$disaggregatorSet}
	      &lt;/adx:disaggregatorSet&gt;
	    &lt;/csd:extension&gt;
	}
	{
	   &lt;csd:extension urn="urn:http://www.dhis2.org/api/dataElement"&gt;
	     &lt;dxf:dataElement shortname="{$de/@shortName}"&gt;
	       {$de/dxf:aggregationType}
	       {$de/dxf:dataDimension}
	       {$de/dxf:domainType}
	       {$de/dxf:type}
	       {$de/dxf:numberType}
	       {$de/dxf:aggregationOperator}
	       {$de/dxf:url}
	       {$de/dxf:zeroIsSignificant}
	     &lt;/dxf:dataElement&gt;
	   &lt;/csd:extension&gt;
	}

	&lt;csd:record 
          created="{util:fixup_date($de/@created)}" 
          updated="{util:fixup_date($de/@lastUpdated)}" 
          status="Active" 
	  sourceDirectory="{$dhis_url}"/&gt;        
      &lt;/csd:service&gt;

}


let $process_dataset := function($ds) {
    let $ds_id := string($ds/@id)
    let $des := $ds/dxf:dataElements/dxf:dataElement
    let $name := string($ds/@name)
    let $s_name := string($ds/@shortName)
    let $pt := string($ds/dxf:periodType) 
    let $code := string($ds/@code)

    let $uuid := string($ds/@uuid)
    let $entityID :=
      if (not(functx:all-whitespace($uuid)))
      then concat("urn:uuid:",$uuid)  
      else  concat("urn:uuid:",util:uuid_generate(concat('service:',$ds_id),$namespace_uuid))


    let $cat_id := $ds/dxf:categoryCombo/@id
    let $cc :=  ($catCombos/dxf:categoryCombo[@id = $cat_id])[1]
    let $cc_code := string($cc/@code)

    let $disaggregatorSet := 
      for $disag in  $cc/dxf:categories/dxf:category
      let $disag_id := $disag/@id
      let $disag_code := $disag/@code
      let $disag_oid := string-join(for $cp in string-to-codepoints(string($disag_code)) return string($cp))
      let $doid :=  concat($oid , '.6.' , $disag_oid )
      let $attr_display:= string($disag/@name)
      let $attr := $disag_code
      let $attr_name := string($attr)
      where ( not(functx:all-whitespace($attr_name))  and  not($attr_display = 'default')) 
      return &lt;adx:disaggregator  id="{$doid}"  code="{$attr_name}"&gt;{$attr_display}&lt;/adx:disaggregator&gt;
 
    return 
      &lt;csd:service entityID="{$entityID}"&gt;
	&lt;csd:primaryName&gt;{$name}&lt;/csd:primaryName&gt;
	&lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/dataSets" code="id"&gt;{$ds_id}&lt;/csd:otherID&gt;
	{     
	  if (not(functx:all-whitespace($uuid)))
	  then &lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/dataSets" code="uuid"&gt;{string($uuid)}&lt;/csd:otherID&gt;
	  else ()
	}
	{ if (not(functx:all-whitespace($code)))
	  then &lt;csd:otherID assigningAuthorityName="{$dhis_url}/api/dataSets" code="code"&gt;{$code}&lt;/csd:otherID&gt;
	  else ()
	}
	{
	  if (count($disaggregatorSet) = 0) 
	  then ()
	  else 
	    &lt;csd:extension urn="urn:http://www.openhie.org/adx" type="disaggregators"&gt;
	      &lt;adx:disaggregatorSet id="{$cat_id}" code="{$cc_code}"&gt;
		{$disaggregatorSet}
	      &lt;/adx:disaggregatorSet&gt;
	    &lt;/csd:extension&gt;
	}

	{
	  if (count($des) = 0) 
	  then ()
	  else 
	    &lt;csd:extension urn="urn:http://www.openhie.org/adx" type="dataSet"&gt;
	      {
              for $de in $des
	      let $de_id := string($de/@id)
	      let $uuid := string($de/@uuid)
	      let $entity_uuid :=((($de/dxf:attributeValues/dxf:attributeValue[./dxf:attribute[@name='entityID']])[1])/dxf:value[1])/text()
	      let $srvcEntityID :=
		if (not(functx:all-whitespace($entity_uuid)))
		then concat("urn:uuid:",$entity_uuid)
	        else if (not(functx:all-whitespace($uuid)))
		then concat("urn:uuid:",$uuid)  
	        else  concat("urn:uuid:",util:uuid_generate(concat('service:',$de_id),$namespace_uuid))
 	      return &lt;csd:service entityID="{$srvcEntityID}"/&gt;
	      }
	    &lt;/csd:extension&gt;
	}

	&lt;csd:record 
          created="{util:fixup_date($ds/@created)}" 
          updated="{util:fixup_date($ds/@lastUpdated)}" 
          status="Active" 
	  sourceDirectory="{$dhis_url}"/&gt;        
      &lt;/csd:service&gt;


(:    let $entityID := concat("urn:uuid:",util:uuid_generate(concat('service:',$de_id),$namespace_uuid)) :)

}




let $process_categories := function($category) {
    let $disag_code := string($category/@code)
    let $disag_oid := string-join(for $cp in string-to-codepoints(string($disag_code)) return string($cp))      
    let $disag_date := xs:dateTime(substring(string($category/@lastUpdated),1,19))
    let $disag_name := string($category/@name)
    let $disag_id := string($category/@id)
    let $svs_vals_0 :=    
      for $catOption in $category/dxf:categoryOptions/dxf:categoryOption
      let $disag_opt_date := xs:dateTime(substring(string($catOption/@lastUpdated),1,19))
      let $disag_opt_name := string($catOption/@name)
      let $date := max(($disag_date,$disag_date,$disag_opt_date))
      where (not((functx:all-whitespace($disag_opt_name)) )) 
      return &lt;svs:Concept code="{$disag_opt_name}" displayName="{$disag_opt_name}" codeSystem="{$dhis_url}/adx/disaggregators/{$disag_code}" lu="{$date}"/&gt;

    let $date := max(( for $d in $svs_vals_0/@lu return xs:dateTime($d)))
    let $svs_vals_1 := functx:remove-attributes-deep($svs_vals_0,'lu')
    
    let $oid :=  concat($oid , '.6.' , $disag_oid)	

    let $attr := $disag_code

    let $svs_doc :=
      &lt;svs:ValueSet  xmlns:svs="urn:ihe:iti:svs:2008" id="{$oid}" version="{$date}" displayName="[ADX {$disag_code}] Disaggregator for {$disag_name}. ( {$disag_id
} ) Published {$date}.  "&gt;
	&lt;svs:ConceptList xml:lang="en-US" &gt;{$svs_vals_1}&lt;/svs:ConceptList&gt;
      &lt;/svs:ValueSet&gt;
    where ( not(functx:all-whitespace($disag_code))  and not($disag_name = 'default'))   
    return $svs_doc
}
	

(: create dhis2 users as health workers/providers if requested :)

let $providers := 
  if (not($do_hws))
  then ()
  else 
    let $prov_funcs := 
      for $user in $dxf/dxf:metaData/dxf:users/dxf:user 
      return function() {$process_users($user)}
    return async:fork-join($prov_funcs)


(: Create CSD Services for DHIS2 Data Elements :) 


let $srvcs := 
  if (not($do_srvcs))
  then ()
  else 
    (
    let $de_funcs := 
      for $de in ($dataElements/dxf:dataElement)
      return function() {$process_dataelements($de)}
    return async:fork-join($de_funcs)
    ,
    let $ds_funcs := 
      for $ds in $dataSets/dxf:dataSet
      return function() {$process_dataset($ds)}
    return async:fork-join($ds_funcs)
    )


(: Create an SVS list for each of the disaggregator sets in  the service :)
let $categories := $dxf/dxf:metaData/dxf:categories/dxf:category

let $svs_srvcs := 
  if (not($do_srvcs))
  then ()
  else
(:    for $category in $categories :)
    let $cat_funcs := 
       for $category in $categories[ @id  = $catCombos/dxf:categoryCombo/dxf:categories/dxf:category/@id]
       return function() {$process_categories($category)}
    return async:fork-join($cat_funcs)



(: Create an SVS list for the Org Unit Levels :)
	
let $level_oid := concat($oid,'.2')
let $levels := $dxf/dxf:metaData/dxf:organisationUnitLevels/dxf:organisationUnitLevel
let $level_version := max(for $date in $levels/@lastUpdated return xs:dateTime(util:fixup_date($date)))
let $svs_levels :=
  &lt;svs:ValueSet  xmlns:svs="urn:ihe:iti:svs:2008" id="{$level_oid}" version="{$level_version}" displayName="Organisation Unit Levels for DHIS at {$dhis_url}"&gt;
    &lt;svs:ConceptList xml:lang="en-US" &gt;
      {
	for $level in $levels
	return &lt;svs:Concept code="{$level/@level}" displayName="{$level/@name}" codeSystem="{$dhis_url}/api/organisationUnitLevels" /&gt;
      }
    &lt;/svs:ConceptList&gt;
  &lt;/svs:ValueSet&gt;


(: Create an SVS list for the Org Unit Groups :)
let $group_oid := concat($oid,'.3')
let $group_version := max(for $date in $orgGroups/@lastUpdated return xs:dateTime(util:fixup_date($date)))
let $svs_groups :=
  &lt;svs:ValueSet  xmlns:svs="urn:ihe:iti:svs:2008" id="{$group_oid}" version="{$group_version}" displayName="Organisation Unit Groups at {$dhis_url}"&gt;
    &lt;svs:ConceptList xml:lang="en-US" &gt;
      {
	for $group in $orgGroups
	return &lt;svs:Concept code="{$group/@code}" displayName="{$group/@name}" codeSystem="{$dhis_url}/api/organisationUnitGroups" /&gt;
      }
    &lt;/svs:ConceptList&gt;
  &lt;/svs:ValueSet&gt;



let $svs_providers := 
  if (not($do_hws))
  then ()
  else 
    let $urs := $dxf/dxf:metaData/dxf:userRoles/dxf:userRole
    let $ags := $dxf/dxf:metaData/dxf:userAuthorityGroups/dxf:userAuthorityGroup
    let $urs_version := max(for $date in $urs/@lastUpdated return xs:dateTime(util:fixup_date($date)))
    let $ags_version := max(for $date in $ags/@lastUpdated return xs:dateTime(util:fixup_date($date)))
    let $ur_oid := concat($oid,'.1')
    let $ag_oid := concat($oid,'.4')
    let $svs_urs := 
      &lt;svs:ValueSet  xmlns:svs="urn:ihe:iti:svs:2008" id="{$ur_oid}" version="{$group_version}" displayName="User Role at {$dhis_url}"&gt;
	&lt;svs:ConceptList xml:lang="en-US" &gt;
	  {
	    for $ur in ($urs,&lt;userRole id='NOROLE' name='No Role'/&gt;)
	    return &lt;svs:Concept code="{$ur/@id}" displayName="{$ur/@name}" codeSystem="{$dhis_url}/api/userRoles" /&gt;
	  }
	&lt;/svs:ConceptList&gt;
      &lt;/svs:ValueSet&gt;
    let $svs_ags := 
      &lt;svs:ValueSet  xmlns:svs="urn:ihe:iti:svs:2008" id="{$ag_oid}" version="{$group_version}" displayName="Authority Groups at {$dhis_url}"&gt;
	&lt;svs:ConceptList xml:lang="en-US" &gt;
	  {
	    for $ag in $ags
	    return &lt;svs:Concept code="{$ag/@id}" displayName="{$ag/@name}" codeSystem="{$dhis_url}/api/userAuthorityGroups" /&gt;
	  }
	&lt;/svs:ConceptList&gt;
      &lt;/svs:ValueSet&gt;


    return ($svs_urs, $svs_ags)

let $svs_docs := ($svs_levels,$svs_groups,$svs_providers,$svs_srvcs)

 
(:Insert everything we generated into the database :)

return (
  for $entity in ( $entities,$providers, $srvcs)
  let $id := $entity/@entityID
  return 
    if (local-name($entity) = 'facility')
    then 
      let $existing_fac := $fac_dir/csd:facility[@entityID = $id]
      return
        if (not(exists($existing_fac)))
        then (insert node $entity into $fac_dir)
        else (replace node $existing_fac with $entity)
    else if (local-name($entity) = 'organization')
    then
      let $existing_org := $org_dir/csd:organization[@entityID = $id]
      return
        if (not(exists($existing_org)))
        then (insert node $entity into $org_dir)
        else (replace node $existing_org with $entity)
    else if (local-name($entity) = 'provider')
    then
      let $existing_prov := $prov_dir/csd:provider[@entityID = $id]
      return
        if (not(exists($existing_prov)))
        then (insert node $entity into $prov_dir)
        else (replace node $existing_prov with $entity)
    else if (local-name($entity) = 'service')
    then
      let $existing_srvc := $srvc_dir/csd:service[@entityID = $id]
      return
        if (not(exists($existing_srvc)))
        then (insert node $entity into $srvc_dir)
        else (replace node $existing_srvc with $entity)

    else (insert node $entity into /)
    

  ,
  for $svs_doc in $svs_docs return svs_lsvs:insert($svs_doc) 

)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rapidpro:get_csv_for_import"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/csv<br/>
	URN: urn:openhie.org:openinfoman-rapidpro:get_csv_for_import</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Creates selection menu of all the CSD organizations and faciltiies with a specified parent.  Designed as part of heierarchical facility selection menus in RapidPro webhooks.
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace oi_csv =  "https://github.com/openhie/openinfoman/adapter/csv";
declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

oi_csv:get_serialized(/,$careServicesRequest)</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rapidpro:get_json_for_import"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        application/json<br/>
	URN: urn:openhie.org:openinfoman-rapidpro:get_json_for_import</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Get JSON representation of CSD for import to RapidPro via API
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csr_proc = "https://github.com/openhie/openinfoman/csr_proc";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";

declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;



let $careServicesSubRequest :=  
  &lt;csd:careServicesRequest&gt;
    &lt;csd:function  urn="urn:ihe:iti:csd:2014:stored-function:provider-search" &gt;
      &lt;csd:requestParams/&gt;
    &lt;/csd:function&gt;
  &lt;/csd:careServicesRequest&gt; 

let $providers := csr_proc:process_CSR_stored_results( /. , $careServicesSubRequest)


let $contacts :=  
  &lt;json type='object'&gt;
    &lt;contacts type="array"&gt;
    {
      for $provider in  $providers/csd:providerDirectory/csd:provider
      let $uuid := lower-case(string($provider/@entityID))
      let $name := ($provider/csd:demographic/csd:name/csd:commonName)[1]/text()
      let $tels := $provider/csd:demographic/csd:contactPoint/csd:codedType[@code="BP" and  @codingScheme="urn:ihe:iti:csd:2013:contactPoint"]
      let $tel_1 := $tels[1]/text()
      let $tel_2 := $tels[2]/text()
      let $tel_3 := $tels[3]/text()
      return 
	if (true()) (:  ($uuid and $name)  :)
       then 
         &lt;_  type="object"&gt;
	   &lt;name&gt;{$name}&lt;/name&gt;
	   &lt;urns type="array"&gt;
             { if ($tel_1) then   &lt;_ type='string'&gt;tel:{$tel_1}&lt;/_&gt; else ()} 
             { if ($tel_2) then   &lt;_ type='string'&gt;tel:{$tel_2}&lt;/_&gt; else ()} 
             { if ($tel_3) then   &lt;_ type='string'&gt;tel:{$tel_3}&lt;/_&gt; else ()} 
	   &lt;/urns&gt;
	   &lt;fields type="object"&gt;
             &lt;globalid&gt;{$uuid}&lt;/globalid&gt;
	   &lt;/fields&gt;
         &lt;/_&gt;
       else ()
    }
    &lt;/contacts&gt;
  &lt;/json&gt;


return json:serialize($contacts,map{"format":"direct"})  
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rapidpro:phone_stats"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/html<br/>
	URN: urn:openhie.org:openinfoman-rapidpro:phone_stats</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Statistics on phone numbers
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace functx = "http://www.functx.com";
declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;


let $country_code := '+231'
let $cellcom_code := '77'

let $get_clean_phones := function($provider) {
  let $all_phones := $provider/csd:demographic/csd:contactPoint/csd:codedType[@code = "BP" and @codingScheme="urn:ihe:iti:csd:2013:contactPoint"]
  let $clean_phones :=
    for $phone in $all_phones
    let $raw_phones := tokenize($phone/text(),'[/\s]+')
    let $normalized_phones := 
      for $raw_phone in $raw_phones
      let $clean_phone := replace($raw_phone,'[^\d\+]/', '')
      return 
	if (string-length($clean_phone) = 0)
	then ()
        else 
	  if (starts-with($clean_phone,'0'))
	  then concat($country_code, substring($clean_phone,2))
	  else $clean_phone
    return $normalized_phones
  return $clean_phones
}

let $clean_providers := 
  for $provider in /csd:CSD/csd:providerDirectory/csd:provider
  let $clean_phones := $get_clean_phones($provider)
  where count($clean_phones) &gt; 0
  return $provider

let $cellcom_providers := 
  for $provider in $clean_providers 
  let $clean_phones := $get_clean_phones($provider)
  let $cellcom_phones := 
    for $clean_phone in $clean_phones
    return 
      if (starts-with($clean_phone,concat($country_code,$cellcom_code))) 
      then $clean_phone
      else ()
  where (count($cellcom_phones) &gt; 0)
  return $provider

let $multi_providers :=
  for $provider in $clean_providers
  let $clean_phones := $get_clean_phones($provider)
  where (count($clean_phones) &gt; 1)
  return $provider

return 
  &lt;div&gt;
    &lt;ul&gt;
      &lt;li&gt;Total number of health workers: {count(/csd:CSD/csd:providerDirectory/csd:provider)}&lt;/li&gt;
      &lt;li&gt;Total number of health workers with phone: {count($clean_providers)}&lt;/li&gt;
      &lt;li&gt;Total number of health workers with cellcom phone: {count($cellcom_providers)}&lt;/li&gt;
      &lt;li&gt;Total number of health workers with multiple phones: {count($multi_providers)}&lt;/li&gt;      
    &lt;/ul&gt;
  &lt;/div&gt;


</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rapidpro:select_facility"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        application/json<br/>
	URN: urn:openhie.org:openinfoman-rapidpro:select_facility</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Creates selection menu of all the CSD organizations and faciltiies with a specified parent.  Designed as part of heierarchical facility selection menus in RapidPro webhooks.
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace functx = "http://www.functx.com";
declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

let $t_top_orgid  :=  $careServicesRequest/query[@name = 'orgid']/text()
let $top_org :=  (/csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $t_top_orgid])[1]



let $selected_text := $careServicesRequest/query[@name = 'input']/text()
(:
let $selections := $careServicesRequest/values/item[./pair[@name = 'label' and ./text() = 'facilityselection']]
let $selected_text := 
  if (count($selections) &gt; 0)
  then
    let $max_time := max(for $time in $selections/pair[@name='time'] return xs:dateTime($time))
    return $selections[./pair[@name = 'time'] = $max_time]/pair[@name='text']/text()
   else ()
:)

let $selected_index := if ($selected_text castable as xs:integer) then xs:integer($selected_text) else -1


let $selected :=
  if ($selected_index = 0)
  then
    /csd:CSD/csd:organizationDirectory/csd:organization[
      @entityID = /csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $top_org/@entityID]/csd:parent/@entityID
    ]
  else if ($selected_index &gt; 0)
  then
    let $select_orgs := 
      if (exists($top_org))
      then /csd:CSD/csd:organizationDirectory/csd:organization[./csd:parent/@entityID = $top_org/@entityID]
      else /csd:CSD/csd:organizationDirectory/csd:organization[count(./csd:parent[@entityID]) = 0]
	
    let $select_facs := 
      if (exists($top_org))
      then /csd:CSD/csd:facilityDirectory/csd:facility[./csd:organizations/csd:organization[@entityID = $top_org/@entityID]]
      else ()
    return ($select_orgs,$select_facs)[ $selected_index]
  else ()

    
let $orgs := 
  if (exists($selected) and  local-name($selected ) = 'organization')
  then /csd:CSD/csd:organizationDirectory/csd:organization[./csd:parent/@entityID = $selected/@entityID]
  else /csd:CSD/csd:organizationDirectory/csd:organization[count(./csd:parent[@entityID]) = 0]
	
let $facs := 
  if (exists($selected) and  local-name($selected ) = 'organization')
  then /csd:CSD/csd:facilityDirectory/csd:facility[./csd:organizations/csd:organization[@entityID = $selected/@entityID]]
  else ()



let $output := 
  if ( local-name($selected ) = 'facility')
  then
    &lt;json type='object'&gt;
      &lt;menutext&gt;You already selected a facility.  You shouldn't see this message&lt;/menutext&gt;
      &lt;facility&gt;{string($selected/@entityID)}&lt;/facility&gt;
      &lt;facilityname&gt;{$selected/csd:primaryName/text()}&lt;/facilityname&gt;
    &lt;/json&gt;
  else  if ( local-name($selected ) = 'organization'  or not(exists($selected)))
  then
    &lt;json type='object'&gt;
      &lt;menutext &gt;
 	{ if (exists($selected)) then concat("In ", $selected/csd:primaryName/text(), ". ")  else () }
	{
	  let $parent := (/csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $selected/csd:parent/@entityID])[1]/csd:primaryName/text()
	  return
	    if ($parent)
	    then concat("O) Up to ", $parent, " ") 
	    else ()
        }
	{ for $ent at $pos in ($orgs,$facs)  return concat( $pos, ") ", $ent/csd:primaryName/text())    }
      &lt;/menutext&gt;
      &lt;orgid&gt;{if (exists($selected)) then string($selected/@entityID) else ()}&lt;/orgid&gt;
      &lt;facility/&gt;
      &lt;facilityname/&gt;      
    &lt;/json&gt;
   else &lt;json type='object'/&gt;

(:return $output :)
return json:serialize($output,map{'format':'direct'})</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:bulk_health_worker_read_otherids_json"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        application/json<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:bulk_health_worker_read_otherids_json</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">bulk_health_worker_read_otherids_json</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;




(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 


let $code := $careServicesRequest/code/text()
let $aa := $careServicesRequest/assigningAuthorityName/text()

let $xml:= 
  &lt;json  type="object"&gt;
    &lt;results type='array'&gt;
      { 
      for $ent_id in $careServicesRequest/id
      let $req_id := upper-case(string($ent_id/@entityID))
      let $provider := (/CSD/providerDirectory/provider[upper-case(string(@entityID)) = $req_id])[1]
      let $other_ids_0 := 
	if ($code) 
	then $provider/otherID[@code = $code]
	else $provider/otherID
      let $other_ids_1 := 
	if ($aa) 
	then $other_ids_0[@assigningAuthorityName = $aa]
        else $other_ids_0

      return
	if (exists($provider) and count($other_ids_1) &gt; 0)
	then
	  &lt;_ type='object'&gt;
	    &lt;entityID&gt;{string($provider/@entityID)}&lt;/entityID&gt;	    
	    &lt;otherID type="array"&gt;
	      {
		for $id in $other_ids_1
		return       
		  &lt;_ type='object'&gt;
		    &lt;code&gt;{string($id/@code)}&lt;/code&gt;
		    &lt;authority&gt;{string($id/@assigningAuthorityName)}&lt;/authority&gt;
		    &lt;value&gt;{$id/text()}&lt;/value&gt;
		  &lt;/_&gt;
	        }
	    &lt;/otherID&gt;
	 &lt;/_&gt;
	else ()
	      
      }
    &lt;/results&gt;
  &lt;/json&gt;
return json:serialize($xml,map{"format":"direct"})  
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_get_urns"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_get_urns</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_get_urns</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $facs0 := if (exists($careServicesRequest/id)) then csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else /CSD/facilityDirectory/*
  let $facs1 := if (exists($careServicesRequest/otherID)) then csd_bl:filter_by_other_id($facs0,$careServicesRequest/otherID) else $facs0
  let $facs2 := if (exists($careServicesRequest/codedType)) then csd_bl:filter_by_coded_type($facs1,$careServicesRequest/codedType)    else $facs1
  let $facs3 := if (exists($careServicesRequest/address/addressLine)) then csd_bl:filter_by_address($facs2, $careServicesRequest/address/addressLine) else $facs2
  let $facs4 := if (exists($careServicesRequest/record)) then csd_bl:filter_by_record($facs3,$careServicesRequest/record) else $facs3
  let $facs5 := if (exists($careServicesRequest/start) and exists($careServicesRequest/max)) then csd_bl:limit_items($facs4,$careServicesRequest/start,$careServicesRequest/max) else $facs4
  let $facs6 := for $entityID in $facs5/@entityID         
   return &lt;facility entityID="{$entityID}"/&gt;

  return csd_bl:wrap_facilities(($facs6))
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_indices_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $facs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) 
    else (/CSD/facilityDirectory/*)
  let $facs1:=     
      for $facility in  $facs0
      return
      &lt;facility entityID="{$facility/@entityID}"&gt;
	  {
	    for $address in  $facility/address
	    return &lt;address type="{$address/@type}"/&gt; 
	  }
      &lt;/facility&gt;
      
    return csd_bl:wrap_facilities($facs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_indices_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $facs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) 
    else (/CSD/facilityDirectory/*)
  let $facs1:=     
      for $facility in  $facs0
      return
      &lt;facility entityID="{$facility/@entityID}"&gt;
	  {
	    for $cp at $pos  in  $facility/contactPoint
	    return &lt;contactPoint position="{$pos}"/&gt; 
	  }
    &lt;/facility&gt;
      
    return csd_bl:wrap_facilities($facs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_organization"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_organization</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_indices_organization</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $facs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) 
    else (/CSD/facilityDirectory/*)
  let $facs1:=     
      for $facility in  $facs0
      return
      &lt;facility entityID="{$facility/@entityID}"&gt;
	&lt;organizations&gt;
          {
	    for $org in $facility/organizations/organization 
	    return
	    &lt;organization entityID="{$org/@entityID}"&gt;&lt;/organization&gt;
	  }
	&lt;/organizations&gt;
      &lt;/facility&gt;
      
    return csd_bl:wrap_facilities($facs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_indices_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_indices_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>
import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $facs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) 
    else (/CSD/facilityDirectory/*)
  let $facs1:=     
      for $facility in  $facs0
      return
      &lt;facility entityID="{$facility/@entityID}"&gt;
	{
	  for $id at $pos  in  $facility/otherID
	  return &lt;otherID position="{$pos}"/&gt; 
	}
    &lt;/facility&gt;
      
    return csd_bl:wrap_facilities($facs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_service"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_service</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_indices_service</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $facs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) 
    else (/CSD/facilityDirectory/*)
  let $facs1:=     
      for $facility in  $facs0
      return
      &lt;facility entityID="{$facility/@entityID}"&gt;
	&lt;organizations&gt;
	  {
	    let $facs := 
	      if (exists($careServicesRequest/organization/@entityID)) 
		then 
		$facility/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]
	      else    $facility/organizations/organization
            for $fac in $facs
	      return 
	       &lt;organization entityID="{$fac/@entityID}"&gt;
		  {
		    for $srvc at $pos in $fac/service
		    return &lt;service position="{$pos}" entityID="{$srvc/@entityID}"/&gt; 
		  }
		&lt;/organization&gt;
	  }
	&lt;/organizations&gt;
    &lt;/facility&gt;
      
    return csd_bl:wrap_facilities($facs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_name_search"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_name_search</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    
    Performs a search for all facilities by name, type, address or ID.   
    
    
      The result set consists of the primary name of all facilities matching the  search parameters ( id, primaryName, name, codedType and address ).
     
        
      The results set may be further restricted according to the limit parameters (start, max, record/@status and record/@updated).  An ordering of the result set is not specified.
    
    
    Response
    Results are returned as a valid CSD document with a root document element of &lt;CSD/&gt;.  The results set is contained entirely within the &lt;facilityDirectory/&gt; element and consists of the full content of the &lt;facility/&gt; elements of matching facilities as maintained by the Care Services InfoManager.
    
    Parameters Query
    Parameters are defined as the content of following elements:
    
       &lt;id/&gt; csd:uniqueID: (optional) If present and the @urn attribute contains a non-empty value, it is a ID which uniquely identifies a facility. This is an exact match.  
      
      &lt;primaryName/&gt; xs:string: (optional) If present and contains a non-empty value, then the result set should be restricted to those facilities whose &lt;primaryName/&gt; contains this value. Case insensitive.
      &lt;name/&gt; xs:string: (optional) If present and contains a non-empty value, then the result set should be restricted to those facilities which have a &lt;primaryName/&gt; or &lt;otherName/&gt; element containing this value. Case insensitive.      
      &lt;codedType/&gt; csd:codedtype:  If present and contains a non-empty value the result set should be restricted to those facilities whose &lt;codedType/@code&gt; equals this value for the coding schema specified by the @codingSchema attribute.  Case insensitive.
      
       &lt;address/&gt; csd:address: (optional) Contains of any-number of child &lt;addressLine/&gt; elements as follows:
        
          Text content xs:string: (optional) If present and contains a non-empty value, then the results set should be restricted to those facilities whose have an &lt;addressLine/&gt; with specified @component containing this value exactly.  Case insensitive.
           
          @component xs:string : (Required attribute) The component of the address we are searching. Case insensitive.
          
      
      &lt;start/&gt;  xs:int: (optional) The starting index for results returned. Defaults to 1, which indexes the first facility matching the search parameters
      &lt;max/&gt;  xs:int: (optional) The maximum number of results returned.  A value of less than zero implies no maximum.
      
	&lt;record/&gt;  csd:record : (optional) A child element to limit results according to
	
	  @status xs:string: (optional) If present and contains a non-empty value, the result set should be restricted to those facilities whose record/@status equals this value.  Case insensitive.
	  @updated xs:dateTime: (optional) If present and contains a non-empty value, the result set should be restricted to those facilities whose record/@updated is at least the given value.
	
      
    
    Example Request
    
         &lt;careServicesRequest&gt;
           &lt;function uuid='c7640530-f600-11e2-b778-0800200c9a66'&gt;
               &lt;codedType code='OPC' codingSchema="USDVA"/&gt;
               &lt;address&gt;
                 &lt;addressLine component='city'&gt;Chapel Hill&lt;/addressLine&gt;
	       &lt;/address&gt;
               &lt;max&gt;5&lt;/max&gt;
           &lt;/function&gt;
         &lt;/careServicesRequest&gt;         
      
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare  variable $careServicesRequest as item() external;



(: 
   The query will be executed against the root element of the CSD document.
    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
&lt;CSD xmlns:csd="urn:ihe:iti:csd:2013"  &gt;
  &lt;organizationDirectory/&gt;
  &lt;serviceDirectory/&gt;
  &lt;facilityDirectory&gt;
    {
      let $facs0 := if (exists($careServicesRequest/id))
	then csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id)
      else /CSD/facilityDirectory/*
         
      let $facs1 := if (exists($careServicesRequest/primaryName))
	then csd_bl:filter_by_primary_name($facs0,$careServicesRequest/primaryName)
      else $facs0
         
      let $facs2 := if (exists($careServicesRequest/name))
	then csd_bl:filter_by_name($facs1,$careServicesRequest/name)
      else $facs1
    
      let $facs3 := if(exists($careServicesRequest/codedType))
	then csd_bl:filter_by_coded_type($facs2,$careServicesRequest/codedType) 
      else $facs2
   
      let $facs4 := if(exists($careServicesRequest/address/addressLine))
	then csd_bl:filter_by_address($facs3, $careServicesRequest/address/addressLine) 
      else $facs3

      let $facs5 := if (exists($careServicesRequest/record))
	then csd_bl:filter_by_record($facs4,$careServicesRequest/record)      
      else $facs4

      let $facs6 := if(exists($careServicesRequest/otherID))
	then csd_bl:filter_by_other_id($facs5,$careServicesRequest/otherID)      
      else $facs5

      let $facs7:= if (exists($careServicesRequest/start)) then
	if (exists($careServicesRequest/max)) 
	  then csd_bl:limit_items($facs6,$careServicesRequest/start,$careServicesRequest/max)         
	else csd_bl:limit_items($facs6,$careServicesRequest/start,&lt;max/&gt;)         
      else
	if (exists($careServicesRequest/max)) 
	  then csd_bl:limit_items($facs6,&lt;start/&gt;,$careServicesRequest/max)         
	else $facs6

      return for $fac in $facs7
        return 
	 &lt;facility entityID='{$fac/@entityID}'&gt;
	   {$fac/primaryName}
	 &lt;/facility&gt;


    }     
  &lt;/facilityDirectory&gt;
  &lt;providerDirectory/&gt;
&lt;/CSD&gt;
    </pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_read_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_read_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facilty_read_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $facs0 := if (exists($careServicesRequest/address/@type)) then /CSD/facilityDirectory/*  else ()
let $facs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($facs0,$careServicesRequest/id) else ()
let $facs2 := 
  if (count($facs1) = 1) 
    then 
    let $facility :=  $facs1[1] 
    return 
    &lt;facility entityID="{$facility/@entityID}"&gt;
	{(
	  for $address in $facility/address[@type = $careServicesRequest/address/@type]
	  return $address
	 )}
      {$facility/record}
    &lt;/facility&gt;
  else ()        
return csd_bl:wrap_facilities($facs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_read_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_read_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_read_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $facs0 := if (exists($careServicesRequest/contactPoint/@position)) then /CSD/facilityDirectory/*  else ()
let $facs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($facs0,$careServicesRequest/id) else ()
let $facs2 := 
  if (count($facs1) = 1) 
    then 
    let $facility :=  $facs1[1] 
    return 
    &lt;facility entityID="{$facility/@entityID}"&gt;
      {
	if (exists($careServicesRequest/contactPoint) and exists($careServicesRequest/contactPoint/@position)) 
	  then 
	      for $cp in $facility/contactPoint[position() = $careServicesRequest/contactPoint/@position]
	      return       &lt;contactPoint position="{$careServicesRequest/contactPoint/@position}"&gt;{$cp/*}&lt;/contactPoint&gt;
	else
	  ()
      }
      {$facility/record}
    &lt;/facility&gt;
  else ()    
    
return csd_bl:wrap_facilities($facs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_read_organization"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_read_organization</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_read_organization</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $facs0 := if (exists($careServicesRequest/organization/@entityID)) then /CSD/facilityDirectory/*  else ()
let $facs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($facs0,$careServicesRequest/id) else ()
let $facs2 := 
  if (count($facs1) = 1) 
    then 
    let $facility :=  $facs1[1] 
    return 
      &lt;facility entityID="{$facility/@entityID}"&gt;
	  {
	    (
	    &lt;organizations&gt;
	      {
		for $org in $facility/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID ) ]
		return
		&lt;organization entityID="{$org/@entityID}"&gt;&lt;/organization&gt;
	      }
	    &lt;/organizations&gt;
	       
	      ,
	      $facility/record
	    )
	  }
      &lt;/facility&gt;
  else ()    
    
return csd_bl:wrap_facilities($facs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_read_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_read_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_read_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $facs0 := if (exists($careServicesRequest/otherID/@position)) then /CSD/facilityDirectory/*  else ()
let $facs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($facs0,$careServicesRequest/id) else ()
let $facs2 := 
  if (count($facs1) = 1) 
    then 
    let $facility :=  $facs1[1] 
    return 
    &lt;facility entityID="{$facility/@entityID}"&gt;
      {(
	if (exists($careServicesRequest/otherID/@position))
	  then 
	  for $id in $facility/otherID[position() = $careServicesRequest/otherID/@position]
	  return       
	  &lt;otherID 
	  position="{$careServicesRequest/otherID/@position}"
	  code="{$id/@code}"
	  assigningAuthorityName="{$id/@assigningAuthorityName}"&gt;{string($id)}&lt;/otherID&gt;
	else
	  ()
        ,      
	$facility/record
	)}
    &lt;/facility&gt;
  else ()    
    
return csd_bl:wrap_facilities($facs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_read_service"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_read_service</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_read_service</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $facs0 := if (exists($careServicesRequest/organization/@entityID)) then /CSD/providerDirectory/*  else ()
let $facs1 := if (exists($careServicesRequest/organization/service/@position)) then $facs0  else ()
let $facs2 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($facs1,$careServicesRequest/id) else ()
let $facs3 := 
  if (count($facs2) = 1) 
    then 
    let $facility :=  $facs2[1] 
    return 
    &lt;facility entityID="{$facility/@entityID}"&gt;
      {
	if (exists($careServicesRequest/organization/@entityID) and exists($careServicesRequest/organization/service/@position)) 
	  then 
	  &lt;organizations&gt;
	    &lt;organization entityID="{$careServicesRequest/organization/@entityID}"&gt;
	    {
	      for $srvc in $facility/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]/service[position() = $careServicesRequest/organization/service/@position]
	      return       &lt;service position="{$careServicesRequest/organization/service/@position}" entityID="{$srvc/@entityID}"&gt;{$srvc/*}&lt;/service&gt;
	  }
	    &lt;/organization&gt;
	  &lt;/organizations&gt;
	else
	  ()
      }
      {$facility/record}
    &lt;/facility&gt;
  else ()    
    
return csd_bl:wrap_facilities($facs3)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_get_urns"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_get_urns</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_get_urns</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := if (exists($careServicesRequest/id)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else /CSD/providerDirectory/*
  let $provs1 := if (exists($careServicesRequest/otherID)) then csd_bl:filter_by_other_id($provs0,$careServicesRequest/otherID) else $provs0
  let $provs2 := if (exists($careServicesRequest/commonName)) then csd_bl:filter_by_common_name($provs1,$careServicesRequest/commonName) else $provs1
  let $provs3 := if (exists($careServicesRequest/codedType)) then csd_bl:filter_by_coded_type($provs2,$careServicesRequest/codedType)    else $provs2
  let $provs4 := if (exists($careServicesRequest/address/addressLine)) then csd_bl:filter_by_address($provs3, $careServicesRequest/address/addressLine) else $provs3
  let $provs5 := if (exists($careServicesRequest/record)) then csd_bl:filter_by_record($provs4,$careServicesRequest/record) else $provs4
  let $provs6 := if (exists($careServicesRequest/start) and exists($careServicesRequest/max)) then csd_bl:limit_items($provs5,$careServicesRequest/start,$careServicesRequest/max) else $provs5
  let $provs7 := for $entityID in $provs6/@entityID         
   return &lt;provider entityID="{$entityID}"/&gt;

  return csd_bl:wrap_providers($provs7)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_indices_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;demographic&gt;
	  {
	    for $address in  $provider/demographic/address
	    return &lt;address type="{$address/@type}"/&gt; 
	  }
	&lt;/demographic&gt;
    &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_indices_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;demographic&gt;
	  {
	    for $cp at $pos  in  $provider/demographic/contactPoint
	    return &lt;contactPoint position="{$pos}"/&gt; 
	  }
	&lt;/demographic&gt;
    &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_credential"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_credential</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_indices_credential</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
        {
	  for $cred in $provider/credential
	  return
	  &lt;credential &gt;{$cred/codedType}&lt;/credential&gt;
	}
      &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_name"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_name</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_indices_name</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;demographic&gt;
	  {
	    for $name at $pos  in  $provider/demographic/name
	    return &lt;name position="{$pos}"/&gt; 
	  }
	&lt;/demographic&gt;
    &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_operating_hours"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_operating_hours</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_indices_operating_hours</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;facilities&gt;
	  {
	    let $facs := 
	      if (exists($careServicesRequest/facility/@entityID)) 
		then 
		$provider/facilities/facility[upper-case(@entityID) = upper-case($careServicesRequest/facility/@entityID)]
	      else    $provider/facilities/facility
            for $fac in $facs
	      return 
	       &lt;facility entityID="{$fac/@entityID}"&gt;
		  {
		    if ($careServicesRequest/facility/service/@position) 
		      then
			for $srvc in $fac/service[position()= $careServicesRequest/facility/service/@position] 
			return 
			&lt;service position="{$careServicesRequest/facility/service/@position}"&gt;
			  {for $oh at $ohpos in $srvc/operatingHours return &lt;operatingHours position="{$ohpos}"/&gt;}
			&lt;/service&gt;
		    else 
		      for $srvc at $spos in $fac/service
			return 
			&lt;service position="{$spos}"&gt;
			  {for $oh at $ohpos in $srvc/operatingHours return &lt;operaingHours position="{$ohpos}"/&gt;}
			&lt;/service&gt;
		  }
		&lt;/facility&gt;
	  }
	&lt;/facilities&gt;
    &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_org_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_org_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_indices_org_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;organizations&gt;
          {
	    let $orgs := 
	      if (exists($careServicesRequest/organization/@entityID)) 
		then 
		$provider/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]
	      else    $provider/organizations/organization
            for $org in $orgs
	      return 
	       &lt;organization entityID="{$org/@entityID}"&gt;
		  {
		    for $address  in $org/address
		    return &lt;address type="{$address/@type}"/&gt; 
		  }
		&lt;/organization&gt;
	  }
	&lt;/organizations&gt;
    &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_org_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_org_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_indices_org_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;organizations&gt;
	  {
	    let $orgs := 
	      if (exists($careServicesRequest/organization/@entityID)) 
		then 
		$provider/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]
	      else    $provider/organizations/organization
            for $org in $orgs
	      return 
	       &lt;organization entityID="{$org/@entityID}"&gt;
		  {
		    for $cp at $pos in $org/contactPoint
		    return &lt;contactPoint position="{$pos}"/&gt; 
		  }
		&lt;/organization&gt;
	  }
	&lt;/organizations&gt;
    &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_indices_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
	{
	  for $id at $pos  in  $provider/otherID
	  return &lt;otherID position="{$pos}"/&gt; 
	}
    &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_provider_facility"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_provider_facility</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_indices_provider_facility</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;facilities&gt;
          {
	    for $fac in $provider/facilities/facility 
	    return
	    &lt;facility entityID="{$fac/@entityID}"&gt;&lt;/facility&gt;
	  }
	&lt;/facilities&gt;
      &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_provider_organization"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_provider_organization</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_indices_provider_organization</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;organizations&gt;
          {
	    for $org in $provider/organizations/organization 
	    return
	    &lt;organization entityID="{$org/@entityID}"&gt;&lt;/organization&gt;
	  }
	&lt;/organizations&gt;
      &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_service"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_indices_service</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_indices_service</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;facilities&gt;
	  {
	    let $facs := 
	      if (exists($careServicesRequest/facility/@entityID)) 
		then 
		$provider/facilities/facility[upper-case(@entityID) = upper-case($careServicesRequest/facility/@entityID)]
	      else    $provider/facilities/facility
            for $fac in $facs
	      return 
	       &lt;facility entityID="{$fac/@entityID}"&gt;
		  {
		    for $srvc at $pos in $fac/service
		    return &lt;service position="{$pos}" entityID="{$srvc/@entityID}"/&gt; 
		  }
		&lt;/facility&gt;
	  }
	&lt;/facilities&gt;
    &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/address/@type)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    let $provider :=  $provs1[1] 
    return 
    &lt;provider entityID="{$provider/@entityID}"&gt;
      &lt;demographic&gt;
	{(
	  for $address in $provider/demographic/address[@type = $careServicesRequest/address/@type]
	  return $address
	 )}
      &lt;/demographic&gt;
      {$provider/record}
    &lt;/provider&gt;
  else ()        
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/contactPoint/@position)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    let $provider :=  $provs1[1] 
    return 
    &lt;provider entityID="{$provider/@entityID}"&gt;
      {
	if (exists($careServicesRequest/contactPoint) and exists($careServicesRequest/contactPoint/@position)) 
	  then 
	  &lt;demographic&gt;
	    {
	      for $cp in $provider/demographic/contactPoint[position() = $careServicesRequest/contactPoint/@position]
	      return       &lt;contactPoint position="{$careServicesRequest/contactPoint/@position}"&gt;{$cp/*}&lt;/contactPoint&gt;
	  }
	  &lt;/demographic&gt;
	else
	  ()
      }
      {$provider/record}
    &lt;/provider&gt;
  else ()    
    
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_credential"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_credential</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_credential</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/credential/codedType/@code) and exists($careServicesRequest/credential/codedType/@codingScheme) ) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    let $provider :=  $provs1[1] 
    let $code:= $careServicesRequest/credential/codedType/@code
    let $codingScheme:= $careServicesRequest/credential/codedType/@codingScheme
    return 
      &lt;provider entityID="{$provider/@entityID}"&gt;
	  {
	    (
	      $provider/credential/codedType[@code = $code and @codingScheme = $codingScheme]/..
	      ,
	      $provider/record
	    )
	  }
      &lt;/provider&gt;
  else ()    
    
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_name"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_name</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_name</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/name/@position)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    let $provider :=  $provs1[1] 
    return 
    &lt;provider entityID="{$provider/@entityID}"&gt;
      {
	if (exists($careServicesRequest/name) and exists($careServicesRequest/name/@position)) 
	  then 
	  &lt;demographic&gt;
	    {
	      for $name in $provider/demographic/name[position() = $careServicesRequest/name/@position]
	      return       &lt;name position="{$careServicesRequest/name/@position}"&gt;{$name/*}&lt;/name&gt;
	  }
	  &lt;/demographic&gt;
	else
	  ()
      }
      {$provider/record}
    &lt;/provider&gt;
  else ()    
    
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_operating_hours"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_operating_hours</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_operating_hours</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $provs0 := if (exists($careServicesRequest/facility/@entityID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/facility/service/@position)) then $provs0  else ()
let $provs2 := if (exists($careServicesRequest/facility/service/operatingHours/@position)) then $provs1  else ()
let $provs3 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs2,$careServicesRequest/id) else ()
let $srvc := $provs3[1]/facilities/facility[upper-case(@entityID) =upper-case($careServicesRequest/facility/@entityID)]/service[position() = $careServicesRequest/facility/service/@position]
let  $provs4:=   
  if (count($srvc) = 1) 
    then
    let $oh := $srvc/operatingHours[position() = $careServicesRequest/facility/service/operatingHours/@position]
    return &lt;provider entityID="{$careServicesRequest/id/@entityID}"&gt;
      &lt;facilities&gt;
	&lt;facility entityID="{$careServicesRequest/facility/@entityID}"&gt;
	  &lt;service position="{$careServicesRequest/facility/service/@position}" &gt;
	    &lt;operatingHours position="{$careServicesRequest/facility/service/operatingHours/@position}"&gt;{$oh/*}&lt;/operatingHours&gt;
	  &lt;/service&gt;
	&lt;/facility&gt;
      &lt;/facilities&gt;
      {$careServicesRequest}
    &lt;/provider&gt;
  else ()


return csd_bl:wrap_providers($provs4)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_org_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_org_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_org_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/organization/@entityID) and exists($careServicesRequest/organization/address/@type)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    let $provider :=  $provs1[1] 
    return 
    &lt;provider entityID="{$provider/@entityID}"&gt;
      &lt;organizations&gt;
	&lt;organization entityID="{$careServicesRequest/organization/@entityID}"&gt;
	  {
	    $provider/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]/address[@type = $careServicesRequest/organization/address/@type]
	  }
	&lt;/organization&gt;
      &lt;/organizations&gt;
      {$provider/record}
    &lt;/provider&gt;
  else ()        
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_org_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_org_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_org_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/organization/@entityID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/organization/contactPoint/@position)) then $provs0  else ()
let $provs2 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs1,$careServicesRequest/id) else ()
let $provs3 := 
  if (count($provs2) = 1) 
    then 
    let $provider :=  $provs2[1] 
    return 
    &lt;provider entityID="{$provider/@entityID}"&gt;
      {
	if (exists($careServicesRequest/organization/@entityID) and exists($careServicesRequest/organization/contactPoint/@position)) 
	  then 
	  &lt;organizations&gt;
	    &lt;organization entityID="{$careServicesRequest/organization/@entityID}"&gt;
	    {
	      for $cp in $provider/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]/contactPoint[position() = $careServicesRequest/organization/contactPoint/@position]
	      return       &lt;contactPoint position="{$careServicesRequest/organization/contactPoint/@position}"&gt;{$cp/*}&lt;/contactPoint&gt;
	  }
	    &lt;/organization&gt;
	  &lt;/organizations&gt;
	else
	  ()
      }
      {$provider/record}
    &lt;/provider&gt;
  else ()    
    
return csd_bl:wrap_providers($provs3)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/otherID/@position)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    let $provider :=  $provs1[1] 
    return 
    &lt;provider entityID="{$provider/@entityID}"&gt;
      {(
	if (exists($careServicesRequest/otherID/@position))
	  then 
	  for $id in $provider/otherID[position() = $careServicesRequest/otherID/@position]
	  return       
	  &lt;otherID 
	  position="{$careServicesRequest/otherID/@position}"
	  code="{$id/@code}"
	  assigningAuthorityName="{$id/@assigningAuthorityName}"&gt;{string($id)}&lt;/otherID&gt;
	else
	  ()
        ,      
	$provider/record
	)}
    &lt;/provider&gt;
  else ()    
    
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherids"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherids</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_otherids</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/otherID/@position)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()

let $provs2 := 
  if (count($provs1) = 1) 
    then 
    let $provider :=  $provs1[1] 
    let $other_ids := 
      if ($careServicesRequest/code/text())
      then $provider/otherID[@code = $careServicesRequest/code/text()]
      else $provider/otherID

    return 
    &lt;provider entityID="{$provider/@entityID}"&gt;
      {(
	$other_ids
        ,      
	$provider/record
	)}
    &lt;/provider&gt;
  else ()    
    
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherids_json"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        application/json<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_otherids_json</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_otherids_json</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;




(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id( /CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provider :=  $provs1[1] 
let $other_ids := 
  if ($careServicesRequest/code/text())
  then $provider/otherID[@code = $careServicesRequest/code/text()]
  else $provider/otherID
let $xml:= 
  &lt;json  type="object"&gt;
    &lt;entityID&gt;{string($provider/@entityID)}&lt;/entityID&gt;
    &lt;otherID type="array"&gt;
      {
	for $id in $other_ids 
	return       
	  &lt;_ type='object'&gt;
	    &lt;code&gt;{string($id/@code)}&lt;/code&gt;
	    &lt;authority&gt;{string($id/@assigningAuthorityName)}&lt;/authority&gt;
	    &lt;value&gt;{$id/text()}&lt;/value&gt;
	 &lt;/_&gt;
      }
    &lt;/otherID&gt;
  &lt;/json&gt;
return json:serialize($xml,map{"format":"direct"})  
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_provider</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $provs0 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()  
let $provs1 :=  if (count($provs0) = 1) then
  let $prov := $provs0[1]
  return 
  &lt;provider entityID="{$prov/@entityID}"&gt;  
  {(
      $prov/codedType,
      &lt;demographic&gt;
      {(
	if (exists($prov/demographic/gender)) then $prov/demographic/gender else (),
	if (exists($prov/demographic/dateOfBirth)) then $prov/demographic/dateOfBirth else ()
      )}
      &lt;/demographic&gt;,
      $prov/language,
      $prov/specialty,
      $prov/record
  )}
  &lt;/provider&gt;
  else ()
  return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider_facility"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider_facility</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_provider_facility</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/facility/@entityID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    let $provider :=  $provs1[1] 
    return 
      &lt;provider entityID="{$provider/@entityID}"&gt;
	  {
	    (
	    &lt;facilities&gt;
	      {
		for $fac in $provider/facilities/facility[upper-case(@entityID) = upper-case($careServicesRequest/facility/@entityID)  ]
		return
		&lt;facility entityID="{$fac/@entityID}"&gt;&lt;/facility&gt;
	      }
	    &lt;/facilities&gt;
	       
	      ,
	      $provider/record
	    )
	  }
      &lt;/provider&gt;
  else ()    
    
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider_organization"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_provider_organization</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_provider_organization</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/organization/@entityID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    let $provider :=  $provs1[1] 
    return 
      &lt;provider entityID="{$provider/@entityID}"&gt;
	  {
	    (
	    &lt;organizations&gt;
	      {
		for $org in $provider/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID ) ]
		return
		&lt;organization entityID="{$org/@entityID}"&gt;&lt;/organization&gt;
	      }
	    &lt;/organizations&gt;
	       
	      ,
	      $provider/record
	    )
	  }
      &lt;/provider&gt;
  else ()    
    
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_service"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_read_service</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_read_service</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/facility/@entityID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/facility/service/@position)) then $provs0  else ()
let $provs2 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs1,$careServicesRequest/id) else ()
let $provs3 := 
  if (count($provs2) = 1) 
    then 
    let $provider :=  $provs2[1] 
    return 
    &lt;provider entityID="{$provider/@entityID}"&gt;
      {
	if (exists($careServicesRequest/facility/@entityID) and exists($careServicesRequest/facility/service/@position)) 
	  then 
	  &lt;facilities&gt;
	    &lt;facility entityID="{$careServicesRequest/facility/@entityID}"&gt;
	    {
	      for $srvc in $provider/facilities/facility[upper-case(@entityID) = upper-case($careServicesRequest/facility/@entityID)]/service[position() = $careServicesRequest/facility/service/@position]
	      return       &lt;service position="{$careServicesRequest/facility/service/@position}" entityID="{$srvc/@entityID}"&gt;{$srvc/*}&lt;/service&gt;
	  }
	    &lt;/facility&gt;
	  &lt;/facilities&gt;
	else
	  ()
      }
      {$provider/record}
    &lt;/provider&gt;
  else ()    
    
return csd_bl:wrap_providers($provs3)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_urn_search_by_id"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_urn_search_by_id</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_urn_search_by_id</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := if (exists($careServicesRequest/otherID)) then csd_bl:filter_by_other_id(/CSD/providerDirectory/*,$careServicesRequest/otherID) else ()
  let $provs1 := if (exists($careServicesRequest/start) and exists($careServicesRequest/max)) then csd_bl:limit_items($provs0,$careServicesRequest/start,$careServicesRequest/max) else $provs0
  let $provs2:= for $entityID in $provs1/@entityID     
   return &lt;provider entityID="{$entityID}"/&gt;

  return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_get_urns"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_get_urns</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">organization_get_urns</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $orgs0 := if (exists($careServicesRequest/id)) then csd_bl:filter_by_primary_id(/CSD/organizationDirectory/*,$careServicesRequest/id) else /CSD/organizationDirectory/*
  let $orgs1 := if (exists($careServicesRequest/otherID)) then csd_bl:filter_by_other_id($orgs0,$careServicesRequest/otherID) else $orgs0
  let $orgs2 := if (exists($careServicesRequest/codedType)) then csd_bl:filter_by_coded_type($orgs1,$careServicesRequest/codedType)    else $orgs1
  let $orgs3 := if (exists($careServicesRequest/address/addressLine)) then csd_bl:filter_by_address($orgs2, $careServicesRequest/address/addressLine) else $orgs2
  let $orgs4 := if (exists($careServicesRequest/record)) then csd_bl:filter_by_record($orgs3,$careServicesRequest/record) else $orgs3
  let $orgs5 := if (exists($careServicesRequest/start) and exists($careServicesRequest/max)) then csd_bl:limit_items($orgs4,$careServicesRequest/start,$careServicesRequest/max) else $orgs4
  let $orgs6 := for $entityID in $orgs5/@entityID         
   return &lt;organization entityID="{$entityID}"/&gt;

  return csd_bl:wrap_organizations(($orgs6))
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">organization_indices_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $orgs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/organizationDirectory/*,$careServicesRequest/id) 
    else (/CSD/organizationDirectory/*)
  let $orgs1:=     
      for $organization in  $orgs0
      return
      &lt;organization entityID="{$organization/@entityID}"&gt;
	  {
	    for $address in  $organization/address
	    return &lt;address type="{$address/@type}"/&gt; 
	  }
      &lt;/organization&gt;
      
    return csd_bl:wrap_organizations($orgs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">organization_indices_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $orgs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/organizationDirectory/*,$careServicesRequest/id) 
    else (/CSD/organizationDirectory/*)
  let $orgs1:=     
      for $organization in  $orgs0
      return
      &lt;organization entityID="{$organization/@entityID}"&gt;
	  {
	    for $cp at $pos  in  $organization/contactPoint
	    return &lt;contactPoint position="{$pos}"/&gt; 
	  }
    &lt;/organization&gt;
      
    return csd_bl:wrap_organizations($orgs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_credential"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_credential</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">organization_indices_credential</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $orgs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/organizationDirectory/*,$careServicesRequest/id) 
    else (/CSD/organizationDirectory/*)
  let $orgs1:=     
      for $organization in  $orgs0
      return
      &lt;organization entityID="{$organization/@entityID}"&gt;
        {
	  for $cred in $organization/credential
	  return
	  &lt;credential &gt;{$cred/codedType}&lt;/credential&gt;
	}
      &lt;/organization&gt;
      
    return csd_bl:wrap_organizations($orgs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_indices_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">organization_indices_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $orgs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/organizationDirectory/*,$careServicesRequest/id) 
    else (/CSD/organizationDirectory/*)
  let $orgs1:=     
      for $organization in  $orgs0
      return
      &lt;organization entityID="{$organization/@entityID}"&gt;
	{
	  for $id at $pos  in  $organization/otherID
	  return &lt;otherID position="{$pos}"/&gt; 
	}
    &lt;/organization&gt;
      
    return csd_bl:wrap_organizations($orgs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_name_search"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_name_search</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    
    Performs a search for all organizations by name, coded type, address or ID.   
    
    
      The result set consists of the primary name of all organizations matching the  search parameters ( id, primaryName, name, codedType and address ).
     
        
      The results set may be further restricted according to the limit parameters (start, max, record/@status and record/@updated).  An ordering of the result set is not specified.
    
    
    Response
    Results are returned as a valid CSD document with a root document element of &lt;CSD/&gt;.  The results set is contained entirely within the &lt;organizationDirectory/&gt; element and consists of the full content of the &lt;organization/&gt; elements of matching organizations as maintained by the Care Services InfoManager.
    
    Parameters Query
    Parameters are defined as the content of following elements:
    
       &lt;id/&gt; csd:uniqueID: (optional) If present and the @urn attribute contains a non-empty value, it is a ID which uniquely identifies an organization. This is an exact match.  
      
      &lt;primaryName/&gt; xs:string: (optional) If present and contains a non-empty value, then the result set should be restricted to those organizations whose &lt;primaryName/&gt; contains this value. Case insensitive.
      &lt;name/&gt; xs:string: (optional) If present and contains a non-empty value, then the result set should be restricted to those organizations which have a &lt;primaryName/&gt; or &lt;otherName/&gt; element containing this value. Case insensitive.      
      &lt;codedType/&gt; csd:codedtype:  If present and contains a non-empty value the result set should be restricted to those organizations whose &lt;codedType/@code&gt; equals this value for the coding schema specified by the @codingSchema attribute.  Case insensitive.
      
       &lt;address/&gt; csd:address: (optional) Contains of any-number of child &lt;addressLine/&gt; elements as follows:
        
          Text content xs:string: (optional) If present and contains a non-empty value, then the results set should be restricted to those organizations whose have an &lt;addressLine/&gt; with specified @component containing this value exactly.  Case insensitive.
           
          @component xs:string : (Required attribute) The component of the address we are searching. Case insensitive.
          
      
      &lt;start/&gt;  xs:int: (optional) The starting index for results returned. Defaults to 1, which indexes the first organization matching the search parameters
      &lt;max/&gt;  xs:int: (optional) The maximum number of results returned.  A value of less than zero implies no maximum.
      
	&lt;record/&gt;  csd:record : (optional) A child element to limit results according to
	
	  @status xs:string: (optional) If present and contains a non-empty value, the result set should be restricted to those organizations whose record/@status equals this value.  Case insensitive.
	  @updated xs:dateTime: (optional) If present and contains a non-empty value, the result set should be restricted to those organizations whose record/@updated is at least the given value.
	
      
    
    Example Request
    
         &lt;careServicesRequest&gt;
           &lt;function uuid='dc6aedf0-f609-11e2-b778-0800200c9a66'&gt;
               &lt;codedType codingSchema="moh.gov.rw" code="FBO" /&gt;
               &lt;address&gt;
                 &lt;addressLine component='city'&gt;Kigali&lt;/addressLine&gt;
	       &lt;/address&gt;
               &lt;max&gt;5&lt;/max&gt;
           &lt;/function&gt;
         &lt;/careServicesRequest&gt;         
      
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 


&lt;CSD xmlns:csd="urn:ihe:iti:csd:2013"  &gt;
  &lt;organizationDirectory&gt;
    {
      let $orgs0 := if (exists($careServicesRequest/id))
	then csd_bl:filter_by_primary_id(/CSD/organizationDirectory/*,$careServicesRequest/id)
      else /CSD/organizationDirectory/*
         
      let $orgs1 := if (exists($careServicesRequest/primaryName))
	then csd_bl:filter_by_primary_name($orgs0,$careServicesRequest/primaryName)
      else $orgs0
         
      let $orgs2 := if(exists($careServicesRequest/name))
	then csd_bl:filter_by_name($orgs1,$careServicesRequest/name)
      else $orgs1
    
      let $orgs3 := if(exists($careServicesRequest/codedType))
	then csd_bl:filter_by_coded_type($orgs2,$careServicesRequest/codedType)
      else $orgs2
   
      let $orgs4 :=if (exists($careServicesRequest/address/addressLine))
	then csd_bl:filter_by_address($orgs3, $careServicesRequest/address/addressLine)
      else $orgs3
      
      let $orgs5 := if (exists($careServicesRequest/record))
	then csd_bl:filter_by_record($orgs4,$careServicesRequest/record)
      else $orgs4

      let $orgs6 := if (exists($careServicesRequest/otherID))
	then csd_bl:filter_by_other_id($orgs5,$careServicesRequest/otherID)
      else $orgs5

      let $orgs7 := if (exists($careServicesRequest/start)) then
	if (exists($careServicesRequest/max))
	  then csd_bl:limit_items($orgs6,$careServicesRequest/start,$careServicesRequest/max)
	else csd_bl:limit_items($orgs6,$careServicesRequest/start,&lt;max/&gt;)
      else
	if (exists($careServicesRequest/max))
	  then csd_bl:limit_items($orgs6,&lt;start/&gt;,$careServicesRequest/max)
	else $orgs6
	  
      return for $org in $orgs7
	return&lt;organization urn='{$org/@urn}'&gt;
	  {$org/primaryName}
	&lt;/organization&gt;

    }     
  &lt;/organizationDirectory&gt;
  &lt;serviceDirectory/&gt;
  &lt;facilityDirectory/&gt;
  &lt;providerDirectory/&gt;
&lt;/CSD&gt;
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_read_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_read_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facilty_read_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $orgs0 := if (exists($careServicesRequest/address/@type)) then /CSD/organizationDirectory/*  else ()
let $orgs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($orgs0,$careServicesRequest/id) else ()
let $orgs2 := 
  if (count($orgs1) = 1) 
    then 
    let $organization :=  $orgs1[1] 
    return 
    &lt;organization entityID="{$organization/@entityID}"&gt;
	{(
	  for $address in $organization/address[@type = $careServicesRequest/address/@type]
	  return $address
	 )}
      {$organization/record}
    &lt;/organization&gt;
  else ()        
return csd_bl:wrap_organizations($orgs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_read_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_read_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">organization_read_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $orgs0 := if (exists($careServicesRequest/contactPoint/@position)) then /CSD/organizationDirectory/*  else ()
let $orgs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($orgs0,$careServicesRequest/id) else ()
let $orgs2 := 
  if (count($orgs1) = 1) 
    then 
    let $organization :=  $orgs1[1] 
    return 
    &lt;organization entityID="{$organization/@entityID}"&gt;
      {
	if (exists($careServicesRequest/contactPoint) and exists($careServicesRequest/contactPoint/@position)) 
	  then 
	      for $cp in $organization/contactPoint[position() = $careServicesRequest/contactPoint/@position]
	      return       &lt;contactPoint position="{$careServicesRequest/contactPoint/@position}"&gt;{$cp/*}&lt;/contactPoint&gt;
	else
	  ()
      }
      {$organization/record}
    &lt;/organization&gt;
  else ()    
    
return csd_bl:wrap_organizations($orgs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_read_credential"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_read_credential</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">organization_read_credential</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $orgs0 := if (exists($careServicesRequest/credential/codedType/@code) and exists($careServicesRequest/credential/codedType/@codingScheme) ) then /CSD/organizationDirectory/*  else ()
let $orgs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($orgs0,$careServicesRequest/id) else ()
let $orgs2 := 
  if (count($orgs1) = 1) 
    then 
    let $organization :=  $orgs1[1] 
    let $code:= $careServicesRequest/credential/codedType/@code
    let $codingScheme:= $careServicesRequest/credential/codedType/@codingScheme
    return 
      &lt;organization entityID="{$organization/@entityID}"&gt;
	  {
	    (
	      $organization/credential/codedType[@code = $code and @codingScheme = $codingScheme]/..
	      ,
	      $organization/record
	    )
	  }
      &lt;/organization&gt;
  else ()    
    
return csd_bl:wrap_organizations($orgs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_read_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_read_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">organization_read_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $orgs0 := if (exists($careServicesRequest/otherID/@position)) then /CSD/organizationDirectory/*  else ()
let $orgs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($orgs0,$careServicesRequest/id) else ()
let $orgs2 := 
  if (count($orgs1) = 1) 
    then 
    let $organization :=  $orgs1[1] 
    return 
    &lt;organization entityID="{$organization/@entityID}"&gt;
      {(
	if (exists($careServicesRequest/otherID/@position))
	  then 
	  for $id in $organization/otherID[position() = $careServicesRequest/otherID/@position]
	  return       
	  &lt;otherID 
	  position="{$careServicesRequest/otherID/@position}"
	  code="{$id/@code}"
	  assigningAuthorityName="{$id/@assigningAuthorityName}"&gt;{string($id)}&lt;/otherID&gt;
	else
	  ()
        ,      
	$organization/record
	)}
    &lt;/organization&gt;
  else ()    
    
return csd_bl:wrap_organizations($orgs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:provider_name_search"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:provider_name_search</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
     Performs a search for all providers by name, coded type, address or ID. 
     The result set consists of all names  providers matching the search parameters ( id,
        otherID, commonName,codedType and address ). 
     The results set may be further restricted according to the limit parameters
        (start, max, record/@status and record/@updated). An ordering of
      the result set is not specified. 
    
      Response Results are returned as a valid CSD document with a root document element of
      &lt;CSD/&gt;. The results set is contained entirely within the &lt;providerDirectory/&gt;
      element and consists of the full content of the &lt;provider/&gt; elements of matching
      providers as maintained by the Care Services InfoManager. 
    Parameters Query Parameters are defined as the content of following elements: 
       &lt;id/&gt; csd:uniqueID: (optional) If present and the @urn attribute contains a
        non-empty value, it is a ID which uniquely identifies a provider. This is an exact match. 
       &lt;otherID/&gt; csd:otherID: (optional) If present and the
        @assigningAuthorityName attribute contains a non-empty value, then the result set is
        restricted to only those providers which have a &lt;otherID/&gt; with the given
        assigingAuthorityName and @code  &lt;commonName/&gt; xsd:string: (optional)
        If present and contains a non-empty value, then the result set should be restricted to those
        providers which have a &lt;demographic/name/commonName/&gt; containing this value. Case
        insensitive.
      &lt;codedType/&gt; csd:codedtype: If present and contains a non-empty value the
        result set should be restricted to those providers whose &lt;codeType/@code&gt; equals this
        value for the coding schema specified by the @codingSchema attribute. Case insensitive. 
       &lt;address/&gt; csd:address: (optional) Contains of any-number of child
        &lt;addressLine/&gt; elements as follows: 
          Text content xsd:string: (optional) If present and contains a non-empty value,
            then the results set should be restricted to those providers whose have an
            &lt;addressLine/&gt; with specified @component containing this value exactly. Case
            insensitive. 
          @component xsd:string : (Required attribute) The component of the address we
            are searching. Case insensitive.
        
      
      &lt;start/&gt;  xsd:int: (optional) The starting index for results returned.
        Defaults to 1, which indexes the first provider matching the search parameters
      &lt;max/&gt;  xsd:int: (optional) The maximum number of results returned. A value
        of less than zero implies no maximum.
       &lt;record/&gt;  csd:record : (optional) A child element to limit results
        according to 
          @status xsd:string: (optional) If present and contains a non-empty value, the
            result set should be restricted to those providers whose record/@status equals this
            value. Case insensitive.
          @updated xsd:dateTime: (optional) If present and contains a non-empty value,
            the result set should be restricted to those providers whose record/@updated is at least
            the given value.
        
      
    
    Example Request
    
         &lt;careServicesRequest&gt;
           &lt;function uuid='4e8bbeb9-f5f5-11e2-b778-0800200c9a66'&gt;
               &lt;codedType code="2221" codingSchema="ISCO-08" /&lt;
               &lt;address&gt;
                 &lt;addressLine component='city'&gt;Kigali&lt;/addressLine&gt;
	       &lt;/address&gt;
               &lt;max&gt;5&lt;/max&gt;
           &lt;/function&gt;
         &lt;/careServicesRequest&gt;         
      
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

&lt;CSD xmlns:csd="urn:ihe:iti:csd:2013"  &gt;
  &lt;organizationDirectory/&gt;
  &lt;serviceDirectory/&gt;
  &lt;facilityDirectory/&gt;
  &lt;providerDirectory&gt;
    {

      let $provs0 := if (exists($careServicesRequest/id))
	then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id)
      else /CSD/providerDirectory/*

      let $provs1 := if(exists($careServicesRequest/otherID))
	then csd_bl:filter_by_other_id($provs0,$careServicesRequest/otherID)
      else $provs0
         
      let $provs2 := if(exists($careServicesRequest/commonName))
	then csd_bl:filter_by_common_name($provs1,$careServicesRequest/commonName)
      else $provs1
    
      let $provs3 := if (exists($careServicesRequest/codedType))
	then csd_bl:filter_by_coded_type($provs2,$careServicesRequest/codedType) 
      else $provs2
   
      let $provs4 := if (exists($careServicesRequest/address/addressLine))
	then csd_bl:filter_by_demographic_address($provs3, $careServicesRequest/address/addressLine) 
      else $provs3

      let $provs5 :=  if (exists($careServicesRequest/record)) 
	then csd_bl:filter_by_record($provs4,$careServicesRequest/record)      
      else  $provs4

      let $provs6:= if (exists($careServicesRequest/start)) then
	if (exists($careServicesRequest/max)) 
	  then csd_bl:limit_items($provs5,$careServicesRequest/start,$careServicesRequest/max)         
	else csd_bl:limit_items($provs5,$careServicesRequest/start,&lt;max/&gt;)         
      else
	if (exists($careServicesRequest/max)) 
	  then csd_bl:limit_items($provs5,&lt;start/&gt;,$careServicesRequest/max)         
	else $provs5

     return 
       for $prov in $provs6
	 return 
	 &lt;provider entityID='{$prov/@entityID}'&gt;
	   &lt;demogrpahic&gt;
	   {$prov/demographic/name}
	   &lt;/demogrpahic&gt;
	 &lt;/provider&gt;

    }     
  &lt;/providerDirectory&gt;
&lt;/CSD&gt;
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:service_get_urns"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:service_get_urns</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">service_get_urns</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $srvcs0 := if (exists($careServicesRequest/id)) then csd_bl:filter_by_primary_id(/CSD/serviceDirectory/*,$careServicesRequest/id) else /CSD/serviceDirectory/*
  let $srvcs1 := if (exists($careServicesRequest/codedType)) then csd_bl:filter_by_coded_type($srvcs0,$careServicesRequest/codedType)    else $srvcs0
  let $srvcs2 := if (exists($careServicesRequest/record)) then csd_bl:filter_by_record($srvcs1,$careServicesRequest/record) else $srvcs1
  let $srvcs3 := if (exists($careServicesRequest/start) and exists($careServicesRequest/max)) then csd_bl:limit_items($srvcs2,$careServicesRequest/start,$careServicesRequest/max) else $srvcs2
  let $srvcs4 := for $entityID in $srvcs3/@entityID         
   return &lt;service entityID="{$entityID}"/&gt;

  return csd_bl:wrap_services(($srvcs4))
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_create_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_create_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_create_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $fac0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
let $fac1 := if (count($fac0) = 1) then $fac0 else ()
let $fac2 := if (exists($careServicesRequest/address/@type))  then $fac1 else ()
return  
  if ( count($fac2) = 1 )
    then
    let $facility:= $fac2[1]
    return
      let $fac3:=  
      &lt;facility entityID="{$facility/@entityID}"&gt;
        &lt;address type="{$careServicesRequest/address/@type}"/&gt;
      &lt;/facility&gt;
       return (
	   insert node
	   $careServicesRequest/address
	   into $facility
	   ,
	csd_blu:wrap_updating_facilities($fac3)
	)
  else  csd_blu:wrap_updating_facilities(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_create_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_create_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_create_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $fac0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
let $fac1 := if (count($fac0) = 1) then $fac0 else ()
let $fac2 := if (exists($careServicesRequest/contactPoint))  then $fac1 else ()
return  
  if ( count($fac2) = 1 )
    then
    let $facility:= $fac2[1]
    let $position := count($facility/contactPoint) +1
    let $cp := 
      &lt;contactPoint&gt;
	{(
	  if (exists($careServicesRequest/contactPoint/codedType)) then  $careServicesRequest/contactPoint/codedType else (),
	  if (exists($careServicesRequest/contactPoint/equipment)) then  $careServicesRequest/contactPoint/equipment else (),
	  if (exists($careServicesRequest/contactPoint/purpose)) then  $careServicesRequest/contactPoint/purpose else (),
	  if (exists($careServicesRequest/contactPoint/certificate)) then  $careServicesRequest/contactPoint/certificate else ()
	 )}
      &lt;/contactPoint&gt;
    let $fac3:=  
    &lt;facility entityID="{$facility/@entityID}"&gt;
	&lt;contactPoint position="{$position}"/&gt;
    &lt;/facility&gt;
    return 
      (insert node $cp into $facility ,    
      csd_blu:wrap_updating_facilities($fac3)
      )
  else  csd_blu:wrap_updating_facilities(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_create_geocode"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_create_geocode</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_create_geocode</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $fac0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
let $fac1 := if (count($fac0) = 1) then $fac0 else ()
let $fac2 := if (exists($careServicesRequest/geocode) and count($fac1/geocode) = 0)  then $fac1 else ()
return  
  if ( count($fac2) = 1 )
    then
    let $facility:= $fac2[1]
    return
      let $fac3:=  
      &lt;facility entityID="{$facility/@entityID}"&gt;
        &lt;geocode/&gt;
      &lt;/facility&gt;
       return (
	   insert node
	   $careServicesRequest/geocode
	   into $facility
	   ,
	csd_blu:wrap_updating_facilities($fac3)
	)
  else  csd_blu:wrap_updating_facilities(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_create_language"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_create_language</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_create_language</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $fac0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
let $fac1 := if (count($fac0) = 1) then $fac0 else ()
let $fac2 := if (exists($careServicesRequest/language/@code) and exists($careServicesRequest/language/@codingScheme))  then $fac1 else ()
let $lang0 := $fac2/language[@code = $careServicesRequest/language/@code and @codingScheme = $fac2/language/@codingScheme] 
return  
  if ( count($fac2) = 1 and count($lang0) = 0)
    then
    let $facility:= $fac2[1]
    return
      let $fac3:=  
      &lt;facility entityID="{$facility/@entityID}"&gt;
        &lt;language code="{$careServicesRequest/language/@code}" codingScheme="{$careServicesRequest/language/@codingScheme}"/&gt;
      &lt;/facility&gt;
       return (
	   insert node
	   $careServicesRequest/language
	   into $facility
	   ,
	csd_blu:wrap_updating_facilities($fac3)
	)
  else  csd_blu:wrap_updating_facilities(())</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_create_operating_hours"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_create_operating_hours</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_create_operating_hours</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $fac0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
let $fac1 := if (count($fac0) = 1) then $fac0 else ()
let $fac2 := if (exists($careServicesRequest/operatingHours))  then $fac1 else ()
return  
  if ( count($fac2) = 1 )
    then
    let $facility:= $fac2[1]
    return
      let $fac3:=  
      &lt;facility entityID="{$facility/@entityID}"&gt;
        &lt;operatingHours/&gt;
      &lt;/facility&gt;
       return (
	   insert node
	   $careServicesRequest/operatingHours
	   into $facility
	   ,
	csd_blu:wrap_updating_facilities($fac3)
	)
  else  csd_blu:wrap_updating_facilities(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_create_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_create_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_create_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $fac0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
let $fac1 := if (count($fac0) = 1) then $fac0 else ()
let $fac2 := if (exists($careServicesRequest/otherID/@code))  then $fac1 else ()
return  
  if ( count($fac2) = 1 )
    then
    let $facility:= $fac2[1]
    let $position := count($facility/otherID) +1
    let $id := 
      if (exists($careServicesRequest/otherID/@assigningAuthorityName)) then
      &lt;otherID code="{$careServicesRequest/otherID/@code}" assigningAuthorityName="{$careServicesRequest/otherID/@assigningAuthorityName}"&gt;{string($careServicesRequest/otherID)}&lt;/otherID&gt;
    else 
      &lt;otherID code="{$careServicesRequest/otherID/@code}"&gt;{string($careServicesRequest/otherID)}&lt;/otherID&gt;
    let $fac3:=  
    &lt;facility entityID="{$facility/@entityID}"&gt;
      &lt;otherID position="{$position}"/&gt;
    &lt;/facility&gt;
    return 
      (insert node $id into $facility ,    
      csd_blu:wrap_updating_facilities($fac3)
      )
  else  csd_blu:wrap_updating_facilities(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_delete_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $fac0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
let $fac1 := if (count($fac0) = 1) then $fac0 else ()
let $fac2 := if (exists($careServicesRequest/address/@type))  then $fac1 else ()
let $address:= $fac2[1]/address[@type = $careServicesRequest/address/@type]
return 
let $fac:=  
      &lt;facility entityID="{$fac2/@entityID}"&gt;
        &lt;address type="{$careServicesRequest/address/@type}"/&gt;
      &lt;/facility&gt;
       return (
	   if (exists($address)) then (delete node $address) else ()
	   ,
	csd_blu:wrap_updating_facilities($fac)
	)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_delete_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  if (exists($careServicesRequest/contactPoint/@position)) 
    then 
    let $facilities := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
    return
      if ( count($facilities) = 1 )
	then
	let  $cp :=  $facilities[1]/contactPoint[position() = $careServicesRequest/contactPoint/@position]
	return if (exists($cp)) then (delete node $cp) else ()
      else  ()
    else ()      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_geocode"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_geocode</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_delete_geocode</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $fac0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
let $fac1 := if (count($fac0) = 1) then $fac0 else ()
let $fac2 := if (exists($careServicesRequest/geocode))  then $fac1 else ()
let $geocode:= $fac2[1]/geocode
return 
let $fac:=  
      &lt;facility entityID="{$fac2/@entityID}"&gt;
        &lt;geocode/&gt;
      &lt;/facility&gt;
       return (
	   if (exists($geocode)) then (delete node $geocode) else ()
	   ,
	csd_blu:wrap_updating_facilities($fac)
	)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_language"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_language</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_delete_language</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $fac0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
let $fac1 := if (count($fac0) = 1) then $fac0 else ()
let $fac2 := if (exists($careServicesRequest/language/@code))  then $fac1 else ()
let $language:= $fac2[1]/language[@code = $careServicesRequest/language/@code]
return 
let $fac:=  
      &lt;facility entityID="{$fac2/@entityID}"&gt;
        &lt;language code="{$careServicesRequest/language/@code}"/&gt;
      &lt;/facility&gt;
       return (
	   if (exists($language)) then (delete node $language) else ()
	   ,
	csd_blu:wrap_updating_facilities($fac)
	)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_name"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_name</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_delete_name</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  if (exists($careServicesRequest/primaryName/@position)) 
    then 
    let $facilities := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
    return
      if ( count($facilities) = 1 )
	then
	let  $name :=  $facilities[1]/primaryName[position() = $careServicesRequest/primaryName/@position]
	return if (exists($name)) then (delete node $name) else ()
      else  ()
    else ()      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_operating_hours"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_operating_hours</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_delete_operating_hours</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $fac0 := if (exists($careServicesRequest/organization/@entityID)) then /CSD/facilityDirectory/*  else ()
let $fac1 := if (exists($careServicesRequest/organization/service/@position)) then $fac0  else ()
let $fac2 := if (exists($careServicesRequest/organization/service/operatingHours/@position)) then $fac1  else ()
let $fac3 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($fac2,$careServicesRequest/id) else ()
let $oh := $fac3[1]/organizations/organization[upper-case(@entityID) =upper-case($careServicesRequest/organization/@entityID)]/service[position() = $careServicesRequest/organization/service/@position]/operatingHours[position() = $careServicesRequest/organization/service/operatingHours/@position]
return
  if (count($oh) = 1)
    then (delete node $oh) else ()
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_delete_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_delete_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu" ;
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  if (exists($careServicesRequest/otherID/@position)) 
    then 
    let $facilities := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
    return
      if ( count($facilities) = 1 )
	then
	let  $id :=  $facilities[1]/otherID[position() = $careServicesRequest/otherID/@position]
	return if (exists($id)) then (delete node $id) else ()
      else  ()
    else ()      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_update_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_update_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_update_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $fac0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
let $fac1 := if (count($fac0) = 1) then $fac0 else ()
let $fac2 := if (exists($careServicesRequest/address/@type))  then $fac1 else ()
let $facility:= $fac2[1]
let $address:= $facility/address[@type = $careServicesRequest/address/@type]
return  
  if ( not(exists($address))) then
    csd_blu:wrap_updating_facilities(()) (: Address does not exist.  Do not update:)
  else
    let $fac3:=  
    &lt;facility entityID="{$facility/@entityID}"&gt;
      &lt;address type="{$careServicesRequest/address/@type}"/&gt;
    &lt;/facility&gt;
    return (
      csd_blu:bump_timestamp($facility),
      replace  node  $address with $careServicesRequest/address
      ,
      csd_blu:wrap_updating_facilities($fac3)
    )
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_update_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_update_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_update_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $fac0 := if (exists($careServicesRequest/contactPoint/@position)) then /CSD/facilityDirectory/*  else ()
let $fac1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($fac0,$careServicesRequest/id) else ()
let $old_cp := $fac1[1]/contactPoint[position() = $careServicesRequest/contactPoint/@position]
return
  if (count($fac1) = 1 and exists($old_cp)) 
    then
    let $new_cp := $careServicesRequest/contactPoint
    let $fac2 := 
    &lt;facility entityID="{$fac1[1]/@entityID}"&gt;
	  &lt;contactPoint position="{$careServicesRequest/contactPoint/@position}"/&gt;
    &lt;/facility&gt;
    return
      (
	csd_blu:bump_timestamp($fac1[1]),
	if (exists($new_cp/codedType)) then (delete node $old_cp/codedType,insert node $new_cp/codedType into $old_cp) else (),
	if (exists($new_cp/equipment)) then (delete node $old_cp/equipment,insert node $new_cp/equipment into $old_cp) else (),
	if (exists($new_cp/purpose)) then (delete node $old_cp/purpose,insert node $new_cp/purpose into $old_cp) else (),
	if (exists($new_cp/certificate)) then (delete node $old_cp/certificate,insert node $new_cp/certificate into $old_cp) else (),
	csd_blu:wrap_updating_facilities($fac2)
     )
  else 	csd_blu:wrap_updating_facilities(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_update_name"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_update_name</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_update_name</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $fac0 := if (exists($careServicesRequest/primaryName/@position)) then /CSD/facilityDirectory/*  else ()
let $fac1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($fac0,$careServicesRequest/id) else ()
let $name := $fac1[1]/primaryName[position() = $careServicesRequest/primaryName/@position]
return
  if (count($fac1) = 1 and exists($name)) 
    then
    let $fac2 := 
    &lt;facility entityID="{$fac1[1]/@entityID}"&gt;
	  &lt;name position="{$careServicesRequest/primaryName/@position}"/&gt;
    &lt;/facility&gt;
    let $new_name := $careServicesRequest/primaryName
    return
      (
	csd_blu:bump_timestamp($fac1[1]),
	replace  node $name with $new_name,
	csd_blu:wrap_updating_facilities($fac2)
     )
  else 	csd_blu:wrap_updating_facilities(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_update_operating_hours"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_update_operating_hours</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_update_operating_hours</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $fac0 := if (exists($careServicesRequest/organization/@entityID)) then /CSD/facilityDirectory/*  else ()
let $fac1 := if (exists($careServicesRequest/organization/service/@position)) then $fac0  else ()
let $fac2 := if (exists($careServicesRequest/organization/service/operatingHours/@position)) then $fac1  else ()
let $fac3 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($fac2,$careServicesRequest/id) else ()
let $oh := $fac3[1]/organizations/organization[upper-case(@entityID) =upper-case($careServicesRequest/organization/@entityID)]/service[position() = $careServicesRequest/organization/service/@position]/operatingHours[position() = $careServicesRequest/organization/service/operatingHours/@position]
return
  if (count($oh) = 1 and count($fac3) = 1)
    then
    let $new_oh := $careServicesRequest/organization/service/operatingHours
    let $fac4 := 
    &lt;facility entityID="{$fac1[1]/@entityID}"&gt;
      &lt;organizations&gt;
	&lt;organization entityID="{$careServicesRequest/organization/@entityID}"&gt;
	  &lt;service position="{$careServicesRequest/organization/service/@position}" &gt;
	    &lt;operatingHours position="{$careServicesRequest/organization/service/operatingHours/@position}"/&gt;
	  &lt;/service&gt;
	&lt;/organization&gt;
      &lt;/organizations&gt;
    &lt;/facility&gt;
    return
      (
	csd_blu:bump_timestamp($fac3[1]),
	if (exists($new_oh/openFlag)) then (delete node $oh/openFlag,insert node $new_oh/openFlag into $oh) else (),
	if (exists($new_oh/dayOfTheWeek)) then (delete node $oh/dayOfTheWeek,insert node $new_oh/dayOfTheWeek into $oh) else (),
	if (exists($new_oh/beginningHour)) then (delete node $oh/beginningHour,insert node $new_oh/beginningHour into $oh) else (),
	if (exists($new_oh/endingHour)) then (delete node $oh/endingHour,insert node $new_oh/endingHour into $oh) else (),
	if (exists($new_oh/beginEffectiveDate)) then (delete node $oh/beginEffectiveDate,insert node $new_oh/beginEffectiveDate into $oh) else (),
	if (exists($new_oh/endEffectiveDate)) then (delete node $oh/endEffectiveDate,insert node $new_oh/endEffectiveDate into $oh) else (),
	csd_blu:wrap_updating_facilities($fac4)
     )
  else 	csd_blu:wrap_updating_facilities(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_update_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_update_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_update_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $fac0 := if (exists($careServicesRequest/otherID)) then /CSD/facilityDirectory/*  else ()
let $fac1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($fac0,$careServicesRequest/id) else ()
let $id := $fac1[1]/otherID[position() = $careServicesRequest/otherID/@position]
return
  if (count($fac1) = 1 and exists($id)) 
    then
    let $fac2 := 
    &lt;facility entityID="{$fac1[1]/@entityID}"&gt;
      &lt;otherID position="{$careServicesRequest/otherID/@position}"/&gt;
    &lt;/facility&gt;
    return
      (
	csd_blu:bump_timestamp($fac1[1]),
	if ($careServicesRequest/otherID/@code) 
	  then 	    
	    if (exists($id/@code))
	      then  (replace value of node $id/@code with $careServicesRequest/otherID/@code)
	      else (insert node  $careServicesRequest/otherID/@code into $id)
	  else (),
	if (exists($careServicesRequest/otherID/@assigningAuthorityName) )
	  then 
	    if (exists($id/@assigningAuthorityName))
	      then replace value of node $id/@assigningAuthorityName with $careServicesRequest/otherID/@assigningAuthorityName
	      else insert node $careServicesRequest/otherID/@assigningAuthorityName into $id		
	  else (),
	if (not(string($careServicesRequest/otherID) = '')) 
	  then (replace value of node $id with string($careServicesRequest/otherID))
	  else (),
	csd_blu:wrap_updating_facilities($fac2)
     )
  else 	csd_blu:wrap_updating_facilities(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/address/@type))  then $provs1 else ()
return  
  if ( count($provs2) = 1 )
    then
    let $provider:= $provs2[1]
    let $demo := $provider/demographic
    return if (exists($demo/address[@type = $careServicesRequest/address/@type])) 
      then
      csd_blu:wrap_updating_providers(()) (: Do not allow the same type to be created more than once:)
    else
      let $provs3:=  
      &lt;provider entityID="{$provider/@entityID}"&gt;
        &lt;demographic&gt;&lt;address type="{$careServicesRequest/address/@type}"/&gt;&lt;/demographic&gt;
      &lt;/provider&gt;
       return (
	 if (not(exists($demo)))
	   then
	   insert node
	   &lt;demographic&gt;{$careServicesRequest/address}&lt;/demographic&gt;
	   into $provider	
	 else	
	   insert node  $careServicesRequest/address into $demo
	   ,
	csd_blu:wrap_updating_providers($provs3)
	)
  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/contactPoint))  then $provs1 else ()
return  
  if ( count($provs2) = 1 )
    then
    let $provider:= $provs2[1]
    let $position := count($provider/demographic/contactPoint) +1
    let $cp := 
      &lt;contactPoint&gt;
	{(
	  if (exists($careServicesRequest/contactPoint/codedType)) then  $careServicesRequest/contactPoint/codedType else (),
	  if (exists($careServicesRequest/contactPoint/equipment)) then  $careServicesRequest/contactPoint/equipment else (),
	  if (exists($careServicesRequest/contactPoint/purpose)) then  $careServicesRequest/contactPoint/purpose else (),
	  if (exists($careServicesRequest/contactPoint/certificate)) then  $careServicesRequest/contactPoint/certificate else ()
	 )}
      &lt;/contactPoint&gt;
    let $provs3:=  
    &lt;provider entityID="{$provider/@entityID}"&gt;
      &lt;demographic&gt;
	&lt;contactPoint position="{$position}"/&gt;
      &lt;/demographic&gt;
    &lt;/provider&gt;
    return 
      (insert node $cp into $provider/demographic ,    
      csd_blu:wrap_updating_providers($provs3)
      )
  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_credential"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_credential</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_credential</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/credential/codedType/@code) and exists($careServicesRequest/credential/codedType/@codingScheme) ) then $provs1  else ()
let $cred_request := $careServicesRequest/credential
let $code:= $cred_request/codedType/@code
let $codingScheme:= $cred_request/codedType/@codingScheme
let $creds0 := $provs2/credential/codedType[@code = $code and @codingScheme = $codingScheme]
return  
  if ( count($provs2) = 1 and count($creds0) = 0)  (:DO NOT ALLOW SAME CRED TWICE :)
    then
    let $provider:= $provs2[1]
    let $cred_rec :=
    &lt;credential&gt;
      &lt;codedType code="{$code}" codingScheme="{$codingScheme}"/&gt;
    &lt;/credential&gt;
    let $cred_new :=
    &lt;credential&gt;
      &lt;codedType code="{$code}" codingScheme="{$codingScheme}"/&gt;
      {(
	if (exists($cred_request/number)) then $cred_request/number else (),
	if (exists($cred_request/issuingAuthority)) then $cred_request/issuingAuthority else (),
	if (exists($cred_request/credentialIssueDate)) then $cred_request/credentialIssueDate else (),
        if (exists($cred_request/credentialRenewalDate)) then $cred_request/credentialRenewalDate else ()
      )}
    &lt;/credential&gt;
    let $provs3:=  
    &lt;provider entityID="{$provider/@entityID}"&gt;{$cred_rec}&lt;/provider&gt;
    return 
	(
	insert node $cred_new into $provider,
	csd_blu:wrap_updating_providers($provs3)
	)

  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_name"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_name</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_name</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/name))  then $provs1 else ()
return  
  if ( count($provs2) = 1 )
    then
    let $provider:= $provs2[1]
    let $position := count($provider/demographic/name) +1
    let $provs3:=  
    &lt;provider entityID="{$provider/@entityID}"&gt;
      &lt;demographic&gt;
	&lt;name position="{$position}"/&gt;
      &lt;/demographic&gt;
    &lt;/provider&gt;
    return 
      (
	if (exists($provider/demographic))
	  then insert node $careServicesRequest/name into $provider/demographic 
	else
	  insert node &lt;demographic&gt;{$careServicesRequest/name}&lt;/demographic&gt; into $provider
	  ,   csd_blu:wrap_updating_providers($provs3)
	)
  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_operating_hours"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_operating_hours</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_operating_hours</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $provs0 := if (exists($careServicesRequest/facility/@entityID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/facility/service/@position)) then $provs0  else ()
let $provs2 := if (exists($careServicesRequest/facility/service/operatingHours)) then $provs1  else ()
let $provs3 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs2,$careServicesRequest/id) else ()
let $srvc := $provs3[1]/facilities/facility[upper-case(@entityID) = upper-case($careServicesRequest/facility/@entityID)]/service[position() = $careServicesRequest/facility/service/@position]
return if (count($srvc) = 1) 
  then
  let $position := count($srvc/operatingHours)
  let $provs4:=  
  &lt;provider entityID="{$careServicesRequest/id/@entityID}"&gt;
    &lt;facilities&gt;
      &lt;facility entityID="{$careServicesRequest/facility/@entityID}"&gt;
	&lt;service position="{$careServicesRequest/facility/service/@position}" entityID="{$careServicesRequest/facility/service/@entityID}"&gt;
	  &lt;operatingHours position="{$position}" /&gt;
	&lt;/service&gt;
      &lt;/facility&gt;
    &lt;/facilities&gt;
  &lt;/provider&gt;
  return 
    (insert node $careServicesRequest/facility/service/operatingHours into $srvc[1] ,    
    csd_blu:wrap_updating_providers($provs4)
  )
else   csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_org_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_org_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_org_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/organization/@entityID))  then $provs1 else ()
let $provs3 := if (exists($careServicesRequest/organization/address/@type))  then $provs2 else ()
let $provider:= $provs3[1]
let $orgs := $provider/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]
let $org := if(count($orgs) =1) then $orgs[1] else ()
let $address := $org/address[@type = $careServicesRequest/organization/address/@type]
return if (not(exists($org)) or exists($address))
  then   csd_blu:wrap_updating_providers(()) (:do not create an already existing one :)	  
else
  (
    insert node $careServicesRequest/organization/address into $org,
    csd_blu:wrap_updating_providers(    
	&lt;provider entityID="{$provider/@entityID}"&gt;
	  &lt;organizations&gt;
	    &lt;organization entityID="{$org/@entityID}"&gt;
	      &lt;contactPoint position="{$careServicesRequest/organization/address/@type}"/&gt;
	    &lt;/organization&gt;
	  &lt;/organizations&gt;
	&lt;/provider&gt;
     )
)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_org_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_org_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_org_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/organization/@entityID))  then $provs1 else ()
let $provs3 := if (exists($careServicesRequest/organization/contactPoint))  then $provs2 else ()
return  
  if ( count($provs3) = 1 )
    then
    let $provider:= $provs3[1]
    let $orgs := $provider/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]
    return 
      if (count($orgs) = 1) 
	then
	let $org := $orgs[1]
	let $position := count($org/contactPoint) +1
	let $new_cp := $careServicesRequest/organization/contactPoint
	let $cp := 
	&lt;contactPoint&gt;
	  {(
	    if (exists($new_cp/codedType)) then  $new_cp/codedType else (),
            if (exists($new_cp/equipment)) then  $new_cp/equipment else (),
            if (exists($new_cp/purpose)) then  $new_cp/purpose else (),
            if (exists($new_cp/certificate)) then  $new_cp/certificate else ()
	   )}
	&lt;/contactPoint&gt;
	let $provs3:=  
	&lt;provider entityID="{$provider/@entityID}"&gt;
	  &lt;organizations&gt;
	    &lt;organization entityID="{$org/@entityID}"&gt;
	      &lt;contactPoint position="{$position}"/&gt;
	    &lt;/organization&gt;
	  &lt;/organizations&gt;
	&lt;/provider&gt;
	return 
	  (insert node $cp into $org ,    
	  csd_blu:wrap_updating_providers($provs3)
	)
      else   csd_blu:wrap_updating_providers(())
    else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/otherID/@code))  then $provs1 else ()
return  
  if ( count($provs2) = 1 )
    then
    let $provider:= $provs2[1]
    let $position := count($provider/otherID) +1
    let $id := 
      if (exists($careServicesRequest/otherID/@assigningAuthorityName)) then
      &lt;otherID code="{$careServicesRequest/otherID/@code}" assigningAuthorityName="{$careServicesRequest/otherID/@assigningAuthorityName}"&gt;{string($careServicesRequest/otherID)}&lt;/otherID&gt;
    else 
      &lt;otherID code="{$careServicesRequest/otherID/@code}"&gt;{string($careServicesRequest/otherID)}&lt;/otherID&gt;
    let $provs3:=  
    &lt;provider entityID="{$provider/@entityID}"&gt;
      &lt;otherID position="{$position}"/&gt;
    &lt;/provider&gt;
    return 
      (insert node $id into $provider ,    
      csd_blu:wrap_updating_providers($provs3)
      )
  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_provider</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
(:
import module namespace random = "http://basex.org/modules/random";
:)
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $provs0 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()  
return
  if (count($provs0) &gt; 0) then (csd_blu:wrap_updating_providers(()))     (:do not allow duplicate ENTITYIDs:)
else
  let $entityID := 
    if (exists($careServicesRequest/id/@entityID) and not($careServicesRequest/id/@entityID = '')) then $careServicesRequest/id/@entityID
  else concat('urn:uuid:', random:uuid())
  let $time :=current-dateTime()
  let $prov := 
  &lt;provider entityID="{$entityID}"&gt;
    {(
      $careServicesRequest/codedType,
      &lt;demographic&gt;
	{(
	  $careServicesRequest/gender,
	  $careServicesRequest/dateOfBirth
	 )}
	 &lt;/demographic&gt;,
	 $careServicesRequest/language,
         $careServicesRequest/specialty,
	 if ($careServicesRequest/status) 
	   then
	   &lt;record created="{$time}" updated="{$time}" status="{$careServicesRequest/status}" sourceDirectory="{$careServicesRequest/sourceDirectory}"/&gt;
	 else 
	   &lt;record created="{$time}" updated="{$time}" status="Active" sourceDirectory="{$careServicesRequest/sourceDirectory}"/&gt;
     )}
  &lt;/provider&gt;
  
  return (
    insert node $prov into /CSD/providerDirectory,  
    csd_blu:wrap_updating_providers(&lt;provider entityID="{$entityID}"/&gt;)
  )

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider_facility"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider_facility</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_provider_facility</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/facility/@entityID))  then $provs1 else ()
let $facs0 := $provs2/facilities/facility[upper-case(@entityID) = upper-case($careServicesRequest/facility/@entityID)]
let $facilities := $provs2/facilities[1]
return  
  if ( count($provs2) = 1 and count($facs0) = 0)  (:DO NOT ALLOW SAME ORG TWICE :)
    then
    let $provider:= $provs2[1]
    let $fac :=  &lt;facility entityID="{$careServicesRequest/facility/@entityID}"/&gt;
    let $facs_new :=  &lt;facilities&gt;{$fac}&lt;/facilities&gt;

    let $provs3:=  
    &lt;provider entityID="{$provider/@entityID}"&gt;{$facs_new}&lt;/provider&gt;
    return 
      if (exists($facilities)) 
	then
	(insert node $fac into $facilities, 
	csd_blu:wrap_updating_providers($provs3)
	)
      else
	(
	insert node $facs_new into $provider,
	csd_blu:wrap_updating_providers($provs3)
	)

  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider_organization"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_provider_organization</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_provider_organization</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/organization/@entityID))  then $provs1 else ()
let $orgs0 := $provs2/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]
let $organizations := $provs2/organizations[1]
return  
  if ( count($provs2) = 1 and count($orgs0) = 0)  (:DO NOT ALLOW SAME ORG TWICE :)
    then
    let $provider:= $provs2[1]
    let $org :=  &lt;organization entityID="{$careServicesRequest/organization/@entityID}"/&gt;
    let $orgs_new :=  &lt;organizations&gt;{$org}&lt;/organizations&gt;

    let $provs3:=  
    &lt;provider entityID="{$provider/@entityID}"&gt;{$orgs_new}&lt;/provider&gt;
    return 
      if (exists($organizations)) 
	then
	(insert node $org into $organizations, 
	csd_blu:wrap_updating_providers($provs3)
	)
      else
	(
	insert node $orgs_new into $provider,
	csd_blu:wrap_updating_providers($provs3)
	)

  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_service"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_create_service</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_create_service</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/facility/@entityID))  then $provs1 else ()
let $provs3 := if (exists($careServicesRequest/facility/service/@entityID))  then $provs2 else ()
let $provider:=   if ( count($provs3) = 1 ) then $provs3[1] else ()
let $facs := $provider/facilities/facility[upper-case(@entityID) = upper-case($careServicesRequest/facility/@entityID)]
let $fac := if (count($facs) = 1) then $facs[1] else ()
return if (exists($fac))
  then
  let $position := count($fac/service) +1
  let $srvc := 
  &lt;service entityID="{$careServicesRequest/facility/service/@entityID}"&gt;
    {(
      $careServicesRequest/facility/service/organization,
      $careServicesRequest/facility/service/language,
      $careServicesRequest/facility/service/freeBusyURI
     )}
  &lt;/service&gt;
  let $provs3:=  
  &lt;provider entityID="{$provider/@entityID}"&gt;
    &lt;facilities&gt;
      &lt;facility entityID="{$fac/@entityID}"&gt;
	&lt;service position="{$position}" entityID="{$careServicesRequest/facility/service/@entityID}"/&gt;
      &lt;/facility&gt;
    &lt;/facilities&gt;
  &lt;/provider&gt;
  return 
    (insert node $srvc into $fac ,    
    csd_blu:wrap_updating_providers($provs3)
  )
else   csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/address/@type))  then $provs1 else ()
let $address:= $provs2[1]/demographic/address[@type = $careServicesRequest/address/@type]
return if (exists($address)) then (delete node $address) else ()
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  if (exists($careServicesRequest/contactPoint/@position)) 
    then 
    let $providers := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
    return
      if ( count($providers) = 1 )
	then
	let  $cp :=  $providers[1]/demographic/contactPoint[position() = $careServicesRequest/contactPoint/@position]
	return if (exists($cp)) then (delete node $cp) else ()
      else  ()
    else ()      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_credential"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_credential</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_credential</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/credential/codedType/@code) and exists($careServicesRequest/credential/codedType/@codingScheme) ) then $provs1  else ()
let $cred_new := $careServicesRequest/credential
let $code:= $cred_new/codedType/@code
let $codingScheme:= $cred_new/codedType/@codingScheme
let $creds0 := $provs2/credential[@code = $code and @codingScheme = $codingScheme]
return  
  if ( count($provs2) = 1 and count($creds0) = 1)  then
    delete node $creds0[1]
  else
    ()
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_name"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_name</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_name</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  if (exists($careServicesRequest/name/@position)) 
    then 
    let $providers := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
    return
      if ( count($providers) = 1 )
	then
	let  $name :=  $providers[1]/demographic/name[position() = $careServicesRequest/name/@position]
	return if (exists($name)) then (delete node $name) else ()
      else  ()
    else ()      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_operating_hours"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_operating_hours</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_operating_hours</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $provs0 := if (exists($careServicesRequest/facility/@entityID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/facility/service/@position)) then $provs0  else ()
let $provs2 := if (exists($careServicesRequest/facility/service/operatingHours/@position)) then $provs1  else ()
let $provs3 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs2,$careServicesRequest/id) else ()
let $oh := $provs3[1]/facilities/facility[upper-case(@entityID) =upper-case($careServicesRequest/facility/@entityID)]/service[position() = $careServicesRequest/facility/service/@position]/operatingHours[position() = $careServicesRequest/facility/service/operatingHours/@position]
return
  if (count($oh) = 1)
    then (delete node $oh) else ()
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_org_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_org_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_org_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/organization/@entityID))  then $provs1 else ()
let $provs3 := if (exists($careServicesRequest/organization/address/@type))  then $provs2 else ()
let $provider:= $provs3[1]
let $orgs := $provider/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]
let $org := if(count($orgs) =1) then $orgs[1] else ()
let $address := $org/address[@type = $careServicesRequest/organization/address/@type]
return if (exists($address)) then (delete node $address) else ()
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_org_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_org_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_org_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  if (exists($careServicesRequest/organization/contactPoint/@position) and exists($careServicesRequest/organization/@entityID)) 
    then 
    let $providers := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
    return
      if ( count($providers) = 1 )
	then
	let $orgs := $providers[1]/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]
	return
	  if (count($orgs) = 1) then
	    let  $cp :=  $orgs[1]/contactPoint[position() = $careServicesRequest/organization/contactPoint/@position]
	    return if (exists($cp)) then (delete node $cp) else ()
	  else () 
      else  ()
    else ()      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu" ;
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  if (exists($careServicesRequest/otherID/@position)) 
    then 
    let $providers := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
    return
      if ( count($providers) = 1 )
	then
	let  $id :=  $providers[1]/otherID[position() = $careServicesRequest/otherID/@position]
	return if (exists($id)) then (delete node $id) else ()
      else  ()
    else ()      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_provider</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $provs0 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()  
return  if (count($provs0) = 1) then
  delete node $provs0[1] else ()
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider_facility"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider_facility</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_provider_facility</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  if (exists($careServicesRequest/facility/@entityID)) 
    then 
    let $providers := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
    return
      if ( count($providers) = 1 )
	then
	let  $fac :=  $providers[1]/facilities/facility[upper-case(@entityID) = upper-case($careServicesRequest/facility/@entityID)]
	return if (exists($fac)) then (delete node $fac) else ()
      else  ()
    else ()      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider_organization"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_provider_organization</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_provider_organization</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  if (exists($careServicesRequest/organization/@entityID)) 
    then 
    let $providers := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
    return
      if ( count($providers) = 1 )
	then
	let  $org :=  $providers[1]/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]
	return if (exists($org)) then (delete node $org) else ()
      else  ()
    else ()      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_service"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_delete_service</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_delete_service</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  if (exists($careServicesRequest/facility/service/@position) and exists($careServicesRequest/facility/@entityID)) 
    then 
    let $providers := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
    return
      if ( count($providers) = 1 )
	then
	let $facs := $providers[1]/facilities/facility[upper-case(@entityID) = upper-case($careServicesRequest/facility/@entityID)]
	return
	  if (count($facs) = 1) then
	    let  $srvc :=  $facs[1]/service[position() = $careServicesRequest/facility/service/@position]
	    return if (exists($srvc)) then (delete node $srvc) else ()
	  else () 
      else  ()
    else ()      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/address/@type))  then $provs1 else ()
let $provider:= $provs2[1]
let $demo := $provider/demographic
let $address:= $demo/address[@type = $careServicesRequest/address/@type]
return  
  if ( not(exists($address))) then
    csd_blu:wrap_updating_providers(()) (: Address does not exist.  Do not update:)
  else
    let $provs3:=  
    &lt;provider entityID="{$provider/@entityID}"&gt;
      &lt;demographic&gt;&lt;address type="{$careServicesRequest/address/@type}"/&gt;&lt;/demographic&gt;
    &lt;/provider&gt;
    return (
      csd_blu:bump_timestamp($provider),
      replace  node  $address with $careServicesRequest/address
      ,
      csd_blu:wrap_updating_providers($provs3)
    )
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $provs0 := if (exists($careServicesRequest/contactPoint/@position)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $old_cp := $provs1[1]/demographic/contactPoint[position() = $careServicesRequest/contactPoint/@position]
return
  if (count($provs1) = 1 and exists($old_cp)) 
    then
    let $new_cp := $careServicesRequest/contactPoint
    let $provs2 := 
    &lt;provider entityID="{$provs1[1]/@entityID}"&gt;
      &lt;demographic&gt;
	&lt;contactPoint position="{$careServicesRequest/contactPoint/@position}"/&gt;
      &lt;/demographic&gt;
    &lt;/provider&gt;
    return
      (
	csd_blu:bump_timestamp($provs1[1]),
	delete node $old_cp/codeType,
	if (exists($new_cp/codeType)) then insert node $new_cp/codeType into $old_cp else (),
	delete node $old_cp/equipment,
	if (exists($new_cp/equipment)) then insert node $new_cp/equipment into $old_cp else (),
	delete node $old_cp/purpose,
	if (exists($new_cp/purpose)) then insert node $new_cp/purpose into $old_cp else (),
	delete node $old_cp/certificate,
	if (exists($new_cp/certificate)) then insert node $new_cp/certificate into $old_cp else (),
	csd_blu:wrap_updating_providers($provs2)
     )
  else 	csd_blu:wrap_updating_providers(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_credential"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_credential</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_credential</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/credential/codedType/@code) and exists($careServicesRequest/credential/codedType/@codingScheme) ) then $provs1  else ()
let $cred_new := $careServicesRequest/credential
let $code:= $cred_new/codedType/@code
let $codingScheme:= $cred_new/codedType/@codingScheme
let $creds0 := $provs2/credential/codedType[@code = $code and @codingScheme = $codingScheme]
return  
  if ( count($provs2) = 1 and count($creds0) = 1)  (:Update only:)
    then
    let $cred_old := $creds0[1]/..
    let $provider:= $provs2[1]
    let $provs3 := 
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;credential&gt;
	  &lt;codedType code="{$code}" codingScheme="{$codingScheme}"/&gt;
	&lt;/credential&gt;
      &lt;/provider&gt;


    return
      
      (
	csd_blu:bump_timestamp($provider),
	if (exists($cred_new/issuingAuthority)) then
	  (if (exists($cred_old/issuingAuthority)) then (delete node $cred_old/issuingAuthority) else (),
	  insert node $cred_new/issuingAuthority into $cred_old)
	else (),
	if (exists($cred_new/number)) then
	  (if (exists($cred_old/number)) then (delete node $cred_old/number) else (),
	  insert node $cred_new/number into $cred_old)
	else (),
	if (exists($cred_new/credentialIssueDate)) then
	  (if (exists($cred_old/credentialIssueDate)) then (delete node $cred_old/credentialIssueDate) else (),
	  insert node $cred_new/credentialIssueDate into $cred_old)
	else (),
	if (exists($cred_new/credentialRenewalDate)) then
	  (if (exists($cred_old/credentialRenewalDate)) then (delete node $cred_old/credentialRenewalDate) else (),
	  insert node $cred_new/credentialRenewalDate into $cred_old)
	else (),
	csd_blu:wrap_updating_providers($provs3)
       )
  else 	csd_blu:wrap_updating_providers(())
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_name"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_name</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_name</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $provs0 := if (exists($careServicesRequest/name/@position)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $name := $provs1[1]/demographic/name[position() = $careServicesRequest/name/@position]
return
  if (count($provs1) = 1 and exists($name)) 
    then
    let $provs2 := 
    &lt;provider entityID="{$provs1[1]/@entityID}"&gt;
      &lt;demographic&gt;
	&lt;name position="{$careServicesRequest/name/@position}"/&gt;
      &lt;/demographic&gt;
    &lt;/provider&gt;
    let $new_name := 
    &lt;name&gt;
     {$careServicesRequest/name/*}
    &lt;/name&gt;
    return
      (
	csd_blu:bump_timestamp($provs1[1]),
	replace  node $name with $new_name,
	csd_blu:wrap_updating_providers($provs2)
     )
  else 	csd_blu:wrap_updating_providers(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_operating_hours"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_operating_hours</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_operating_hours</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $provs0 := if (exists($careServicesRequest/facility/@entityID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/facility/service/@position)) then $provs0  else ()
let $provs2 := if (exists($careServicesRequest/facility/service/operatingHours/@position)) then $provs1  else ()
let $provs3 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs2,$careServicesRequest/id) else ()
let $oh := $provs3[1]/facilities/facility[upper-case(@entityID) =upper-case($careServicesRequest/facility/@entityID)]/service[position() = $careServicesRequest/facility/service/@position]/operatingHours[position() = $careServicesRequest/facility/service/operatingHours/@position]
return
  if (count($oh) = 1 and count($provs3) = 1)
    then
    let $new_oh := $careServicesRequest/facility/service/operatingHours
    let $provs4 := 
    &lt;provider entityID="{$provs1[1]/@entityID}"&gt;
      &lt;facilities&gt;
	&lt;facility entityID="{$careServicesRequest/facility/@entityID}"&gt;
	  &lt;service position="{$careServicesRequest/facility/service/@position}" &gt;
	    &lt;operatingHours position="{$careServicesRequest/facility/service/operatingHours/@position}"/&gt;
	  &lt;/service&gt;
	&lt;/facility&gt;
      &lt;/facilities&gt;
    &lt;/provider&gt;
    return
      (
	csd_blu:bump_timestamp($provs3[1]),
	delete node $oh/openFlag,
	if (exists($new_oh/openFlag)) then insert node $new_oh/openFlag into $oh else (),
	delete node $oh/dayOfTheWeek,
	if (exists($new_oh/dayOfTheWeek)) then insert node $new_oh/dayOfTheWeek into $oh else (),
	delete node $oh/beginningHour,
	if (exists($new_oh/beginningHour)) then insert node $new_oh/beginningHour into $oh else (),
	delete node $oh/endingHour,
	if (exists($new_oh/endingHour)) then insert node $new_oh/endingHour into $oh else (),
	delete node $oh/beginEffectiveDate,
	if (exists($new_oh/beginEffectiveDate)) then insert node $new_oh/beginEffectiveDate into $oh else (),
	delete node $oh/endEffectiveDate,
	if (exists($new_oh/endEffectiveDate)) then insert node $new_oh/endEffectiveDate into $oh else (),
	csd_blu:wrap_updating_providers($provs4)
     )
  else 	csd_blu:wrap_updating_providers(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_org_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_org_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_org_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/organization/@entityID))  then $provs1 else ()
let $provs3 := if (exists($careServicesRequest/organization/address/@type))  then $provs2 else ()
let $provider:= $provs3[1]
let $org_container := $provider/organizations[1]
let $orgs := $provider/organizations/organization[upper-case(@entityID) = upper-case($careServicesRequest/organization/@entityID)]
let $org := if(count($orgs) =1) then $orgs[1] else ()
let $address := $org/address[@type = $careServicesRequest/organization/address/@type]
return if (not(exists($address)))
  then   csd_blu:wrap_updating_providers((&lt;bad0/&gt;,$careServicesRequest)) (:do not update an non-existent one :)
else
  (
    csd_blu:bump_timestamp($provider),
    replace node $address with  $careServicesRequest/organization/address ,
     csd_blu:wrap_updating_providers(    
       &lt;provider entityID="{$provider/@entityID}"&gt;
	 &lt;organizations&gt;
	   &lt;organization entityID="{$org/@entityID}"&gt;
	     &lt;contactPoint position="{$address/@type}"/&gt;
	   &lt;/organization&gt;
	 &lt;/organizations&gt;
       &lt;/provider&gt;
    )
)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_org_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_org_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_org_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $provs0 := if (exists($careServicesRequest/organization/@entityID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/organization/contactPoint/@position)) then $provs0  else ()
let $provs2 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs1,$careServicesRequest/id) else ()
let $old_cp := $provs2[1]/organizations/organization[upper-case(@entityID) =upper-case($careServicesRequest/organization/@entityID)]/contactPoint[position() = $careServicesRequest/organization/contactPoint/@position]
return
  if (count($provs2) = 1 and exists($old_cp)) 
    then
    let $new_cp := $careServicesRequest/organization/contactPoint
    let $provs3 := 
    &lt;provider entityID="{$provs1[1]/@entityID}"&gt;
      &lt;organizations&gt;
	&lt;organization entityID="{$careServicesRequest/organization/@entityID}"&gt;
	  &lt;contactPoint position="{$careServicesRequest/organization/contactPoint/@position}"/&gt;
	&lt;/organization&gt;
      &lt;/organizations&gt;
    &lt;/provider&gt;
    return
      (
	csd_blu:bump_timestamp($provs2[1]),
	delete node $old_cp/codeType,
	if (exists($new_cp/codeType)) then insert node $new_cp/codeType into $old_cp else (),
	delete node $old_cp/equipment,
	if (exists($new_cp/equipment)) then insert node $new_cp/equipment into $old_cp else (),
	delete node $old_cp/purpose,
	if (exists($new_cp/purpose)) then insert node $new_cp/purpose into $old_cp else (),
	delete node $old_cp/certificate,
	if (exists($new_cp/certificate)) then insert node $new_cp/certificate into $old_cp else (),
	csd_blu:wrap_updating_providers($provs3)
     )
  else 	csd_blu:wrap_updating_providers(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $provs0 := if (exists($careServicesRequest/otherID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $id := $provs1[1]/otherID[position() = $careServicesRequest/otherID/@position]
return
  if (count($provs1) = 1 and exists($id)) 
    then
    let $provs2 := 
    &lt;provider entityID="{$provs1[1]/@entityID}"&gt;
      &lt;otherID position="{$careServicesRequest/otherID/@position}"/&gt;
    &lt;/provider&gt;
    return
      (
	csd_blu:bump_timestamp($provs1[1]),
	if ($careServicesRequest/otherID/@code) 
	  then 	    
	    if (exists($id/@code))
	      then  (replace value of node $id/@code with $careServicesRequest/otherID/@code)
	      else (insert node  $careServicesRequest/otherID/@code into $id)
	  else (),
	if (exists($careServicesRequest/otherID/@assigningAuthorityName) )
	  then 
	    if (exists($id/@assigningAuthorityName))
	      then replace value of node $id/@assigningAuthorityName with $careServicesRequest/otherID/@assigningAuthorityName
	      else insert node $careServicesRequest/otherID/@assigningAuthorityName into $id		
	  else (),
	if (not(string($careServicesRequest/otherID) = '')) 
	  then (replace value of node $id with string($careServicesRequest/otherID))
	  else (),
	csd_blu:wrap_updating_providers($provs2)
     )
  else 	csd_blu:wrap_updating_providers(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_provider</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $provs0 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()  
return
  if (not (count($provs0) = 1)) 
    then ( csd_blu:wrap_updating_providers((&lt;bad/&gt;)))     (:do nothing :)
  else
    let $provider := $provs0[1]
    let $demo := $provider/demographic
    let $dob := $demo/dateOfBirth
    let $gender := $demo/gender
    return 
      (
	csd_blu:bump_timestamp($provider),
	delete node $provider/codedType,
	insert node $careServicesRequest/codedType into $provider,
	if (not(exists($demo)))
	  then
	  insert node
	  &lt;demographic&gt;
	    {($careServicesRequest/gender,$careServicesRequest/dateOfBirth)}
	  &lt;/demographic&gt;
	  into $provider	
	else	
	  (
	    if (not(exists($dob))) then  insert node $careServicesRequest/dateOfBirth into $demo else replace value of node  $demo/dateOfBirth with $careServicesRequest/dateOfBirth,
	    if (not(exists($gender))) then  insert node $careServicesRequest/gender into $demo else replace value of node  $demo/gender with $careServicesRequest/gender
	),
	delete node $provider/language,
	insert node $careServicesRequest/language into $provider,
	delete node $provider/specialty,
	insert node $careServicesRequest/specialty into $provider,
	if (exists($provider/record/@status)) 
	  then replace value of node $provider/record/@status with $careServicesRequest/status 
	else insert node attribute { 'status' } { string($careServicesRequest/status) } into $provider/record,
	csd_blu:wrap_updating_providers(&lt;provider entityID="{$provider/@entityID}" /&gt;)
    )

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider_facility"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider_facility</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_provider_facility</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
() (: does nothing:)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider_organization"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_provider_organization</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_provider_organization</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
() (: does nothing:)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_service"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:health_worker_update_service</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">health_worker_update_service</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $provs0 := if (exists($careServicesRequest/facility/@entityID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/facility/service/@position)) then $provs0  else ()
let $provs2 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs1,$careServicesRequest/id) else ()
let $old_srvc := $provs2[1]/facilities/facility[upper-case(@entityID) =upper-case($careServicesRequest/facility/@entityID)]/service[position() = $careServicesRequest/facility/service/@position]
return
  if (count($provs2) = 1 and exists($old_srvc)) 
    then
    let $new_srvc := $careServicesRequest/facility/service
    let $provs3 := 
    &lt;provider entityID="{$provs1[1]/@entityID}"&gt;
      &lt;facilities&gt;
	&lt;facility entityID="{$careServicesRequest/facility/@entityID}"&gt;
	  &lt;service position="{$careServicesRequest/facility/service/@position}" /&gt;
	&lt;/facility&gt;
      &lt;/facilities&gt;
    &lt;/provider&gt;
    return
      (
	csd_blu:bump_timestamp($provs2[1]),
	delete node $old_srvc/freeBusyURI,
	if (exists($new_srvc/freeBusyURI)) then insert node $new_srvc/freeBusyURI into $old_srvc else (),
	delete node $old_srvc/organization,
	if (exists($new_srvc/organization)) then insert node $new_srvc/organization into $old_srvc else (),
	delete node $old_srvc/language,
	if (exists($new_srvc/language)) then insert node $new_srvc/language into $old_srvc else (),
	csd_blu:wrap_updating_providers($provs3)
     )
  else 	csd_blu:wrap_updating_providers(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:facility_create_address"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:facility_create_address</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">facility_create_address</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $fac0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/facilityDirectory/*,$careServicesRequest/id) else ()
let $fac1 := if (count($fac0) = 1) then $fac0 else ()
let $fac2 := if (exists($careServicesRequest/address/@type))  then $fac1 else ()
return  
  if ( count($fac2) = 1 )
    then
    let $facility:= $fac2[1]
    return
      let $fac3:=  
      &lt;facility entityID="{$facility/@entityID}"&gt;
        &lt;address type="{$careServicesRequest/address/@type}"/&gt;
      &lt;/facility&gt;
       return (
	   insert node
	   $careServicesRequest/address
	   into $facility
	   ,
	csd_blu:wrap_updating_facilities($fac3)
	)
  else  csd_blu:wrap_updating_facilities(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_create_contact_point"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_create_contact_point</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">organization_create_contact_point</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $orgs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/organizationDirectory/*,$careServicesRequest/id) else ()
let $orgs1 := if (count($orgs0) = 1) then $orgs0 else ()
let $orgs2 := if (exists($careServicesRequest/contactPoint))  then $orgs1 else ()
return  
  if ( count($orgs2) = 1 )
    then
    let $organization:= $orgs2[1]
    let $position := count($organization/contactPoint) +1
    let $cp := 
      &lt;contactPoint&gt;
	{(
	  if (exists($careServicesRequest/contactPoint/codedType)) then  $careServicesRequest/contactPoint/codedType else (),
	  if (exists($careServicesRequest/contactPoint/equipment)) then  $careServicesRequest/contactPoint/equipment else (),
	  if (exists($careServicesRequest/contactPoint/purpose)) then  $careServicesRequest/contactPoint/purpose else (),
	  if (exists($careServicesRequest/contactPoint/certificate)) then  $careServicesRequest/contactPoint/certificate else ()
	 )}
      &lt;/contactPoint&gt;
    let $orgs3:=  
    &lt;organization entityID="{$organization/@entityID}"&gt;
	&lt;contactPoint position="{$position}"/&gt;
    &lt;/organization&gt;
    return 
      (insert node $cp into $organization ,    
      csd_blu:wrap_updating_organizations($orgs3)
      )
  else  csd_blu:wrap_updating_organizations(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_create_credential"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_create_credential</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">organization_create_credential</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $orgs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/organizationDirectory/*,$careServicesRequest/id) else ()
let $orgs1 := if (count($orgs0) = 1) then $orgs0 else ()
let $orgs2 := if (exists($careServicesRequest/credential/codedType/@code) and exists($careServicesRequest/credential/codedType/@codingScheme) ) then $orgs1  else ()
let $cred_request := $careServicesRequest/credential
let $code:= $cred_request/codedType/@code
let $codingScheme:= $cred_request/codedType/@codingScheme
let $creds0 := $orgs2/credential/codedType[@code = $code and @codingScheme = $codingScheme]
return  
  if ( count($orgs2) = 1 and count($creds0) = 0)  (:DO NOT ALLOW SAME CRED TWICE :)
    then
    let $organization:= $orgs2[1]
    let $cred_rec :=
    &lt;credential&gt;
      &lt;codedType code="{$code}" codingScheme="{$codingScheme}"/&gt;
    &lt;/credential&gt;
    let $cred_new :=
    &lt;credential&gt;
      &lt;codedType code="{$code}" codingScheme="{$codingScheme}"/&gt;
      {(
	if (exists($cred_request/number)) then $cred_request/number else (),
	if (exists($cred_request/issuingAuthority)) then $cred_request/issuingAuthority else (),
	if (exists($cred_request/credentialIssueDate)) then $cred_request/credentialIssueDate else (),
        if (exists($cred_request/credentialRenewalDate)) then $cred_request/credentialRenewalDate else ()
      )}
    &lt;/credential&gt;
    let $orgs3:=  
    &lt;organization entityID="{$organization/@entityID}"&gt;{$cred_rec}&lt;/organization&gt;
    return 
	(
	insert node $cred_new into $organization,
	csd_blu:wrap_updating_organizations($orgs3)
	)

  else  csd_blu:wrap_updating_organizations(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr:stored-function:organization_create_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr:stored-function:organization_create_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">organization_create_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $orgs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/organizationDirectory/*,$careServicesRequest/id) else ()
let $orgs1 := if (count($orgs0) = 1) then $orgs0 else ()
let $orgs2 := if (exists($careServicesRequest/otherID/@code))  then $orgs1 else ()
return  
  if ( count($orgs2) = 1 )
    then
    let $organization:= $orgs2[1]
    let $position := count($organization/otherID) +1
    let $id := 
      if (exists($careServicesRequest/otherID/@assigningAuthorityName)) then
      &lt;otherID code="{$careServicesRequest/otherID/@code}" assigningAuthorityName="{$careServicesRequest/otherID/@assigningAuthorityName}"&gt;{string($careServicesRequest/otherID)}&lt;/otherID&gt;
    else 
      &lt;otherID code="{$careServicesRequest/otherID/@code}"&gt;{string($careServicesRequest/otherID)}&lt;/otherID&gt;
    let $orgs3:=  
    &lt;organization entityID="{$organization/@entityID}"&gt;
      &lt;otherID position="{$position}"/&gt;
    &lt;/organization&gt;
    return 
      (insert node $id into $organization ,    
      csd_blu:wrap_updating_organizations($orgs3)
      )
  else  csd_blu:wrap_updating_organizations(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rapidpro:get_json_for_import"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        application/json<br/>
	URN: urn:openhie.org:openinfoman-rapidpro:get_json_for_import</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Get JSON representation of CSD for import to RapidPro via API
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csr_proc = "https://github.com/openhie/openinfoman/csr_proc";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";

declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;



let $careServicesSubRequest :=  
  &lt;csd:careServicesRequest&gt;
    &lt;csd:function  urn="urn:ihe:iti:csd:2014:stored-function:provider-search" &gt;
      &lt;csd:requestParams/&gt;
    &lt;/csd:function&gt;
  &lt;/csd:careServicesRequest&gt; 

let $providers := csr_proc:process_CSR_stored_results($csd_webconf:db, /. , $careServicesSubRequest)


let $contacts :=  
  &lt;json type='object'&gt;
    &lt;contacts type="array"&gt;
    {
      for $provider in  $providers/csd:providerDirectory/csd:provider
      let $uuid := lower-case(string($provider/@entityID))
      let $payrollnum := $provider/csd:otherID[@code="1"]/text()
      let $payrollisssue := string($provider/csd:otherID[@code="1"]/@issuedate)
      let $name := ($provider/csd:demographic/csd:name/csd:commonName)[1]/text()
      let $tels := $provider/csd:demographic/csd:contactPoint/csd:codedType[@code="BP" and  @codingScheme="urn:ihe:iti:csd:2013:contactPoint"]
      let $tel_1 := $tels[1]/text()
      let $tel_2 := $tels[2]/text()
      let $tel_3 := $tels[3]/text()
      return 
	if (true()) (:  ($uuid and $name)  :)
       then 
         &lt;_  type="object"&gt;
	   &lt;name&gt;{$name}&lt;/name&gt;
	   &lt;urns type="array"&gt;
             { if ($tel_1) then   &lt;_ type='string'&gt;tel:{$tel_1}&lt;/_&gt; else ()} 
             { if ($tel_2) then   &lt;_ type='string'&gt;tel:{$tel_2}&lt;/_&gt; else ()} 
             { if ($tel_3) then   &lt;_ type='string'&gt;tel:{$tel_3}&lt;/_&gt; else ()} 
	   &lt;/urns&gt;
	   &lt;fields type="object"&gt;
             &lt;globalid&gt;{$uuid}&lt;/globalid&gt;
             &lt;payrollnum&gt;{$payrollnum}&lt;/payrollnum&gt;
             &lt;payrollissue&gt;{$payrollisssue}&lt;/payrollissue&gt;
	   &lt;/fields&gt;
         &lt;/_&gt;
       else ()
    }
    &lt;/contacts&gt;
  &lt;/json&gt;


return json:serialize($contacts,map{"format":"direct"})  
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-liberia:mhero-merge"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-liberia:mhero-merge</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Performs merge for Liberia preserving any mHero/RapidPRO identifiers for existing providers.
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";

import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";

import module namespace mhero = "https://github.com/openhie/openinfoman-mhero";

declare namespace csd  =  "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;


let $mhero_doc := /.
let $mhero := $careServicesRequest/@resource
let $mhero := $careServicesRequest/documents/mhero/@resource


for $doc  in $careServicesRequest/documents/document
let $name := $doc/@resource
let $src_doc :=
  if (not ($name  = '')) 
  then if (not ($name = $mhero)) then csd_dm:open_document( $name) else ()
  else $doc
return mhero:merge_into($mhero_doc, $src_doc) 

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-fhir:fhir_fac_by_organizational_hierarchy_value_set"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-fhir:fhir_fac_by_organizational_hierarchy_value_set</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Provider XML representation of organizational-facility hierarchy a FHIR value set resource.  

  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csr_proc = "https://github.com/openhie/openinfoman/csr_proc";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace functx = 'http://www.functx.com';

declare namespace csd =  "urn:ihe:iti:csd:2013";
declare namespace fhir = "http://hl7.org/fhir";
declare variable $careServicesRequest as item() external;

let $org_id := $careServicesRequest/fhir:_id/text()
let $search_name := string($careServicesRequest/@function)
let $resource := string($careServicesRequest/@resource)

let $function := csr_proc:get_function_definition($search_name)
let $entity :=   string(($function/csd:extension[@urn='urn:openhie.org:openinfoman:adapter:fhir:valueset' ])[1]/@type)


let $t_base_url := 
  if (exists($careServicesRequest/@xml:base))
  then string($careServicesRequest/@xml:base)
  else string($careServicesRequest/@base_url)


let $base_url :=
  concat($t_base_url, "CSD/csr/", $resource, "/careServicesRequest/" , $search_name , "/adapter/fhir/" , $entity , "/valueset" )

let $expand := 
    (exists($careServicesRequest/fhir:_query)
    and matches(functx:trim(($careServicesRequest/fhir:_query)[1]/text()),'expand','i')
    )
      


let $org := (/csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $org_id])[1]
let $child_orgs := /csd:CSD/csd:organizationDirectory/csd:organization[ ./csd:parent[@entityID = $org_id]]
let $child_facs := /csd:CSD/csd:facilityDirectory/csd:facility[ ./csd:organizations/csd:organization[@entityID = $org_id]]
let $org_name := ($org/csd:primaryName)[1]/text()


return
  if (exists($org) ) 
  then
    &lt;fhir:ValueSet&gt;
      &lt;fhir:text&gt;
	&lt;fhir:status value="generated"/&gt;
	&lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;
	  &lt;h2&gt;Value Set {$org_id}&lt;/h2&gt;
	  &lt;h3&gt;Valueset {$entity}: {$org/csd:primaryName/text()}&lt;/h3&gt;
	  {
	    let $parent := (/csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $org/csd:parent/@entityID ])[1]
	    return 
	       if (exists($parent))
	       then
	         &lt;span class='vs_parent'&gt;
		   &lt;p&gt;Parent Oraganization (Imports this value set): &lt;/p&gt;
		   &lt;a href="{$base_url}?_id={$parent/@entityID}"&gt;{string($parent/@entityID)}&lt;/a&gt;{$parent/csd:primaryName}
		 &lt;/span&gt;
	       else()
	  }
	  {
	    if (count($child_orgs) &gt; 0)
	    then
	      &lt;span class='vs_child'&gt;
	       &lt;p&gt;
  	         Child Organizatons (Imported Value Sets):
	       &lt;/p&gt;
	       &lt;ul&gt;
	         {
		   for $child_org in $child_orgs
		   return &lt;li&gt;&lt;a href="{$base_url}?_id={$child_org/@entityID}"&gt;{string($child_org/@entityID)}&lt;/a&gt;{$child_org/csd:primaryName}&lt;/li&gt;
		 }
	       &lt;/ul&gt;
	      &lt;/span&gt;
	    else ()
	    
	  }
	  {
	    if (count($child_facs) &gt; 0)
	    then 
	      &lt;span class='vs_facs'&gt;
	        &lt;p&gt;
	          Facility codes directly defined by this code set:
		&lt;/p&gt;
	        &lt;ul&gt;
		  {
		     for $child_fac in $child_facs
		     return &lt;li&gt;Value: {string($child_fac/@entityID)} is {$child_fac/csd:primaryName/text()} &lt;/li&gt;
		  }
		&lt;/ul&gt;
	      &lt;/span&gt;
	    else ()

	  }
	&lt;/div&gt;
      &lt;/fhir:text&gt;
      &lt;fhir:identifier value="{$base_url}?_id={$org_id}"/&gt;
      &lt;fhir:version value="0"/&gt;
      &lt;fhir:name&gt;Organization: {$org_name}&lt;/fhir:name&gt;
      &lt;fhir:status value="active"/&gt;      
      &lt;fhir:date&gt;{string($org/csd:record/@lastModified)}&lt;/fhir:date&gt;
      &lt;fhir:define&gt;

        &lt;fhir:system value="{$base_url}?_id={$org_id}"/&gt;
        &lt;fhir:version value="0"/&gt;
	&lt;fhir:caseSensitive value="true"/&gt;

	{
	  for $child_fac in $child_facs
	  let $fac_name := ($child_fac/csd:primaryName[1])/text()
	  let $definition := out:format("%s in %s", $fac_name,$org_name)
	  let $value := string($child_fac/@entityID)
	  where (not (functx:all-whitespace($value)) and not (functx:all-whitespace($fac_name)))
	  return 
	    &lt;fhir:concept&gt;
	      &lt;fhir:code value="{$value}"/&gt;
	      &lt;fhir:display value="{$fac_name}"/&gt;
	      &lt;fhir:definition value="{$definition}"/&gt;
	    &lt;/fhir:concept&gt;
	}
      &lt;/fhir:define&gt;
      {
	if(not($expand) ) 
	then
  	  &lt;fhir:compose&gt;
            {
	      for $child_org in $child_orgs
	      let $child_id := string($child_org/@entityID)
	      where not (functx:all-whitespace($child_id))
	      return &lt;fhir:import value="{$base_url}?_id={$child_id}"/&gt;
	    }
	  &lt;/fhir:compose&gt;    
	 else  ()

        }
    &lt;/fhir:ValueSet&gt;
  else $careServicesRequest</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-fhir:fhir_location_read"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-fhir:fhir_location_read</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Provider XML representation of a faciltiy as a FHIR location resource.  

  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csr_proc = "https://github.com/openhie/openinfoman/csr_proc";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace fadpt = "https://github.com/openhie/openinfoman/adapter/fhir";
import module namespace functx = 'http://www.functx.com';

declare namespace csd =  "urn:ihe:iti:csd:2013";
declare namespace fhir = "http://hl7.org/fhir";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
 
let $search_name := "urn:ihe:iti:csd:2014:stored-function:facility-search"

let $careServicesSubRequest :=  
  &lt;csd:careServicesRequest&gt;
    &lt;csd:function urn="{$search_name}" resource="{$careServicesRequest/@resource}" base_url="{$careServicesRequest/@base_url}"&gt;
      &lt;csd:requestParams&gt;
         {
	  let $id := $careServicesRequest/fhir:_id/text()
	  return if (functx:all-whitespace($id)) then () else &lt;csd:id entityID="{$id}"/&gt;
	 }
         {
	  let $cn := $careServicesRequest/fhir:name/text()
	  return if (functx:all-whitespace($cn)) then () else  &lt;csd:primaryName&gt;{$cn}&lt;/csd:primaryName&gt; 
	 }
	 {
	  let $org := string($careServicesRequest/fhir:manaingOrganization/@value)
	  return if (functx:all-whitespace($org)) then () else &lt;csd:organizations&gt;&lt;csd:organization&gt;{$org}&lt;/csd:organization&gt;&lt;/csd:organizations&gt; 
	 }

         {
	  let $t_start := $careServicesRequest/page/text()
	  return if (functx:is-a-number($t_start))
	    then
	      let $start := max((xs:int($t_start),1))
	      let $t_count := $careServicesRequest/fhir:_count/text()
	      let $count := if(functx:is-a-number($t_count)) then  max((xs:int($t_count),1)) else 50
	      let $startIndex := ($start - 1)*$count + 1
	      return &lt;csd:start&gt;{$startIndex}&lt;/csd:start&gt;
	    else () 
	 }
	 {
	   let $count := $careServicesRequest/fhir:_count/text()
	   return 
	      if(functx:is-a-number($count)) 
	      then  &lt;csd:max&gt;{max((xs:int($count),1))} &lt;/csd:max&gt;
	      else ()
	 }
	 {
	  let $since := $careServicesRequest/fhir:_since/text()
	  return if (functx:all-whitespace($since)) then () else &lt;csd:record updated="{$since}"/&gt; 
	 }
      &lt;/csd:requestParams&gt;
    &lt;/csd:function&gt;
  &lt;/csd:careServicesRequest&gt;

 
let $contents := csr_proc:process_CSR_stored_results( /. , $careServicesSubRequest)

   (:note this is a CSD:csd element, not a document :)
return $contents/csd:facilityDirectory/csd:facility




</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-fhir:fhir_organization_read"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-fhir:fhir_organization_read</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Provider XML representation of a organization as a FHIR organization resource.  

  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csr_proc = "https://github.com/openhie/openinfoman/csr_proc";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace fadpt = "https://github.com/openhie/openinfoman/adapter/fhir";
import module namespace functx = 'http://www.functx.com';

declare namespace csd =  "urn:ihe:iti:csd:2013";
declare namespace fhir = "http://hl7.org/fhir";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
 
let $search_name := "urn:ihe:iti:csd:2014:stored-function:organization-search"

let $careServicesSubRequest :=  
  &lt;csd:careServicesRequest&gt;
    &lt;csd:function urn="{$search_name}" resource="{$careServicesRequest/@resource}" base_url="{$careServicesRequest/@base_url}"&gt;
      &lt;csd:requestParams&gt;
         {
	  let $id := $careServicesRequest/fhir:_id/text()
	  return if (functx:all-whitespace($id)) then () else &lt;csd:id entityID="{$id}"/&gt;
	 }
         {
	  let $cn := $careServicesRequest/fhir:name/text()
	  return if (functx:all-whitespace($cn)) then () else &lt;csd:primaryName&gt;{$cn}&lt;/csd:primaryName&gt; 
	 }
	 {
	  let $org := string($careServicesRequest/fhir:partOf/@value)
	  return if (functx:all-whitespace($org)) then () else  &lt;csd:parent&gt;{$org}&lt;/csd:parent&gt; 
	 }

         {
	  let $t_start := $careServicesRequest/page/text()
	  return if (functx:is-a-number($t_start))
	    then
	      let $start := max((xs:int($t_start),1))
	      let $t_count := $careServicesRequest/fhir:_count/text()
	      let $count := if(functx:is-a-number($t_count)) then  max((xs:int($t_count),1)) else 50
	      let $startIndex := ($start - 1)*$count + 1
	      return &lt;csd:start&gt;{$startIndex}&lt;/csd:start&gt;
	    else () 
	 }
         {
	   let $count := $careServicesRequest/fhir:_count/text()
	   return 
	      if(functx:is-a-number($count)) 
	      then &lt;csd:max&gt;{max(($count,1))} &lt;/csd:max&gt;
	      else ()
	 }
	 {
	  let $since := $careServicesRequest/fhir:_since/text()
	  return if ($since) then &lt;csd:record updated="{$since}"/&gt; else () 
	 }
      &lt;/csd:requestParams&gt;
    &lt;/csd:function&gt;
  &lt;/csd:careServicesRequest&gt;

 
let $contents := csr_proc:process_CSR_stored_results( /. , $careServicesSubRequest)

   (:note this is a CSD:csd element, not a document :)
return $contents/csd:organizationDirectory/csd:organization




</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-fhir:fhir_practitioner_read"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-fhir:fhir_practitioner_read</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Provider XML representation of a provider as a FHIR practitioner resource.  

  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csr_proc = "https://github.com/openhie/openinfoman/csr_proc";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace fadpt = "https://github.com/openhie/openinfoman/adapter/fhir";
import module namespace functx = 'http://www.functx.com';

declare namespace csd =  "urn:ihe:iti:csd:2013";
declare namespace fhir = "http://hl7.org/fhir";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
 
let $search_name := "urn:ihe:iti:csd:2014:stored-function:provider-search"

let $careServicesSubRequest :=  
  &lt;csd:careServicesRequest&gt;
    &lt;csd:function urn="{$search_name}" resource="{$careServicesRequest/@resource}" base_url="{$careServicesRequest/@base_url}"&gt;
      &lt;csd:requestParams&gt;
         {
	  let $id := $careServicesRequest/fhir:_id/text()
	  return if (functx:all-whitespace($id)) then () else &lt;csd:id entityID="{$id}"/&gt;
	 }
         {
	  let $cn := $careServicesRequest/fhir:name/fhir:text/text()
	  return if (functx:all-whitespace($cn)) then () else &lt;csd:commonName&gt;{$cn}&lt;/csd:commonName&gt;
	 }
	 {
	  let $org := string($careServicesRequest/fhir:organization/@value)
	  return if (functx:all-whitespace($org)) then () else  &lt;csd:organizations&gt;&lt;csd:organization&gt;{$org}&lt;/csd:organization&gt;&lt;/csd:organizations&gt; 
	 }

	 {
	  let $loc := string($careServicesRequest/fhir:location/@value)
	  return if (functx:all-whitespace($loc)) then () else &lt;csd:facilities&gt;&lt;csd:facility&gt;{$loc}&lt;/csd:facility&gt;&lt;/csd:facilities&gt; 
	 }

         {
	  let $t_start := $careServicesRequest/page/text()
	  return if (functx:is-a-number($t_start))
	    then
	      let $start := max((xs:int($t_start),1))
	      let $t_count := $careServicesRequest/fhir:_count/text()
	      let $count := if(functx:is-a-number($t_count)) then  max((xs:int($t_count),1)) else 50
	      let $startIndex := ($start - 1)*$count + 1
	      return &lt;csd:start&gt;{xs:string($startIndex)}&lt;/csd:start&gt;
	    else () 
	 }
         {
	   let $count := $careServicesRequest/fhir:_count/text()
	   return 
	      if(functx:is-a-number($count)) 
	      then &lt;csd:max&gt;{max(($count,1))} &lt;/csd:max&gt;
	      else ()
	 }
	 {
	  let $since := $careServicesRequest/fhir:_since/text()
	  return if (functx:all-whitespace($since)) then () else &lt;csd:record updated="{$since}"/&gt; 
	 }
      &lt;/csd:requestParams&gt;
    &lt;/csd:function&gt;
  &lt;/csd:careServicesRequest&gt;

 
let $contents := csr_proc:process_CSR_stored_results( /. , $careServicesSubRequest)

   (:note this is a CSD:csd element, not a document :)
return $contents/csd:providerDirectory/csd:provider




</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rapidpro:select_hfr_facility"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        application/json<br/>
	URN: urn:openhie.org:openinfoman-rapidpro:select_hfr_facility</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Creates selection menu of all the CSD organizations with a specified parent.  Designed as part of heierarchical organization selection menus in RapidPro webhooks.
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace functx = "http://www.functx.com";
declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

let $t_top_orgid  :=  $careServicesRequest/query[@name = 'orgid']/text()
let $top_org :=  (/csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $t_top_orgid])[1]

let $selected_text := $careServicesRequest/query[@name = 'input']/text()

let $selected_index := if ($selected_text castable as xs:integer) then xs:integer($selected_text) else -1

let $selected :=
  if ($selected_index = 0)
  then
    /csd:CSD/csd:organizationDirectory/csd:organization[
      @entityID = /csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $top_org/@entityID]/csd:parent/@entityID
    ]
  else if ($selected_index &gt; 0)
  then
    let $select_orgs := 
      if (exists($top_org))
      then /csd:CSD/csd:organizationDirectory/csd:organization[./csd:parent/@entityID = $top_org/@entityID]
      else /csd:CSD/csd:organizationDirectory/csd:organization[count(./csd:parent[@entityID]) = 0]
    return ($select_orgs)[$selected_index]
  else ()

    
let $orgs := 
  if (exists($selected) and  local-name($selected ) = 'organization')
  then /csd:CSD/csd:organizationDirectory/csd:organization[./csd:parent/@entityID = $selected/@entityID]
  else /csd:CSD/csd:organizationDirectory/csd:organization[count(./csd:parent[@entityID]) = 0]

let $output := 
  if ( $selected[./csd:codedType/@code=7])
  then
    &lt;json type='object'&gt;
      &lt;menutext&gt;Facility Selected&lt;/menutext&gt;
      &lt;facility&gt;{string($selected/@entityID)}&lt;/facility&gt;
      &lt;facilityname&gt;{$selected/csd:primaryName/text()}&lt;/facilityname&gt;
      &lt;orgcode&gt;{string($selected/csd:otherID/@code)}&lt;/orgcode&gt;
    &lt;/json&gt;
  else  if ( local-name($selected ) = 'organization'  or not(exists($selected)))
  then
    &lt;json type='object'&gt;
      &lt;menutext &gt;
 	{ if (exists($selected)) then concat("In ", $selected/csd:primaryName/text(), ". ")  else () }
	{
	  let $parent := (/csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $selected/csd:parent/@entityID])[1]/csd:primaryName/text()
	  return
	    if ($parent)
	    then concat("O) Up to ", $parent, " ") 
	    else ()
        }
	{ for $ent at $pos in ($orgs)  return concat( $pos, ") ", $ent/csd:primaryName/text())    }
      &lt;/menutext&gt;
      &lt;orgid&gt;{if (exists($selected)) then string($selected/@entityID) else ()}&lt;/orgid&gt;
      &lt;orgcode&gt;{string($selected/csd:otherID/@code)}&lt;/orgcode&gt;
      &lt;facility/&gt;
      &lt;facilityname/&gt;      
    &lt;/json&gt;
   else &lt;json type='object'/&gt;

(:return $output :)
return json:serialize($output,map{'format':'direct'})
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rapidpro:select_village"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        application/json<br/>
	URN: urn:openhie.org:openinfoman-rapidpro:select_village</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Creates selection menu of all the CSD organizations and faciltiies with a specified parent.  Designed as part of heierarchical facility selection menus in RapidPro webhooks.
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace functx = "http://www.functx.com";
declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

let $t_top_orgid  :=  $careServicesRequest/query[@name = 'orgid']/text()
let $top_org :=  (/csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $t_top_orgid])[1]



let $selected_text := $careServicesRequest/query[@name = 'input']/text()
(:
let $selections := $careServicesRequest/values/item[./pair[@name = 'label' and ./text() = 'facilityselection']]
let $selected_text := 
  if (count($selections) &gt; 0)
  then
    let $max_time := max(for $time in $selections/pair[@name='time'] return xs:dateTime($time))
    return $selections[./pair[@name = 'time'] = $max_time]/pair[@name='text']/text()
   else ()
:)

let $selected_index := if ($selected_text castable as xs:integer) then xs:integer($selected_text) else -1


let $selected :=
  if ($selected_index = 0)
  then
    /csd:CSD/csd:organizationDirectory/csd:organization[
      @entityID = /csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $top_org/@entityID]/csd:parent/@entityID
    ]
  else if ($selected_index &gt; 0)
  then
    let $select_orgs := 
      if (exists($top_org))
      then /csd:CSD/csd:organizationDirectory/csd:organization[./csd:parent/@entityID = $top_org/@entityID]
      else /csd:CSD/csd:organizationDirectory/csd:organization[count(./csd:parent[@entityID]) = 0]
	
    let $select_facs := 
      if (exists($top_org))
      then /csd:CSD/csd:facilityDirectory/csd:facility[./csd:organizations/csd:organization[@entityID = $top_org/@entityID]]
      else ()
    return ($select_orgs,$select_facs)[ $selected_index]
  else ()

    
let $orgs := 
  if (exists($selected) and  local-name($selected ) = 'organization')
  then /csd:CSD/csd:organizationDirectory/csd:organization[./csd:parent/@entityID = $selected/@entityID]
  else /csd:CSD/csd:organizationDirectory/csd:organization[count(./csd:parent[@entityID]) = 0]
	
let $facs := 
  if (exists($selected) and  local-name($selected ) = 'organization')
  then /csd:CSD/csd:facilityDirectory/csd:facility[./csd:organizations/csd:organization[@entityID = $selected/@entityID]]
  else ()



let $output := 
  if ( local-name($selected ) = 'facility')
  then
    &lt;json type='object'&gt;
      &lt;menutext&gt;You already selected a facility.  You shouldn't see this message&lt;/menutext&gt;
      &lt;facility&gt;{string($selected/@entityID)}&lt;/facility&gt;
      &lt;facilityname&gt;{$selected/csd:primaryName/text()}&lt;/facilityname&gt;
    &lt;/json&gt;
  else  if ( local-name($selected ) = 'organization'  or not(exists($selected)))
  then
    &lt;json type='object'&gt;
      &lt;menutext &gt;
 	{ if (exists($selected)) then concat("In ", $selected/csd:primaryName/text(), ". ")  else () }
	{
	  let $parent := (/csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $selected/csd:parent/@entityID])[1]/csd:primaryName/text()
	  return
	    if ($parent)
	    then concat("O) Up to ", $parent, " ") 
	    else ()
        }
	{ for $ent at $pos in ($orgs,$facs)  return concat( $pos, ") ", $ent/csd:primaryName/text())    }
      &lt;/menutext&gt;
      &lt;orgid&gt;{if (exists($selected)) then string($selected/@entityID) else ()}&lt;/orgid&gt;
      &lt;facility/&gt;
      &lt;facilityname/&gt;      
    &lt;/json&gt;
   else &lt;json type='object'/&gt;

(:return $output :)
return json:serialize($output,map{'format':'direct'})</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-tz:hfr_facilities_to_csd"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-tz:hfr_facilities_to_csd</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Updates the CSD document by an import from Health Facility Registry export of the Organizational hierarchy
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace dxf2csd = "http://dhis2.org/csd/dxf/2.0";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace functx = "http://www.functx.com";

declare namespace csd = "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;

let $doc_name := string($careServicesRequest/@resource)
let $doc := csd_dm:open_document($csd_webconf:db,$doc_name)
let $org_dir := $doc/csd:CSD/csd:organizationDirectory

let $oid := $careServicesRequest/oid
let $csv_src := $careServicesRequest/csv  
let $csv :=    csv:parse($csv_src, map{ 'header': true()})/csv/record



let $namespace_uuid := "7ee93e32-78da-4913-82f8-49eb0a618cfc"

let $generate_UUID_v3 := function($name) {
  concat('urn:uuid:' , dxf2csd:generate_UUID_v3($name,$namespace_uuid))
}

let $zone_csd :=
for $zone_record in distinct-values($csv/Zone)
 let $now := current-dateTime()
 let $zone_urn := $generate_UUID_v3(concat('zone:',$zone_record))
  return
   &lt;csd:organization entityID="{$zone_urn}"&gt;
     &lt;csd:codedType code="1" codingScheme="{$oid}"/&gt;
     &lt;csd:primaryName&gt;{$zone_record}&lt;/csd:primaryName&gt;
     &lt;csd:record
       created="{$now}"
       updated="{$now}"
       sourceDirectory="http://hfrportal.ehealth.go.tz"/&gt;
   &lt;/csd:organization&gt;

let $region_csd :=
for $region_record in distinct-values($csv/Region)
 let $now := current-dateTime()
 let $region_urn := $generate_UUID_v3(concat('region:',$region_record))
 let $parent_urns :=
 for $record in $csv  
  let $zone := $record/Zone
  let $region := $record/Region
  return if($region_record=$region)
   then $generate_UUID_v3(concat('zone:',$zone))
   else ()
 return
   &lt;csd:organization entityID="{$region_urn}"&gt;
     &lt;csd:codedType code="2" codingScheme="{$oid}"/&gt;
     &lt;csd:primaryName&gt;{$region_record}&lt;/csd:primaryName&gt;
     &lt;csd:record
       created="{$now}"
       updated="{$now}"
       sourceDirectory="http://hfrportal.ehealth.go.tz"/&gt;
     &lt;csd:parent entityID="{$parent_urns[last()]}"/&gt;
   &lt;/csd:organization&gt;

let $district_csd :=
for $district_record in distinct-values($csv/District)
 let $now := current-dateTime()
 let $district_urn := $generate_UUID_v3(concat('district:',$district_record))
 let $parent_urns :=
 for $record in $csv
  let $region := $record/Region
  let $district := $record/District
  return if($district_record=$district)
   then $generate_UUID_v3(concat('region:',$region))
   else ()
 return
   &lt;csd:organization entityID="{$district_urn}"&gt;
     &lt;csd:codedType code="3" codingScheme="{$oid}"/&gt;
     &lt;csd:primaryName&gt;{$district_record}&lt;/csd:primaryName&gt;
     &lt;csd:record
       created="{$now}"
       updated="{$now}"
       sourceDirectory="http://hfrportal.ehealth.go.tz"/&gt;
     &lt;csd:parent entityID="{$parent_urns[last()]}"/&gt;
   &lt;/csd:organization&gt;

let $council_csd :=
for $council_record in distinct-values($csv/Council)
 let $now := current-dateTime()
 let $council_urn := $generate_UUID_v3(concat('council:',$council_record))
 let $parent_urns :=
 for $record in $csv
  let $district := $record/District
  let $council := $record/Council
  return if($council_record=$council)
   then $generate_UUID_v3(concat('district:',$district))
   else ()
 return
   &lt;csd:organization entityID="{$council_urn}"&gt;
     &lt;csd:codedType code="4" codingScheme="{$oid}"/&gt;
     &lt;csd:primaryName&gt;{$council_record}&lt;/csd:primaryName&gt;
     &lt;csd:record
       created="{$now}"
       updated="{$now}"
       sourceDirectory="http://hfrportal.ehealth.go.tz"/&gt;
     &lt;csd:parent entityID="{$parent_urns[last()]}"/&gt;
   &lt;/csd:organization&gt;

let $ward_csd :=
for $ward_record in distinct-values($csv/Ward)
 let $now := current-dateTime()
 let $ward_urn := $generate_UUID_v3(concat('ward:',$ward_record))
 let $parent_urns :=
 for $record in $csv
  let $council := $record/Council
  let $ward := $record/Ward
  return if($ward_record=$ward)
   then $generate_UUID_v3(concat('council:',$council))
   else ()
 return if (not (contains($ward_record,"Not set"))) then
   &lt;csd:organization entityID="{$ward_urn}"&gt;
     &lt;csd:codedType code="5" codingScheme="{$oid}"/&gt;
     &lt;csd:primaryName&gt;{$ward_record}&lt;/csd:primaryName&gt;
     &lt;csd:record
       created="{$now}"
       updated="{$now}"
       sourceDirectory="http://hfrportal.ehealth.go.tz"/&gt;
     &lt;csd:parent entityID="{$parent_urns[last()]}"/&gt;
   &lt;/csd:organization&gt;
   else ()

let $village_csd :=
for $village_record in distinct-values($csv/VillageStreet)
 let $now := current-dateTime()
 let $village_urn := $generate_UUID_v3(concat('village:',$village_record))
 let $parent_urns :=
 for $record in $csv
  let $ward := if ((contains($record/Ward,"Not set"))) then $record/Council else($record/Ward)
  let $village := $record/VillageStreet
  return if($village_record=$village)
   then $generate_UUID_v3(concat('ward:',$ward))
   else ()
 return if (not (contains($village_record,"Not set"))) then
   &lt;csd:organization entityID="{$village_urn}"&gt;
     &lt;csd:codedType code="6" codingScheme="{$oid}"/&gt;
     &lt;csd:primaryName&gt;{$village_record}&lt;/csd:primaryName&gt;
     &lt;csd:record
       created="{$now}"
       updated="{$now}"
       sourceDirectory="http://hfrportal.ehealth.go.tz"/&gt;
     &lt;csd:parent entityID="{$parent_urns[last()]}"/&gt;
   &lt;/csd:organization&gt;
   else ()

let $facility_csd :=
for $record in $csv
 let $facNum := $record/FacilityNumber
 let $facName  := $record/FacilityName
 let $now := current-dateTime()
 let $facility_urn := $generate_UUID_v3(concat('facility:',$facNum))
 let $parent := if ((contains($record/VillageStreet,"Not set"))) then 
                     (if ((contains($record/Ward,"Not set"))) then $record/Council else $record/Ward) 
                     else($record/VillageStreet)
 let $parent_string := if ((contains($record/VillageStreet,"Not set"))) then
                     (if ((contains($record/Ward,"Not set"))) then "council:" else "ward:")
                     else("village:")
 let $parent_urn := $generate_UUID_v3(concat($parent_string,$parent))
 return if (not (contains($facName,"Not set"))) then
   &lt;csd:organization entityID="{$facility_urn}"&gt;
     &lt;csd:otherID assigningAuthorityName='health_facility_registry' code="{$facNum}"/&gt;
     &lt;csd:codedType code="7" codingScheme="{$oid}"/&gt;
     &lt;csd:primaryName&gt;{$facName/text()}&lt;/csd:primaryName&gt;
     &lt;csd:record
       created="{$now}"
       updated="{$now}"
       sourceDirectory="http://hfrportal.ehealth.go.tz"/&gt;
     &lt;csd:parent entityID="{$parent_urn}"/&gt;
   &lt;/csd:organization&gt;
   else ()

let $csd :=
  &lt;csd:CSD&gt;
    &lt;csd:organizationDirectory&gt;
      {($zone_csd,$region_csd,$district_csd,$council_csd,$ward_csd,$village_csd,$facility_csd)}
    &lt;/csd:organizationDirectory&gt;
    &lt;csd:serviceDirectory/&gt;
    &lt;csd:facilityDirectory/&gt;
    &lt;csd:providerDirectory/&gt;
  &lt;/csd:CSD&gt;

return  csd_dm:add($csd_webconf:db,$csd,$doc_name)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-tz:rm_org_hierarchy_to_csd"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-tz:rm_org_hierarchy_to_csd</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Updates the CSD document by an import from Resource Map's export of the Organizational hierarchy
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace dxf2csd = "http://dhis2.org/csd/dxf/2.0";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace functx = "http://www.functx.com";

declare namespace csd = "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;


let $doc_name := string($careServicesRequest/@resource)
let $doc := csd_dm:open_document($doc_name)


let $oid := $careServicesRequest/oid
let $csv_src := $careServicesRequest/csv  
let $csv :=    csv:parse($csv_src, map{ 'header': true()})/csv/record



let $namespace_uuid := "7ee93e32-78da-4913-82f8-49eb0a618cfc"

let $generate_UUID_v3 := function($name) {
  concat('urn:uuid:' , dxf2csd:generate_UUID_v3($name,$namespace_uuid))
}



let $csd_orgs := 
  for $record in $csv
   let $village := $record/VillMtaa
   let $ward  := $record/Ward
   let $council  := $record/Council
   let $district  := $record/District
   let $region  := $record/Region
   let $zone  := $record/Zone 
   let $country  := $record/Country
   let $name  := $record/Name
   let $id  := $record/NodeID
   let $urn := $generate_UUID_v3(concat('organization:',$id))
   let $level := 
      if (not(functx:all-whitespace($village)))
      then  '6'
      else if (not(functx:all-whitespace($ward)))
      then  '5'
      else if (not(functx:all-whitespace($council)))
      then  '4'
      else if (not(functx:all-whitespace($district)))
      then  '3'
      else if (not(functx:all-whitespace($region)))
      then  '2'
      else if (not(functx:all-whitespace($zone)))
      then  '1'
      else if (not(functx:all-whitespace($country)))
      then  '0'
      else ()
   let $pid := 
      if ( not(functx:all-whitespace($village)) )
      then  $csv[./Country = $country and ./Zone = $zone and ./Region = $region and ./District = $district and ./Council = $council and ./Ward = $ward and functx:all-whitespace(./VillMtaa)]/NodeID/text()
      else if (not(functx:all-whitespace($ward)))
      then  $csv[./Country = $country and ./Zone = $zone and ./Region = $region and ./District = $district and ./Council = $council and functx:all-whitespace(./VillMtaa) and functx:all-whitespace(./Ward)]/NodeID/text()
      else if (not(functx:all-whitespace($council)))
      then  $csv[./Country = $country and ./Zone = $zone and ./Region = $region and ./District = $district and functx:all-whitespace(./Council) and functx:all-whitespace(./VillMtaa) and functx:all-whitespace(./Ward) ]/NodeID/text()
      else if (not(functx:all-whitespace($district)))
      then  $csv[./Country = $country and ./Zone = $zone and ./Region = $region and functx:all-whitespace(./District) and functx:all-whitespace(./Council) and functx:all-whitespace(./VillMtaa) and functx:all-whitespace(./Ward) ]/NodeID/text()
      else if (not(functx:all-whitespace($region)))
      then  $csv[./Country = $country and ./Zone = $zone and functx:all-whitespace(./Region) and functx:all-whitespace(./District) and functx:all-whitespace(./Council) and functx:all-whitespace(./VillMtaa) and functx:all-whitespace(./Ward)]/NodeID/text()
      else if (not(functx:all-whitespace($zone)))
      then  $csv[./Country = $country  and functx:all-whitespace(./Zone) and functx:all-whitespace(./Region) and functx:all-whitespace(./District) and functx:all-whitespace(./Council) and functx:all-whitespace(./VillMtaa) and functx:all-whitespace(./Ward)]/NodeID/text()
      else ()
   let $parent := 
     if ($pid)
     then
       let $parent_urn := $generate_UUID_v3(concat('organization:',$pid))
       return &lt;csd:parent entityID="{$parent_urn}"/&gt;
     else ()
   return 
     if (($name) and ($level)  and ($urn) )
     then 
       &lt;csd:organization entityID="{$urn}"&gt;
	 &lt;csd:otherID assigningAuthorityName='resource_map_tanzania' code="{$id}"/&gt;
	 &lt;csd:codedType code="{$level}" codingScheme="{$oid}"/&gt;
	 &lt;csd:primaryName&gt;{$name/text()}&lt;/csd:primaryName&gt;
	 {$parent}
       &lt;/csd:organization&gt;
     else ($record)  (:no name or id or type :)



let $csd :=
  &lt;csd:CSD&gt;
    &lt;csd:organizationDirectory&gt;
      {$csd_orgs}
    &lt;/csd:organizationDirectory&gt;
    &lt;csd:serviceDirectory/&gt;
    &lt;csd:facilityDirectory/&gt;  
    &lt;csd:providerDirectory/&gt;
  &lt;/csd:CSD&gt;

return  csd_dm:add($csd,$doc_name)


</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-namibia:stored-function:staff_list"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-namibia:stored-function:staff_list</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Create a staff list for Namibia by facility
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>declare namespace csd = 'urn:ihe:iti:csd:2013';
declare variable $careServicesRequest as item() external;

&lt;html&gt;
 &lt;body&gt;
  &lt;ul&gt;
   &lt;li&gt;You have {count(/csd:CSD/csd:providerDirectory/*)} providers.&lt;/li&gt;
   &lt;li&gt;You have {count(/csd:CSD/csd:facilityDirectory/*)} facilities.&lt;/li&gt;
   &lt;li&gt;You have {count(/csd:CSD/csd:organizationDirectory/*)} organizations.&lt;/li&gt;
   &lt;li&gt;You have {count(/csd:CSD/csd:serviceDirectory/*)} services.&lt;/li&gt;
  &lt;/ul&gt;
  &lt;table&gt;
  {(: Looping through the Facility directory :)
    for $facility in /csd:CSD/csd:facilityDirectory/*
      let $facilityName:=$facility/csd:primaryName
      order by $facilityName
      return
	  &lt;span&gt;
	  &lt;h2&gt;Facility List&lt;/h2&gt;
      &lt;tr&gt;
        &lt;td&gt; {string($facility/csd:record/@sourceDirectory)}&lt;/td&gt;
        &lt;td&gt;{ $facilityName }&lt;/td&gt; 
        &lt;td&gt;{ string($facility/@urn)}&lt;/td&gt;	 
      &lt;/tr&gt;
	  &lt;/span&gt;
	  &lt;span&gt;
	  &lt;h2&gt;Empoloyee's List&lt;/h2&gt;
	  &lt;h3&gt;{$facilityName}&lt;/h3&gt;
	     &lt;table&gt; 
		 {
           for $provider in /csd:CSD/csd:providerDirectory/*
             let $EmpoloyeeName:= $provider/demogrpahic/csd:name[1]/csd:forename
             let $pfacility:=$provider/csd:facilities/facility/@entityID
			 let $gender_code:= $provider/demogrpahic/csd:gender
			 let $DOB:= $provider/demogrpahic/csd:dateOfBirth
			 let $email:= string($provider/demogrpahic/csd:contactPoint/@EMAIL)
             where $facility/@urn = $pfacility
             order by $EmpoloyeeName
			 return
			 &lt;tr&gt;
			  &lt;td&gt;{$EmpoloyeeName}&lt;/td&gt;
			  &lt;td&gt;{$gender_code}&lt;/td&gt;
			  &lt;td&gt;{$DOB}&lt;/td&gt;
			  &lt;td&gt;{$email}&lt;/td&gt;
			 &lt;/tr&gt;
			 }
		   &lt;/table&gt;
	  &lt;/span&gt;
  
  }
  &lt;/table&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-whomds:stored-function:mds_completeness_healthworker"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-whomds:stored-function:mds_completeness_healthworker</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">Health Worker WHO MDS completeness report</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>declare   namespace   csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;
let $doc := /.


let $xpaths := map{
    "Posting/Facility": "csd:facilities/csd:facility",
    "ID Number": "csd:otherID/@code",
    "ID Date of Issue":"csd:otherID/@issueDate/text()",
    "ID Date of Expiration":"csd:otherID/@expirationDate/text()",
    "Place of Issue": "csd:otherID/@assigningAuthorityName/text()",
    "First name": "csd:demographic/csd:name/csd:forename/text()",
    "Last name": "csd:demographic/csd:name/csd:surname/text()",
    "Middle name":"csd:demographic/csd:name/csd:otherNames[@type='middle']/text()",
    "Maiden name": "csd:demographic/csd:name/csd:otherNames[@type='maiden']/text()",
    "Other name 1" : "csd:demographic/csd:name/csd:otherNames[@type='other_1']/text()",
    "Other name 2" :"csd:demographic/csd:name/csd:otherNames[@type='other_2']/text()",
    "Other name 3" : "csd:demographic/csd:name/csd:otherNames[@type='other_3']/text()",
    "Place of birth country":"csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='birth']/csd:country/text()",
    "Place of birth town": "csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='birth']/csd:town/text()",
    "Father’s name":"csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='birth']/csd:fatherName/text()",
    "Mother’s name":"csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='birth']/csd:motherName/text()",
    "Photograph" :    "csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds'  and @type='photograph']/csd:image/text()",
    "Date of birth" :  "csd:demographic/csd:dateOfBirth/text()",
    "Sex at birth " : "csd:demographic/csd:gender/text()",
    "Citizenship at birth" : "csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='citizenship']/csd:birth/text()" , 
    "Citizenship at present country of residence":"csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='citizenship']/csd:residence/text()",
    "Ability in written languages":"csd:language[@code]/@written-ability",
    "Ability in spoken languages": "csd:language[@code]/@spoken-ability",
    "Address Country":"csd:demographic/csd:address/csd:addressLine[@component='country']/text()",
    "Address City": "csd:demographic/csd:address/csd:addressLine[@component='city']/text()" ,
    "Street Address": "csd:demographic/csd:address/csd:addressLine[@component='streetAddress']/text()",
    "Address Postal Code" :"csd:demographic/csd:address/csd:addressLine[@component='postalCode']/text()" ,
    "Telephone number" : "csd:demographic/csd:contactPoint/csd:codedType[@code='BP'  and @codingScheme='urn:ihe:iti:csd:2013:contactPoint']/text()",
    "Email address" : "csd:demographic/csd:contactPoint/csd:codedType[@code='EMAIL' and @codingScheme='urn:ihe:iti:csd:2013:contactPoint']/text()",
    "Emergency contact name" : "csd:demographic/csd:contactPoint/csd:codedType[@code='EMERGENCY'  and @codingScheme= 'urn:who.int:hrh:mds']/text()",
    "Professional License and Certification Document Type" : "csd:credential/csd:codedType/@code",
    "Professional License and Certification Document Category" : "csd:credential/csd:codedType/@category",
    "Professional License and Certification Issuing Institution": "csd:credential/csd:issuingAuthority/text()",
    "Professional License and Certification Date of Issue" : "csd:credential/csd:credentialIssueDate/text()",
    "Professional License and Certification Date of Expiration" : "csd:credential/csd:credentialRenewalDate/text()" ,
    "Professional License and Certification Scan/Photograph" :  "csd:credential/csd:extension[@urn ='urn:who.int:hrh:mds' and @type='photograph']/csd:image/text()" ,
    "Employment status" : "csd:record/@status" ,
    "Occupational category" : "csd:codedType/@code" ,
    "Employment title" : "csd:codedType[@code]/text()",
    "Complaints" : "csd:credential/csd:extension[@urn = 'urn:who.int:hrh:mds' and @type='complaints']/@value",
    "Data submission  institution ": "csd:record/@sourceDirectory",
    "Data submission date" : "csd:record/@updated" 
}



let $total := count($doc/csd:CSD/csd:providerDirectory/csd:provider)

let $stats := 
  map:for-each($xpaths, 
    function($label,$xpath) {
      let $matches := 
        for $provider in $doc/csd:CSD/csd:providerDirectory/csd:provider
        let $bindings := map{"provider":$provider}
	let $expr := " declare namespace csd = 'urn:ihe:iti:csd:2013'; declare variable $provider external; $provider/" || $xpath
	let $result := xquery:eval($expr,$bindings) 
	where exists($result)
	return 	$provider
      let $count:=count($matches)
      return &lt;tr count="{$count}" xpath="{$xpath}"&gt;&lt;td&gt;{$label}&lt;/td&gt;&lt;td&gt;{$count}&lt;/td&gt;&lt;td&gt;{if ($total &gt; 0) then floor($count div $total * 100) else "N/A"} %&lt;/td&gt;&lt;/tr&gt;
    })


return 
  &lt;table &gt;
  &lt;tr&gt;&lt;th style='width:33%'&gt;Data Field&lt;/th&gt;&lt;th style='width:33%'&gt;Number of Records&lt;br/&gt;Total of {$total}&lt;/th&gt;&lt;th style='width:33%'&gt;Percentage&lt;/th&gt;&lt;/tr&gt;
   { 
     for $stat in $stats
     order by number($stat/@count) descending
     return $stat
   }
  &lt;/table&gt;
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-whomds:stored-function:mds_completeness_healthworker_csv"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/csv<br/>
	URN: urn:openhie.org:openinfoman-whomds:stored-function:mds_completeness_healthworker_csv</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">Health Worker WHO MDS completeness report as CSV</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>declare   namespace   csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;
let $doc := /.


let $xpaths := map{
    "Posting/Facility": "csd:facilities/csd:facility",
    "ID Number": "csd:otherID/@code",
    "ID Date of Issue":"csd:otherID/@issueDate/text()",
    "ID Date of Expiration":"csd:otherID/@expirationDate/text()",
    "Place of Issue": "csd:otherID/@assigningAuthorityName/text()",
    "First name": "csd:demographic/csd:name/csd:forename/text()",
    "Last name": "csd:demographic/csd:name/csd:surname/text()",
    "Middle name":"csd:demographic/csd:name/csd:otherNames[@type='middle']/text()",
    "Maiden name": "csd:demographic/csd:name/csd:otherNames[@type='maiden']/text()",
    "Other name 1" : "csd:demographic/csd:name/csd:otherNames[@type='other_1']/text()",
    "Other name 2" :"csd:demographic/csd:name/csd:otherNames[@type='other_2']/text()",
    "Other name 3" : "csd:demographic/csd:name/csd:otherNames[@type='other_3']/text()",
    "Place of birth country":"csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='birth']/csd:country/text()",
    "Place of birth town": "csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='birth']/csd:town/text()",
    "Father’s name":"csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='birth']/csd:fatherName/text()",
    "Mother’s name":"csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='birth']/csd:motherName/text()",
    "Photograph" :    "csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds'  and @type='photograph']/csd:image/text()",
    "Date of birth" :  "csd:demographic/csd:dateOfBirth/text()",
    "Sex at birth " : "csd:demographic/csd:gender/text()",
    "Citizenship at birth" : "csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='citizenship']/csd:birth/text()" , 
    "Citizenship at present country of residence":"csd:demographic/csd:extension[@urn='urn:who.int:hrh:mds' and @type='citizenship']/csd:residence/text()",
    "Ability in written languages":"csd:language[@code]/@written-ability",
    "Ability in spoken languages": "csd:language[@code]/@spoken-ability",
    "Address Country":"csd:demographic/csd:address/csd:addressLine[@component='country']/text()",
    "Address City": "csd:demographic/csd:address/csd:addressLine[@component='city']/text()" ,
    "Street Address": "csd:demographic/csd:address/csd:addressLine[@component='streetAddress']/text()",
    "Address Postal Code" :"csd:demographic/csd:address/csd:addressLine[@component='postalCode']/text()" ,
    "Telephone number" : "csd:demographic/csd:contactPoint/csd:codedType[@code='BP'  and @codingScheme='urn:ihe:iti:csd:2013:contactPoint']/text()",
    "Email address" : "csd:demographic/csd:contactPoint/csd:codedType[@code='EMAIL' and @codingScheme='urn:ihe:iti:csd:2013:contactPoint']/text()",
    "Emergency contact name" : "csd:demographic/csd:contactPoint/csd:codedType[@code='EMERGENCY'  and @codingScheme= 'urn:who.int:hrh:mds']/text()",
    "Professional License and Certification Document Type" : "csd:credential/csd:codedType/@code",
    "Professional License and Certification Document Category" : "csd:credential/csd:codedType/@category",
    "Professional License and Certification Issuing Institution": "csd:credential/csd:issuingAuthority/text()",
    "Professional License and Certification Date of Issue" : "csd:credential/csd:credentialIssueDate/text()",
    "Professional License and Certification Date of Expiration" : "csd:credential/csd:credentialRenewalDate/text()" ,
    "Professional License and Certification Scan/Photograph" :  "csd:credential/csd:extension[@urn ='urn:who.int:hrh:mds' and @type='photograph']/csd:image/text()" ,
    "Employment status" : "csd:record/@status" ,
    "Occupational category" : "csd:codedType/@code" ,
    "Employment title" : "csd:codedType[@code]/text()",
    "Complaints" : "csd:credential/csd:extension[@urn = 'urn:who.int:hrh:mds' and @type='complaints']/@value",
    "Data submission  institution ": "csd:record/@sourceDirectory",
    "Data submission date" : "csd:record/@updated" 
}



let $total := count($doc/csd:CSD/csd:providerDirectory/csd:provider)

let $stats := 
  map:for-each($xpaths, 
    function($label,$xpath) {
      let $matches := 
        for $provider in $doc/csd:CSD/csd:providerDirectory/csd:provider
        let $bindings := map{"provider":$provider}
	let $expr := " declare namespace csd = 'urn:ihe:iti:csd:2013'; declare variable $provider external; $provider/" || $xpath
	let $result := xquery:eval($expr,$bindings) 
	where exists($result)
	return 	$provider
      let $count:=count($matches)
      return &lt;record&gt;&lt;label&gt;{$label}&lt;/label&gt;&lt;count&gt;{$count}&lt;/count&gt;&lt;percent&gt;{if ($total &gt; 0) then floor($count div $total * 100) else "N/A"} %&lt;/percent&gt;&lt;/record&gt;
    })


let $csv:=
  &lt;csv &gt;
  &lt;record&gt;&lt;label&gt;Data Field&lt;/label&gt;&lt;count&gt;Number of Records Total of {$total}&lt;/count&gt;&lt;percent&gt;Percentage&lt;/percent&gt;&lt;/record&gt;
   { 
     for $stat in $stats
     order by number($stat/count/text()) descending
     return $stat
   }
  &lt;/csv&gt;

return csv:serialize($csv,map{ 'header': 'no', 'separator': 'tab'  })
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-r:stored-function:duplicate_record_field_metrics"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/html<br/>
	URN: urn:openhie.org:openinfoman-r:stored-function:duplicate_record_field_metrics</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Gets metrics on specified data fields to determine applicability of these fields for deduplication of records.  Output is text representation of result.
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace rscript = "https://github.com/openhie/openinfoman/adapter/r";

declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;


(: 
   The query will be executed against the root element of the CSD document.    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 


rscript:html_result(/.,$careServicesRequest)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-ldif:provider_search"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/plain<br/>
	URN: urn:openhie.org:openinfoman-ldif:provider_search</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Gets LDIF (for LDAP) representaiton of provider search results
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>

(: import the library module for ldif :)
import module namespace ldif = "https://github.com/openhie/openinfoman/adapter/ldif";

(: declare the careServicesRequest vairable as external :)
declare variable $careServicesRequest as item() external;

(: get the ldif data file for entities matching the request :)
ldif:get(/.,$careServicesRequest)

</pre></span>
      </div>
    </div>
    <a id=""/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: </span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Peforms a search request on a provider's common name according to the OpenSearch 1.1 Specification:
      http://www.opensearch.org/Specifications/OpenSearch/1.1
    Returns search results in opensearch feed for a provider by common name including link to free busy information on Zimbra for scheduling information.
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace osf = "https://github.com/openhie/openinfoman/adapter/opensearch";
import module namespace functx = 'http://www.functx.com';

declare namespace csd =  "urn:ihe:iti:csd:2013";
declare namespace rss = "http://backend.userland.com/rss2";
declare namespace atom = "http://www.w3.org/2005/Atom";
declare namespace html = "http://www.w3.org/1999/xhtml";
declare namespace os  = "http://a9.com/-/spec/opensearch/1.1/";


declare variable $careServicesRequest as item() external;



(: 
   The query will be executed against the root element of the CSD document.    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 


(:Get the search terms passed in the request :)
let $search_terms := xs:string($careServicesRequest/os:searchTerms/text())
(:Find the matching providers -- to be customized for your search:)
let $filter:= function($common_name) {
  functx:contains-case-insensitive($common_name,  $search_terms)  
}
let $matched_providers :=  
  if ($search_terms) then
    for $provider in /csd:CSD/csd:providerDirectory/csd:provider
    let $common_names := $provider/csd:demographic/csd:name/csd:commonName
    where  count(filter($common_names,$filter)) &gt; 0
    return $provider  
  else ()

let $html_func := function($provider,$doc_name,$search_name) {
  if (local-name-from-QName(node-name($provider)) = 'provider' and namespace-uri-from-QName(node-name($provider)) = "urn:ihe:iti:csd:2013") then
    let $demo:= $provider/csd:demographic[1]
    let $oid := string($provider/@oid)
    let $adapter_link := concat($careServicesRequest/@base_url,"CSD/adapter/zimbra/" , $search_name, "/" , $doc_name,"/scheduling")
    return 
      &lt;html:li&gt;
	&lt;html:a href="{osf:get_entity_link($provider,$search_name)}"&gt;
	  {$demo/csd:name[1]/csd:surname/text()}, {$demo/csd:name[1]/csd:forename/text()}
	&lt;/html:a&gt;
	&lt;html:a href="{$adapter_link}?oid={$oid}"&gt;Scheduling with Free Busy&lt;/html:a&gt;
	&lt;html:div class='description_html'&gt;{osf:get_provider_desc_html($provider,$doc_name)}&lt;/html:div&gt;
      &lt;/html:li&gt;
   else 
   ()
}



let $processors := map{
  'html' := $html_func
}



(:Produce the feed in the neccesary format :)
return osf:create_feed_from_entities($matched_providers,$careServicesRequest,$processors)



</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rwanda:stored-function:rwanda_lookup_epid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-rwanda:stored-function:rwanda_lookup_epid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">rwanda_lookup_epid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 


let $id_number := ($careServicesRequest/id_number , $careServicesRequest/csd:id_number)[1]
let $authority := ($careServicesRequest/authority , $careServicesRequest/csd:authority)[1]
let $id_type := ($careServicesRequest/id_type, $careServicesRequest/csd:id_type)[1]

let $provider := 
  if (exists($id_number) and exists($id_type) and exists($authority))
  then 
     let $provs :=   /csd:CSD/csd:providerDirectory/csd:provider[./csd:otherID[./@assigningAuthorityName = $authority  and  ./@code = $id_type  and ./text() = $id_number ]]
     return $provs[1]
  else ()

return $provider
</pre></span>
      </div>
    </div>
    <a id="urn:moh.gov.rw:extract_orgunits_rwanda:v2.19"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:moh.gov.rw:extract_orgunits_rwanda:v2.19</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    
    Extracts Organisation Unit hierarchy and Facility/Site list from DATIM (DHIS2) as CSD Organization and Facility entities.   
    Also creates SVS for relevant terminologies (e.g. facility/site type)

    Imports: DHIS2 metadata export of Organsation Units, Organisation Unit Group,  Organisation Unit Group Set, Organization Unit Level from DHIS2 2.19
    
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>declare namespace csd = "urn:ihe:iti:csd:2013"; 

declare namespace svs = "urn:ihe:iti:svs:2008";
declare namespace dxf = "http://dhis2.org/schema/dxf/2.0";
declare namespace adx = "http://www.datim.org/adx:2015";

import module namespace datim = "http://www.datim.org";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace svs_lsvs = "https://github.com/openhie/openinfoman/svs_lsvs";
import module namespace uuid = "https://github.com/openhie/openinfoman-datim/uuid";
import module namespace functx = "http://www.functx.com";

declare variable $careServicesRequest as item() external; 


let $dxf := $careServicesRequest/file
let $datim_oid := $careServicesRequest/oid/text()
let $codelist_prefix := $careServicesRequest/codelist_prefix/text()

let $orgUnits := $dxf/dxf:metaData/dxf:organisationUnits/dxf:organisationUnit
let $orgGroups := $dxf/dxf:metaData/dxf:organisationUnitGroups/dxf:organisationUnitGroup

let $site_codes := ('FACILITY','COUNTRY','OUSCOUNTRIES','COMMUNITIY')   (:Org Unit Groups that can report data and so should have a CSD facilities :)

let $doc_name := string($careServicesRequest/@resource)
let $doc := csd_dm:open_document($csd_webconf:db,$doc_name)
let $org_dir := $doc/csd:CSD/csd:organizationDirectory
let $fac_dir := $doc/csd:CSD/csd:facilityDirectory





let $now := current-dateTime()



let $entities:= 
  for $orgUnit in $orgUnits
  let $level := xs:integer($orgUnit/@level)
  let $id := $orgUnit/@id
  let $code := $orgUnit/@code
  let $uuid := string($orgUnit/@uuid)
  let $displayName:=string($orgUnit/@name)
  let $pid:=string($orgUnit/dxf:parent/@id)
  let $puuid := $orgUnits[@id=$pid]/@uuid
  let $lm := datim:fixup_date($orgUnit/@lastUpdated)
  let $created := datim:fixup_date($orgUnit/@created)
  let $groups := $orgGroups[./dxf:organisationUnits/dxf:organisationUnit[@id = $id]]
  let $group_codes := $groups/@code
  let $facEntityID := concat("urn:uuid:",uuid:generate(concat('facility:',$id),$datim:namespace_uuid))
  let $orgEntityID := concat("urn:uuid:",uuid:generate(concat('organization:',$id),$datim:namespace_uuid))
  let $parentEntityID := concat("urn:uuid:",uuid:generate(concat('organization:',$pid),$datim:namespace_uuid))

  let $fac_entity :=
    if ($group_codes = $site_codes)
    then
      &lt;csd:facility entityID="{$facEntityID}"&gt;
        &lt;csd:otherID assigningAuthorityName="http://www.datim.org/orgUnit" code="id"&gt;{string($id)}&lt;/csd:otherID&gt;
        &lt;csd:otherID assigningAuthorityName="http://www.datim.org/orgUnit" code="code"&gt;{string($code)}&lt;/csd:otherID&gt;
	{
	  if (not(functx:all-whitespace($uuid)))
	  then &lt;csd:otherID assigningAuthorityName="http://www.datim.org/orgUnit" code="uuid"&gt;{string($uuid)}&lt;/csd:otherID&gt;
	  else ()
	}
	&lt;csd:codedType codingScheme="urn:www.datim.org" code="site"/&gt;
	  {
	    for $group_code in $group_codes
	    return &lt;csd:codedType codingScheme="urn:www.datim.org:org-unit-group" code="{$group_code}" /&gt;
	  }
	&lt;csd:primaryName&gt;{$displayName}&lt;/csd:primaryName&gt;
	{datim:get_geocode($doc,$orgUnit)}
	{ 
	  if (not(functx:all-whitespace($puuid))) 
	  then 
            &lt;csd:organizations&gt;
	      &lt;csd:organization entityID="{$parentEntityID}"/&gt;
	    &lt;/csd:organizations&gt;
	  else () 
	}
	&lt;csd:record created="{$created}" updated="{$lm}" status="Active" sourceDirectory="http://www.datim.org"/&gt;
      &lt;/csd:facility&gt;
    else ()
  let $org_entity :=
    &lt;csd:organization entityID="{$orgEntityID}"&gt;
      &lt;csd:otherID assigningAuthorityName="http://www.datim.org/orgUnit" code="id"&gt;{string($id)}&lt;/csd:otherID&gt;
      &lt;csd:otherID assigningAuthorityName="http://www.datim.org/orgUnit" code="code"&gt;{string($code)}&lt;/csd:otherID&gt;
      {
	if (not(functx:all-whitespace($uuid)))
	then &lt;csd:otherID assigningAuthorityName="http://www.datim.org/orgUnit" code="uuid"&gt;{string($uuid)}&lt;/csd:otherID&gt;
	else ()
      }
      &lt;csd:codedType code="{$level}" codingScheme="urn:www.datim.org:org-unit-level"/&gt;
      {
	for $group_code in $group_codes
	return &lt;csd:codedType codingScheme="urn:www.datim.org:org-unit-group" code="{$group_code}" /&gt;
      }
      &lt;csd:primaryName&gt;{$displayName}&lt;/csd:primaryName&gt;
      {datim:get_geocode($doc,$orgUnit) (:Should put in a CP to point geo codes for orgs as service delivery area :)}
      {
	if (not(functx:all-whitespace($puuid))) 
	then 
          &lt;csd:organizations&gt;
	    &lt;csd:organization entityID="{$parentEntityID}"/&gt;
	  &lt;/csd:organizations&gt;
	else () 
      }
      &lt;csd:record created="{$created}" updated="{$lm}" status="Active" sourceDirectory="http://www.datim.org"/&gt;
    &lt;/csd:organization&gt;

  return ($org_entity,$fac_entity)

	

	
let $level_oid := concat($datim_oid,'.2')
let $levels := $dxf/dxf:metaData/dxf:organisationUnitLevels/dxf:organisationUnitLevel
let $level_version := max(for $date in $levels/@lastUpdated return xs:dateTime(datim:fixup_date($date)))
let $svs_levels :=
  &lt;svs:ValueSet  xmlns:svs="urn:ihe:iti:svs:2008" id="{$level_oid}" version="{$level_version}" displayName="Organisation Unit Levels for DATIM"&gt;
    &lt;svs:ConceptList xml:lang="en-US" &gt;
      {
	for $level in $levels
	return &lt;svs:Concept code="{$level/@level}" displayName="{$level/@name}" codeSystem="urn:www.datim.org:org-unit-level" /&gt;
      }
    &lt;/svs:ConceptList&gt;
  &lt;/svs:ValueSet&gt;

let $group_oid := concat($datim_oid,'.3')
let $group_version := max(for $date in $orgGroups/@lastUpdated return xs:dateTime(datim:fixup_date($date)))
let $svs_groups :=
  &lt;svs:ValueSet  xmlns:svs="urn:ihe:iti:svs:2008" id="{$group_oid}" version="{$group_version}" displayName="Organisation Unit Groups for DATIM"&gt;
    &lt;svs:ConceptList xml:lang="en-US" &gt;
      {
	for $group in $orgGroups
	return &lt;svs:Concept code="{$group/@code}" displayName="{$group/@name}" codeSystem="urn:www.datim.org:org-unit-group" /&gt;
      }
    &lt;/svs:ConceptList&gt;
  &lt;/svs:ValueSet&gt;


let $svs_docs := ($svs_levels,$svs_groups)


return (
  for $entity in $entities
  let $id := $entity/@entityID
  return 
    if (local-name($entity) = 'facility')
    then 
      let $existing_fac := $fac_dir/csd:facility[@entityID = $id]
      return
        if (not(exists($existing_fac)))
        then (insert node $entity into $fac_dir)
        else (replace node $existing_fac with $entity)
    else
      let $existing_org := $org_dir/csd:organization[@entityID = $id]
      return
        if (not(exists($existing_org)))
        then (insert node $entity into $org_dir)
        else (replace node $existing_org with $entity)
  ,
  for $svs_doc in $svs_docs return svs_lsvs:insert($csd_webconf:db,$svs_doc) 

)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-opensearch:provider_common_name"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-opensearch:provider_common_name</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Peforms a search request on a provider's common name according to the OpenSearch 1.1 Specification:
      http://www.opensearch.org/Specifications/OpenSearch/1.1
    Returns search results in opensearch feed for a provider by common name
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace osf = "https://github.com/openhie/openinfoman/adapter/opensearch";
import module namespace functx = 'http://www.functx.com';

declare namespace csd =  "urn:ihe:iti:csd:2013";
declare namespace rss = "http://backend.userland.com/rss2";
declare namespace atom = "http://www.w3.org/2005/Atom";
declare namespace html = "http://www.w3.org/1999/xhtml";
declare namespace os  = "http://a9.com/-/spec/opensearch/1.1/";

declare variable $careServicesRequest as item() external;



(: 
   The query will be executed against the root element of the CSD document.    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 


(:Get the search terms passed in the request :)
let $search_terms := xs:string($careServicesRequest/os:searchTerms/text())
(:Find the matching providers -- to be customized for your search:)
let $filter:= function($common_name) {
  functx:contains-case-insensitive($common_name,  $search_terms)  
}
let $matched_providers :=  
  if ($search_terms) then
    for $provider in /csd:CSD/csd:providerDirectory/csd:provider
    let $common_names := $provider/csd:demographic/csd:name/csd:commonName
    where  count(filter($common_names,$filter)) &gt; 0
    return $provider  
  else ()



(:Produce the feed in the neccesary format :)
return osf:create_feed_from_entities($matched_providers,$careServicesRequest)



</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-opensearch:provider_credenital"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-opensearch:provider_credenital</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Peforms a search request on a provider's credential number according to the OpenSearch 1.1 Specification:
      http://www.opensearch.org/Specifications/OpenSearch/1.1
    Returns search results in opensearch feed 
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace osf = "https://github.com/openhie/openinfoman/adapter/opensearch";
import module namespace functx = 'http://www.functx.com';

declare namespace csd = "urn:ihe:iti:csd:2013";
declare namespace rss = "http://backend.userland.com/rss2";
declare namespace atom = "http://www.w3.org/2005/Atom";
declare namespace html = "http://www.w3.org/1999/xhtml";
declare namespace os  = "http://a9.com/-/spec/opensearch/1.1/";
declare variable $careServicesRequest as item() external;


(: 
   The query will be executed against the root element of the CSD document.    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

(:Get the search terms passed in the request :)
let $search_terms := xs:string($careServicesRequest/os:searchTerms/text())
(:Find the matching providers -- to be customized for your search:)
let $filter:= function($credential) {
  functx:contains-case-insensitive($credential,  $search_terms)  
}
let $matched_providers :=  
  if ($search_terms) then
    for $provider in /csd:CSD/csd:providerDirectory/csd:provider
    let $credentials := $provider/csd:credential/csd:number
    where  count(filter($credentials,$filter)) &gt; 0
    return $provider  
  else ()
  


let $html_func :=  function($provider ,$doc_name,$search_name) 
{
  let $demo:= $provider/csd:demographic[1]
  return 
  &lt;html:li&gt;
    &lt;html:a href="{osf:get_entity_link($provider,$search_name)}"&gt;
      {$demo/csd:name[1]/csd:surname/text()}, {$demo/csd:name[1]/csd:forename/text()}
    &lt;/html:a&gt;
    &lt;html:div class='description_html'&gt;
      {osf:get_provider_desc_html($provider,$doc_name)}
      &lt;html:h2&gt;Credentials&lt;/html:h2&gt;
      &lt;html:ul&gt;
	  {
	    for $cred in $provider/csd:credential
	    return      
	      &lt;html:li&gt;
	        {$cred/csd:number} assigned by {$cred/csd:issuingAuthority}
	      &lt;/html:li&gt;

	  }
      &lt;/html:ul&gt;
    &lt;/html:div&gt;
  &lt;/html:li&gt; 
}


let $processors := map{
  'html' : $html_func
}


(:Produce the feed in the neccesary format :)
return osf:create_feed_from_entities($matched_providers,$careServicesRequest,$processors)



</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-anon:wiki-star-bible"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-anon:wiki-star-bible</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Anonymizes data using biblical names for person names and star names for places (sourced from wikipedia)
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";
import module namespace csd_lsc = "https://github.com/openhie/openinfoman/csd_lsc";
import module namespace csd_dm = "https://github.com/openhie/openinfoman/csd_dm";
import module namespace anonymize = "https://github.com/openhie/openinfoman-anon";
import module namespace functx = "http://www.functx.com";

declare namespace csd  =  "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;

let $dest_doc := /.
let $dest := $careServicesRequest/@resource

let $values_doc := "anonymous/bible.xml"
let $fac_values_doc := "anonymous/star.xml"


let $values_src_0 := db:open($csd_webconf:db,$values_doc)
let $values_src_1 := 
 if (count($values_src_0//value[1]) &gt; 0)  
 then $values_src_0
 else 
   let $number-for-a := string-to-codepoints('A')
   let $number-for-z := string-to-codepoints('Z')

   let $values_src := 
     &lt;values&gt;
       {
	 for $letter in ($number-for-a to $number-for-z)
	 let $url := concat('http://en.wikipedia.org/wiki/List_of_biblical_names_starting_with_', codepoints-to-string($letter))
	 let $resp := http:send-request(&lt;http:request method='get' href="{$url}"/&gt;)
 	   for $li in $resp/html/body//div[@id="mw-content-text"]/ul[1]/li
	   let $text := string-join(($li/a[1]/text(),$li/text()))
	   let $name := tokenize($text,'\W+')[1]
	   return &lt;value&gt;{functx:trim($name)}&lt;/value&gt;
       }
     &lt;/values&gt;
    return $values_src
let $values := $values_src_1//value/text()
  


let $fac_values_src_0 := db:open($csd_webconf:db,  $fac_values_doc)
let $fac_values_src_1 := 
 if (count($fac_values_src_0//value[1]) &gt; 0)  
 then $fac_values_src_0
 else 
   let $fac_url := 'http://en.wikipedia.org/wiki/List_of_proper_names_of_stars_in_alphabetical_order'
   let $resp := http:send-request(&lt;http:request method='get' href="{$fac_url}"/&gt;)
  
   return
     &lt;values&gt;
       {
	 for $td in $resp//table[@class="wikitable"]//td[1]
	 let $text := 
	   functx:trim(string-join(($td/a[1]/text(),$td/text())))
	 return if ($text) then &lt;value&gt;{$text}&lt;/value&gt; else ()
       }
     &lt;/values&gt;


let $fac_values := $fac_values_src_1//value/text()
 

return 
(
  if (count($values_src_0//value[1]) = 0)  
  then 
     if (db:exists($csd_webconf:db, $values_doc))
     then db:replace($csd_webconf:db, $values_src_1, $values_doc)
     else db:add($csd_webconf:db, $values_src_1, $values_doc)
  else ()
  ,
  if (count($fac_values_src_0//value[1]) = 0)  
  then 
     if (db:exists($csd_webconf:db, $fac_values_doc))
     then db:replace($csd_webconf:db, $fac_values_src_1, $fac_values_doc)
     else db:add($csd_webconf:db, $fac_values_src_1, $fac_values_doc)
  else ()
  ,
  for $doc  in $careServicesRequest/documents/document
    let $name := $doc/@resource
    let $src_doc :=
      if (not ($name = $dest)) then csd_dm:open_document( $name) 
      else ()
    let $anon_doc := anonymize:document($src_doc,$values,$fac_values,$fac_values)
    return   (csd_lsc:refresh_doc($dest_doc, $anon_doc))

)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-ilr:validate_provider_facility_service"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-ilr:validate_provider_facility_service</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Validates a healthcare worker's entity ID.   If optional facility and service information is provided, validates that the healthcare worker is registered to perform the service at the indicated facility
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

&lt;CSD xmlns:csd="urn:ihe:iti:csd:2013"  &gt;
  &lt;organizationDirectory/&gt;
  &lt;serviceDirectory/&gt;
  &lt;facilityDirectory/&gt;
  &lt;providerDirectory&gt;
    {
      let $facility_entityID := $careServicesRequest/facility[1]/@entityID
      let $service_entityID := $careServicesRequest/facility[1]/service[1]/@entityID
	  
      (: if no provider id was provided, then this is invalid. :)
      let $provs0 := if (exists($careServicesRequest/id/@entityID))
	then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id)
      else ()   

      let $provs1 := if (exists($facility_entityID) and count($provs0) = 1)
	then 
	   if (count ($provs0[1]/facilities/facility[@entityID = $facility_entityID]) &gt; 0) then $provs0 else ()
	else $provs0

      let $provs2 := if (exists($service_entityID) and count($provs1) = 1)
	then 
	   if (count ($provs1[1]/facilities/facility[upper-case(@entityID) = upper-case($facility_entityID)]/service[upper-case(@entityID) = upper-case($service_entityID)]) &gt; 0) then $provs1 else ()
	else $provs1

      return if (count($provs2) = 1) then
	&lt;provider entityID='{$provs2[1]/@entityID}'/&gt;
      else 
	 ()
    }     
  &lt;/providerDirectory&gt;
&lt;/CSD&gt;
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rapidpro:get_csv_for_import"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/csv<br/>
	URN: urn:openhie.org:openinfoman-rapidpro:get_csv_for_import</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Creates selection menu of all the CSD organizations and faciltiies with a specified parent.  Designed as part of heierarchical facility selection menus in RapidPro webhooks.
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace oi_csv =  "https://github.com/openhie/openinfoman/adapter/csv";
declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

oi_csv:get_serialized(/,$careServicesRequest)</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rapidpro:get_json_for_import"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        application/json<br/>
	URN: urn:openhie.org:openinfoman-rapidpro:get_json_for_import</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Get JSON representation of CSD for import to RapidPro via API
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csr_proc = "https://github.com/openhie/openinfoman/csr_proc";
import module namespace csd_webconf =  "https://github.com/openhie/openinfoman/csd_webconf";

declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;



let $careServicesSubRequest :=  
  &lt;csd:careServicesRequest&gt;
    &lt;csd:function  urn="urn:ihe:iti:csd:2014:stored-function:provider-search" &gt;
      &lt;csd:requestParams/&gt;
    &lt;/csd:function&gt;
  &lt;/csd:careServicesRequest&gt; 

let $providers := csr_proc:process_CSR_stored_results( /. , $careServicesSubRequest)


let $contacts :=  
  &lt;json type='object'&gt;
    &lt;contacts type="array"&gt;
    {
      for $provider in  $providers/csd:providerDirectory/csd:provider
      let $uuid := lower-case(string($provider/@entityID))
      let $name := ($provider/csd:demographic/csd:name/csd:commonName)[1]/text()
      let $tels := $provider/csd:demographic/csd:contactPoint/csd:codedType[@code="BP" and  @codingScheme="urn:ihe:iti:csd:2013:contactPoint"]
      let $tel_1 := $tels[1]/text()
      let $tel_2 := $tels[2]/text()
      let $tel_3 := $tels[3]/text()
      return 
	if (true()) (:  ($uuid and $name)  :)
       then 
         &lt;_  type="object"&gt;
	   &lt;name&gt;{$name}&lt;/name&gt;
	   &lt;urns type="array"&gt;
             { if ($tel_1) then   &lt;_ type='string'&gt;tel:{$tel_1}&lt;/_&gt; else ()} 
             { if ($tel_2) then   &lt;_ type='string'&gt;tel:{$tel_2}&lt;/_&gt; else ()} 
             { if ($tel_3) then   &lt;_ type='string'&gt;tel:{$tel_3}&lt;/_&gt; else ()} 
	   &lt;/urns&gt;
	   &lt;fields type="object"&gt;
             &lt;globalid&gt;{$uuid}&lt;/globalid&gt;
	   &lt;/fields&gt;
         &lt;/_&gt;
       else ()
    }
    &lt;/contacts&gt;
  &lt;/json&gt;


return json:serialize($contacts,map{"format":"direct"})  
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rapidpro:phone_stats"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/html<br/>
	URN: urn:openhie.org:openinfoman-rapidpro:phone_stats</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Statistics on phone numbers
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace functx = "http://www.functx.com";
declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;


let $country_code := '+231'
let $cellcom_code := '77'

let $get_clean_phones := function($provider) {
  let $all_phones := $provider/csd:demographic/csd:contactPoint/csd:codedType[@code = "BP" and @codingScheme="urn:ihe:iti:csd:2013:contactPoint"]
  let $clean_phones :=
    for $phone in $all_phones
    let $raw_phones := tokenize($phone/text(),'[/\s]+')
    let $normalized_phones := 
      for $raw_phone in $raw_phones
      let $clean_phone := replace($raw_phone,'[^\d\+]/', '')
      return 
	if (string-length($clean_phone) = 0)
	then ()
        else 
	  if (starts-with($clean_phone,'0'))
	  then concat($country_code, substring($clean_phone,2))
	  else $clean_phone
    return $normalized_phones
  return $clean_phones
}

let $clean_providers := 
  for $provider in /csd:CSD/csd:providerDirectory/csd:provider
  let $clean_phones := $get_clean_phones($provider)
  where count($clean_phones) &gt; 0
  return $provider

let $cellcom_providers := 
  for $provider in $clean_providers 
  let $clean_phones := $get_clean_phones($provider)
  let $cellcom_phones := 
    for $clean_phone in $clean_phones
    return 
      if (starts-with($clean_phone,concat($country_code,$cellcom_code))) 
      then $clean_phone
      else ()
  where (count($cellcom_phones) &gt; 0)
  return $provider

let $multi_providers :=
  for $provider in $clean_providers
  let $clean_phones := $get_clean_phones($provider)
  where (count($clean_phones) &gt; 1)
  return $provider

return 
  &lt;div&gt;
    &lt;ul&gt;
      &lt;li&gt;Total number of health workers: {count(/csd:CSD/csd:providerDirectory/csd:provider)}&lt;/li&gt;
      &lt;li&gt;Total number of health workers with phone: {count($clean_providers)}&lt;/li&gt;
      &lt;li&gt;Total number of health workers with cellcom phone: {count($cellcom_providers)}&lt;/li&gt;
      &lt;li&gt;Total number of health workers with multiple phones: {count($multi_providers)}&lt;/li&gt;      
    &lt;/ul&gt;
  &lt;/div&gt;


</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-rapidpro:select_facility"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        application/json<br/>
	URN: urn:openhie.org:openinfoman-rapidpro:select_facility</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source"> 
    Creates selection menu of all the CSD organizations and faciltiies with a specified parent.  Designed as part of heierarchical facility selection menus in RapidPro webhooks.
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace functx = "http://www.functx.com";
declare namespace csd = "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

let $t_top_orgid  :=  $careServicesRequest/query[@name = 'orgid']/text()
let $top_org :=  (/csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $t_top_orgid])[1]



let $selected_text := $careServicesRequest/query[@name = 'input']/text()
(:
let $selections := $careServicesRequest/values/item[./pair[@name = 'label' and ./text() = 'facilityselection']]
let $selected_text := 
  if (count($selections) &gt; 0)
  then
    let $max_time := max(for $time in $selections/pair[@name='time'] return xs:dateTime($time))
    return $selections[./pair[@name = 'time'] = $max_time]/pair[@name='text']/text()
   else ()
:)

let $selected_index := if ($selected_text castable as xs:integer) then xs:integer($selected_text) else -1


let $selected :=
  if ($selected_index = 0)
  then
    /csd:CSD/csd:organizationDirectory/csd:organization[
      @entityID = /csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $top_org/@entityID]/csd:parent/@entityID
    ]
  else if ($selected_index &gt; 0)
  then
    let $select_orgs := 
      if (exists($top_org))
      then /csd:CSD/csd:organizationDirectory/csd:organization[./csd:parent/@entityID = $top_org/@entityID]
      else /csd:CSD/csd:organizationDirectory/csd:organization[count(./csd:parent[@entityID]) = 0]
	
    let $select_facs := 
      if (exists($top_org))
      then /csd:CSD/csd:facilityDirectory/csd:facility[./csd:organizations/csd:organization[@entityID = $top_org/@entityID]]
      else ()
    return ($select_orgs,$select_facs)[ $selected_index]
  else ()

    
let $orgs := 
  if (exists($selected) and  local-name($selected ) = 'organization')
  then /csd:CSD/csd:organizationDirectory/csd:organization[./csd:parent/@entityID = $selected/@entityID]
  else /csd:CSD/csd:organizationDirectory/csd:organization[count(./csd:parent[@entityID]) = 0]
	
let $facs := 
  if (exists($selected) and  local-name($selected ) = 'organization')
  then /csd:CSD/csd:facilityDirectory/csd:facility[./csd:organizations/csd:organization[@entityID = $selected/@entityID]]
  else ()



let $output := 
  if ( local-name($selected ) = 'facility')
  then
    &lt;json type='object'&gt;
      &lt;menutext&gt;You already selected a facility.  You shouldn't see this message&lt;/menutext&gt;
      &lt;facility&gt;{string($selected/@entityID)}&lt;/facility&gt;
      &lt;facilityname&gt;{$selected/csd:primaryName/text()}&lt;/facilityname&gt;
    &lt;/json&gt;
  else  if ( local-name($selected ) = 'organization'  or not(exists($selected)))
  then
    &lt;json type='object'&gt;
      &lt;menutext &gt;
 	{ if (exists($selected)) then concat("In ", $selected/csd:primaryName/text(), ". ")  else () }
	{
	  let $parent := (/csd:CSD/csd:organizationDirectory/csd:organization[@entityID = $selected/csd:parent/@entityID])[1]/csd:primaryName/text()
	  return
	    if ($parent)
	    then concat("O) Up to ", $parent, " ") 
	    else ()
        }
	{ for $ent at $pos in ($orgs,$facs)  return concat( $pos, ") ", $ent/csd:primaryName/text())    }
      &lt;/menutext&gt;
      &lt;orgid&gt;{if (exists($selected)) then string($selected/@entityID) else ()}&lt;/orgid&gt;
      &lt;facility/&gt;
      &lt;facilityname/&gt;      
    &lt;/json&gt;
   else &lt;json type='object'/&gt;

(:return $output :)
return json:serialize($output,map{'format':'direct'})</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_birth"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_birth</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_indices_demogrpahic_birth</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";

declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $provs0 := 
  if (exists($careServicesRequest/id/@entityID)) then 
    csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
  else (/CSD/providerDirectory/*)
let $provs1:=     
  for $provider in  $provs0
  return
  &lt;provider entityID="{$provider/@entityID}"&gt;
    &lt;demographic&gt;
     {
       if (exists(($provider/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='birth'])[1])) then
	 &lt;extension urn="urn:who.int:hrh:mds" type='birth'/&gt;
       else ()
     }
    &lt;/demographic&gt;
  &lt;/provider&gt;
    
return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_citizenship"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_citizenship</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_indices_demogrpahic_citizenship</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";

declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $provs0 := 
  if (exists($careServicesRequest/id/@entityID)) then 
    csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
  else (/CSD/providerDirectory/*)
let $provs1:=     
  for $provider in  $provs0
  return
  &lt;provider entityID="{$provider/@entityID}"&gt;
    &lt;demographic&gt;
     {
       if (exists(($provider/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='citizenship'])[1])) then
	 &lt;extension urn="urn:who.int:hrh:mds" type='citizenship'/&gt;
       else ()
     }
    &lt;/demographic&gt;
  &lt;/provider&gt;
    
return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_photo"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:indices_demographic_photo</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_indices_demographic_photo</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
  let $provs0 := 
    if (exists($careServicesRequest/id/@entityID)) then 
      csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) 
    else (/CSD/providerDirectory/*)
  let $provs1:=     
      for $provider in  $provs0
      return
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;demographic&gt;
	  {
	    for $name at $pos  in  $provider/demographic/extension[@type='photograph' and @urn='urn:who.int:hrh:mds']
	    return &lt;extension type='photograph' urn='urn:who.int:hrh:mds'  position="{$pos}"/&gt; 
	  }
	&lt;/demographic&gt;
    &lt;/provider&gt;
      
    return csd_bl:wrap_providers($provs1)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_birth"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_birth</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_read_demographic_birth</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";

declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/* ,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    &lt;provider entityID="{$provs1[1]/@entityID}"&gt;
      &lt;demographic&gt;
	{($provs1[1]/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='birth'])[1]}
      &lt;/demographic&gt;
    &lt;/provider&gt;
  else ()        
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_citizenship"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_citizenship</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_read_demographic_citizenship</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";

declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/* ,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    &lt;provider entityID="{$provs1[1]/@entityID}"&gt;
      &lt;demographic&gt;
	{($provs1[1]/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='citizenship'])[1]}
      &lt;/demographic&gt;
    &lt;/provider&gt;
  else ()        
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_photo"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_demographic_photo</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_read_demographic_photo</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";

declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $exts := $careServicesRequest/demographic/extension[@type='photograph' and @urn='urn:who.int:hrh:mds']
let $provs0 := if (count($exts) = 1 and exists($exts[1]/@position)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    let $provider :=  $provs1[1] 
    return 
    &lt;provider entityID="{$provider/@entityID}"&gt;
      &lt;demographic&gt;
	{
	  for $ext in ($provider/demographic/extension[@type='photograph' and @urn='urn:who.int:hrh:mds'])[position() = $exts[1]/@position]
	  return      &lt;extension type='photograph' urn='urn:who.int:hrh:mds'  position="{$exts[1]/@position}"&gt;{$ext/*}&lt;/extension&gt;
	}
      &lt;/demographic&gt;
      {$provider/record}
    &lt;/provider&gt;
  else ()    
    
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:read_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_read_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 

let $provs0 := if (exists($careServicesRequest/otherID/@position)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $provs2 := 
  if (count($provs1) = 1) 
    then 
    let $provider :=  $provs1[1] 
    return 
    &lt;provider entityID="{$provider/@entityID}"&gt;
      {(
	if (exists($careServicesRequest/otherID/@position))
	  then 
	  for $id in $provider/otherID[position() = $careServicesRequest/otherID/@position]
	  return       
	  &lt;otherID 
	  position="{$careServicesRequest/otherID/@position}"
	  code="{$id/@code}"
	  expirationDate="{$id/@expirationDate}"
	  issueDate="{$id/@issueDate}"
	  assigningAuthorityName="{$id/@assigningAuthorityName}"&gt;{string($id)}&lt;/otherID&gt;
	else
	  ()
        ,      
	$provider/record
	)}
    &lt;/provider&gt;
  else ()    
    
return csd_bl:wrap_providers($provs2)
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:opensearch_name"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:opensearch_name</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">
    Peforms a search request on a provider's common name according to the OpenSearch 1.1 Specification:
      http://www.opensearch.org/Specifications/OpenSearch/1.1
    Returns search results in opensearch feed for a provider by common name
  </span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace osf = "https://github.com/openhie/openinfoman/adapter/opensearch";
import module namespace functx = 'http://www.functx.com';

declare namespace csd =  "urn:ihe:iti:csd:2013";
declare namespace rss = "http://backend.userland.com/rss2";
declare namespace atom = "http://www.w3.org/2005/Atom";
declare namespace html = "http://www.w3.org/1999/xhtml";
declare namespace os  = "http://a9.com/-/spec/opensearch/1.1/";
declare variable $careServicesRequest as item() external;


(: 
   The query will be executed against the root element of the CSD document.    
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 


(:Get the search terms passed in the request :)
let $search_terms := xs:string($careServicesRequest/os:searchTerms/text())
(:Find the matching providers -- to be customized for your search:)
let $matched_providers :=  
  for $provider in /csd:CSD/csd:providerDirectory/csd:provider
  let $surname := $provider/csd:demographic/csd:name/csd:surname
  where  exists($search_terms) and exists($surname) and functx:contains-case-insensitive($surname,  $search_terms)  
  return $provider  



let $html_wrap_func :=  function($meta,$content) {
  &lt;html:html xml:lang="en" lang="en"&gt;
    &lt;html:head profile="http://a9.com/-/spec/opensearch/1.1/" &gt;    

      &lt;html:link href="/static/bootstrap/css/bootstrap.css" rel="stylesheet"/&gt;
      &lt;html:link href="/static/bootstrap/css/bootstrap-theme.css" rel="stylesheet"/&gt;
      
      &lt;html:script src="https://code.jquery.com/jquery.js"/&gt;
      &lt;script src="/static/bootstrap/js/bootstrap.min.js"/&gt;

      &lt;html:script src="https://code.jquery.com/jquery.js"/&gt;
      &lt;html:script src="/static/bootstrap/js/bootstrap.min.js"/&gt;
      {$meta}
    &lt;/html:head&gt;
    &lt;html:body&gt;  
      &lt;html:div class="navbar navbar-inverse navbar-static-top"&gt;
	&lt;html:div class="container"&gt;
          &lt;html:div class="navbar-header"&gt;
	    &lt;html:img class='pull-left' height='38px' src='/static/FMOH_Nigeria_logo.png'/&gt;
            &lt;html:button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"&gt;
              &lt;html:span class="icon-bar"&gt;&lt;/html:span&gt;
              &lt;html:span class="icon-bar"&gt;&lt;/html:span&gt;
              &lt;html:span class="icon-bar"&gt;&lt;/html:span&gt;
            &lt;/html:button&gt;
            &lt;html:a class="navbar-brand" href="/CSD"&gt;Nigeria Health Workforce Registry&lt;/html:a&gt;
          &lt;/html:div&gt;
	&lt;/html:div&gt;
      &lt;/html:div&gt;
      &lt;html:div class="container"&gt;
	&lt;html:p align="justify" class='bold'&gt;
	The Nigeria Health Workforce Registry (NHWR) is an information system developed and managed by the Department of Planning, Research and Statistics,
	in the Federal Ministry of Health. The Nigeria Health Workforce Registry represents the Government of Nigeria's health workforce, aggregated from the three
	tiers of the country's health system - Local, State and Federal levels.
	&lt;/html:p&gt;
	&lt;html:p&gt;
	The Nigeria Health Workforce Registry implements the Care Services Directory 
	(&lt;html:a href="ftp://ftp.ihe.net/DocumentPublication/CurrentPublished/ITInfrastructure/IHE_ITI_Suppl_CSD.pdf"&gt;CSD&lt;/html:a&gt;)
	profile from Integrating the Health Enterprise &lt;html:a href="http://ihe.net"&gt;(IHE)&lt;/html:a&gt; as recommened by OpenHIE.
	&lt;/html:p&gt;
	

	&lt;html:p&gt;
	  &lt;html:b&gt;The Nigeria Health Workforce Registry is a free, Open Source software solution.&lt;/html:b&gt;
	&lt;/html:p&gt;
      &lt;/html:div&gt;
      &lt;html:div class='wrapper_search'&gt;
	&lt;html:div class="container"&gt;
	  {$content}
	&lt;/html:div&gt;
      &lt;/html:div&gt;


      &lt;html:div id='site_footer' class='container'&gt;
        © 2014 Department of Planning, Research and statistics, Federal Ministry of Health. 
      &lt;/html:div&gt;
    &lt;/html:body&gt;
  &lt;/html:html&gt;

}



let $processors := map{
  'html_wrap' : $html_wrap_func
}

(:Produce the feed in the neccesary format :)
return osf:create_feed_from_entities($matched_providers,$careServicesRequest,$processors)



</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_birth"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_birth</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_create_demographic_birth</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";

import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $birth :=  ($careServicesRequest/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='birth'])[1]
let $existingBirth :=  ($provs[1]/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='birth'])[1]
let $demo := $provs[1]/demographic
let $insert := 
  if (not(exists($demo))) then &lt;demographic&gt;{$birth}&lt;/demographic&gt; else $birth
    let $return := 
    &lt;provider entityID="{$provs[1]/@entityID}"&gt;
      &lt;demographic&gt;&lt;extension type="birth" urn="urn:who.int:hrh:mds"/&gt;&lt;/demographic&gt;
    &lt;/provider&gt;
let $insertTo :=
  if (not(exists($demo))) then $provs[1] else $provs[1]/demographic

return  
  if ( count($provs) = 1 and not(exists($existingBirth)))
  then
     (
      insert node $insert into $insertTo,
      csd_blu:bump_timestamp($provs[1]),
      csd_blu:wrap_updating_providers($return)
      )
  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_citizenship"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_citizenship</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_create_demographic_citizenship</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";

import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $citizenship :=  ($careServicesRequest/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='citizenship'])[1]
let $existingCitizenship :=  ($provs[1]/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='citizenship'])[1]
let $demo := $provs[1]/demographic
let $insert := 
  if (not(exists($demo))) then &lt;demographic&gt;{$citizenship}&lt;/demographic&gt; else $citizenship
    let $return := 
    &lt;provider entityID="{$provs[1]/@entityID}"&gt;
      &lt;demographic&gt;&lt;extension type="citizenship" urn="urn:who.int:hrh:mds"/&gt;&lt;/demographic&gt;
    &lt;/provider&gt;
let $insertTo :=
  if (not(exists($demo))) then $provs[1] else $provs[1]/demographic

return  
  if ( count($provs) = 1 and not(exists($existingCitizenship)))
  then
     (
      insert node $insert into $insertTo,
      csd_blu:bump_timestamp($provs[1]),
      csd_blu:wrap_updating_providers($return)
      )
  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_photo"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_demographic_photo</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_create_demogrpahic_photo</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";

declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $ext := $careServicesRequest/demographic/extension[@type='photograph' and urn ='urn:who.int:hrh:mds']
let $provs := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
return  
  if ( exists($ext) and count($provs) = 1 )
    then
    let $provider:= $provs[1]
    let $position := count($provider/demographic/extension[@type='photograph' and @urn='urn:who.int:hrh:mds']) +1
    let $return:=  
    &lt;provider entityID="{$provider/@entityID}"&gt;
      &lt;demographic&gt;
	&lt;extension type='photograph' urn='urn:who.int:hrh:mds' position="{$position}"/&gt;
      &lt;/demographic&gt;
    &lt;/provider&gt;
    return 
      (
	if (exists($provider/demographic))
	  then insert node $ext into $provider/demographic 
	else
	  insert node &lt;demographic&gt;{$ext}&lt;/demographic&gt; into $provider
	  ,   csd_blu:wrap_updating_providers($return)
	)
  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_other_id"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_other_id</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_create_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provider := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id)[1] else ()
let $new_id := $careServicesRequest/otherID
return  
  if ( exists($provider) and not($new_id/@code = ''))     
    then
    let $position := count($provider/otherID) +1
    let $return:=  
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;otherID position="{$position}"/&gt;
      &lt;/provider&gt;
    return 
      (
	insert node $new_id into $provider ,    
	csd_blu:wrap_updating_providers($return)
      )
  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_provider_credenital"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:create_provider_credenital</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_create_provider_credential</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provider := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id)[1] else ()
let $cred_request := $careServicesRequest/credential
let $code:= $cred_request/codedType/@code
let $codingScheme:= $cred_request/codedType/@codingScheme
let $creds := $provider/credential[@code = $code and @codingScheme = $codingScheme]
return  
  if ( exists($provider) and count($creds) = 0 and exists($code) and exists($codingScheme))  (:DO NOT ALLOW SAME CRED TWICE :)
    then
    let $return:=  
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;credential&gt;
	  &lt;codedType code="{$code}" codingScheme="{$codingScheme}"/&gt;
	&lt;/credential&gt;
      &lt;/provider&gt;
    let $cred_new :=
      &lt;credential&gt;
	&lt;codedType code="{$code}" codingScheme="{$codingScheme}"/&gt;
	{(
	  if (exists($cred_request/number)) then $cred_request/number else (),
	  if (exists($cred_request/issuingAuthority)) then $cred_request/issuingAuthority else (),
	  if (exists($cred_request/credentialIssueDate)) then $cred_request/credentialIssueDate else (),
	  if (exists($cred_request/credentialRenewalDate)) then $cred_request/credentialRenewalDate else (),
	  if (exists($cred_request/extension[@urn='urn:who.int:hrh:mds' and @type='photograph']/image)) then $cred_request/extension[@urn='urn:who.int:hrh:mds' and @type='photograph'] else ()
	 )}
      &lt;/credential&gt;
    return 
	(
	insert node $cred_new into $provider,
	csd_blu:wrap_updating_providers($return)
	)

  else  csd_blu:wrap_updating_providers(())
      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demographic_birth"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demographic_birth</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_delete_demogrpahic_birth</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";

import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $providers := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
return
  if ( count($providers) = 1 )
    then
    let $birth := ($providers[1]/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='birth'])
    return if (exists($birth)) then (delete node $birth) else ()
  else  ()

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demogrpahic_citizenship"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demogrpahic_citizenship</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_delete_demogrpahic_citizenship</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";

import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $providers := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
return
  if ( count($providers) = 1 )
    then
    let $citizenship := ($providers[1]/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='citizenship'])
    return if (exists($citizenship)) then (delete node $citizenship) else ()
  else  ()

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demographic_photo"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:delete_demographic_photo</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_delete_demogrpahic_photo</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";

declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:) 
let $pos := $careServicesRequest/demographic/extension[@type='photograph' and @urn='urn:who.int:hrh:mds']/@position
return
  if (exists($pos)) 
    then 
    let $providers := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
    return
      if ( count($providers) = 1 )
	then
	let  $ext :=  ($providers[1]/demographic/extension[@type='photograph' and @urn='urn:who.int:hrh:mds'])[position() = $pos]
	return if (exists($ext)) then (delete node $ext) else ()
      else  ()
    else ()      
</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demographic_birth"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demographic_birth</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_update_demogrpahic_birth</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";

import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $updBirth :=  ($careServicesRequest/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='birth'])[1]
let $existBirth := ($provs[1]/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='birth'])[1]

return  
  if ( count($provs) = 1 and exists( $existBirth ) and exists($updBirth)) then
   (
     if (exists($updBirth/country))
       then 	    
       if (exists($existBirth/country))
	 then  replace value of node $existBirth/country with $updBirth/country
       else insert node  $updBirth/country into $existBirth
     else (),
     if (exists($updBirth/town))
       then 	    
       if (exists($existBirth/town))
	 then  replace value of node $existBirth/town with $updBirth/town
       else insert node  $updBirth/town into $existBirth
     else (),
     if (exists($updBirth/motherName))
       then 	    
       if (exists($existBirth/motherName))
	 then  replace value of node $existBirth/motherName with $updBirth/motherName
       else insert node  $updBirth/motherName into $existBirth
     else (),
     if (exists($updBirth/fatherName))
       then 	    
       if (exists($existBirth/fatherName))
	 then  replace value of node $existBirth/fatherName with $updBirth/fatherName
       else insert node  $updBirth/fatherName into $existBirth
     else (),	    
     csd_blu:bump_timestamp($provs[1]),
     let $return := 
     &lt;provider entityID="{$provs[1]/@entityID}"&gt;
       &lt;demographic&gt;&lt;extension type="birth" urn="urn:who.int:hrh:mds"/&gt;&lt;/demographic&gt;
     &lt;/provider&gt;
     return csd_blu:wrap_updating_providers($return)
    )
  else 	csd_blu:wrap_updating_providers(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demogrpahic_citizenship"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demogrpahic_citizenship</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_update_demogrpahic_citizenship</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";

import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $updCitizen :=  ($careServicesRequest/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='citizenship'])[1]
let $existCitizen := ($provs[1]/demographic/extension[@urn='urn:who.int:hrh:mds' and @type='citizenship'])[1]

return  
  if ( count($provs) = 1 and exists( $existCitizen ) and exists($updCitizen)) then
   (
     if (exists($updCitizen/residence))
       then 	    
       if (exists($existCitizen/residence))
	 then  replace value of node $existCitizen/residence with $updCitizen/residence
       else insert node  $updCitizen/residence into $existCitizen
     else (),
     if (exists($updCitizen/current))
       then 	    
       if (exists($existCitizen/current))
	 then  replace value of node $existCitizen/current with $updCitizen/current
       else insert node  $updCitizen/current into $existCitizen
     else (),
     if (exists($updCitizen/birth))
       then 	    
       if (exists($existCitizen/birth))
	 then  replace value of node $existCitizen/birth with $updCitizen/birth
       else insert node  $updCitizen/birth into $existCitizen
     else (),
     csd_blu:bump_timestamp($provs[1]),
     let $return := 
     &lt;provider entityID="{$provs[1]/@entityID}"&gt;
       &lt;demographic&gt;&lt;extension type='citizenship' urn="urn:who.int:hrh:mds"/&gt;&lt;/demographic&gt;
     &lt;/provider&gt;
     return csd_blu:wrap_updating_providers($return)
    )
  else 	csd_blu:wrap_updating_providers(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demographic_photo"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_demographic_photo</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_update_demogrpahic_phto</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";

declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $new_ext := $careServicesRequest/demographic/extension[@type='photograph' and @urn='urn:who.int:hrh:mds']
let $provs0 := if (exists($new_ext/@position)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $ext := ($provs1[1]/demographic/extension[@type='photograph' and @urn='urn:who.int:hrh:mds'])[position() = $new_ext/@position]
return
  if (count($provs1) = 1 and exists($ext)) 
    then
    let $provs2 := 
    &lt;provider entityID="{$provs1[1]/@entityID}"&gt;
      &lt;demographic&gt;
	&lt;extension type='photograph' urn='urn:who.int:hrh:mds' position="{$new_ext/@position}"/&gt;
      &lt;/demographic&gt;
    &lt;/provider&gt;
    return
      (
	csd_blu:bump_timestamp($provs1[1]),
	replace  node $ext with $new_ext,
	csd_blu:wrap_updating_providers($provs2)
     )
  else 	csd_blu:wrap_updating_providers(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_otherid"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_otherid</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_update_otherid</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";
import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   
let $provs0 := if (exists($careServicesRequest/otherID)) then /CSD/providerDirectory/*  else ()
let $provs1 := if (exists($careServicesRequest/id/@entityID)) then csd_bl:filter_by_primary_id($provs0,$careServicesRequest/id) else ()
let $id := $provs1[1]/otherID[position() = $careServicesRequest/otherID/@position]
return
  if (count($provs1) = 1 and exists($id)) 
    then
    let $provs2 := 
    &lt;provider entityID="{$provs1[1]/@entityID}"&gt;
      &lt;otherID position="{$careServicesRequest/otherID/@position}"/&gt;
    &lt;/provider&gt;
    return
      (
	csd_blu:bump_timestamp($provs1[1]),
	if ($careServicesRequest/otherID/@code) 
	  then 	    
	    if (exists($id/@code))
	      then  (replace value of node $id/@code with $careServicesRequest/otherID/@code)
	      else (insert node  $careServicesRequest/otherID/@code into $id)
	  else (),
	if (exists($careServicesRequest/otherID/@assigningAuthorityName) )
	  then 
	    if (exists($id/@assigningAuthorityName))
	      then replace value of node $id/@assigningAuthorityName with $careServicesRequest/otherID/@assigningAuthorityName
	      else insert node $careServicesRequest/otherID/@assigningAuthorityName into $id		
	  else (),
	if (exists($careServicesRequest/otherID/@issueDate) )
	  then 
	    if (exists($id/@issueDate))
	      then replace value of node $id/@issueDate with $careServicesRequest/otherID/@issueDate
	      else insert node $careServicesRequest/otherID/@issueDate into $id		
	  else (),
	if (exists($careServicesRequest/otherID/@expirationDate) )
	  then 
	    if (exists($id/@expirationDate))
	      then replace value of node $id/@expirationDate with $careServicesRequest/otherID/@expirationDate
	      else insert node $careServicesRequest/otherID/@expirationDate into $id		
	  else (),
	if (not(string($careServicesRequest/otherID) = '')) 
	  then (replace value of node $id with string($careServicesRequest/otherID))
	  else (),
	csd_blu:wrap_updating_providers($provs2)
     )
  else 	csd_blu:wrap_updating_providers(())

</pre></span>
      </div>
    </div>
    <a id="urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_provider_credenital"/>
    <div class="function">
      <div class="callout">
        <span class="attribute">Content-Type: 
        text/xml<br/>
	URN: urn:openhie.org:openinfoman-hwr-nigeria:stored-function:update_provider_credenital</span>
        <h2>Description</h2>
        <br/>
        <br/>
        <span class="source">nigeria_health_worker_update_provider_credential</span>
        <h2>Definition            </h2>
        <span class="source">Source: 
	<pre>import module namespace csd_bl = "https://github.com/openhie/openinfoman/csd_bl";

import module namespace csd_blu = "https://github.com/openhie/openinfoman/csd_blu";
declare default element  namespace   "urn:ihe:iti:csd:2013";
declare variable $careServicesRequest as item() external;

(: 
   The query will be executed against the root element of the CSD document.
   
   The dynamic context of this query has $careServicesRequest set to contain any of the search 
   and limit paramaters as sent by the Service Finder
:)   

let $provs0 := if (exists($careServicesRequest/id/@entityID)) then	csd_bl:filter_by_primary_id(/CSD/providerDirectory/*,$careServicesRequest/id) else ()
let $provs1 := if (count($provs0) = 1) then $provs0 else ()
let $provs2 := if (exists($careServicesRequest/credential/codedType/@code) and exists($careServicesRequest/credential/codedType/@codingScheme) ) then $provs1  else ()
let $cred_new := $careServicesRequest/credential
let $code:= $cred_new/codedType/@code
let $codingScheme:= $cred_new/codedType/@codingScheme
let $creds0 := $provs2/credential/codedType[@code = $code and @codingScheme = $codingScheme]
return  
  if ( count($provs2) = 1 and count($creds0) = 1)  (:Update only:)
    then
    let $cred_old := $creds0[1]/..
    let $provider:= $provs2[1]
    let $provs3 := 
      &lt;provider entityID="{$provider/@entityID}"&gt;
	&lt;credential&gt;
	  &lt;codedType code="{$code}" codingScheme="{$codingScheme}"/&gt;
	&lt;/credential&gt;
      &lt;/provider&gt;


    return
      
      (
	csd_blu:bump_timestamp($provider),
	if (exists($cred_new/issuingAuthority)) then
	  (if (exists($cred_old/issuingAuthority)) then (delete node $cred_old/issuingAuthority) else (),
	  insert node $cred_new/issuingAuthority into $cred_old)
	else (),
	if (exists($cred_new/number)) then
	  (if (exists($cred_old/number)) then (delete node $cred_old/number) else (),
	  insert node $cred_new/number into $cred_old)
	else (),
	if (exists($cred_new/credentialIssueDate)) then
	  (if (exists($cred_old/credentialIssueDate)) then (delete node $cred_old/credentialIssueDate) else (),
	  insert node $cred_new/credentialIssueDate into $cred_old)
	else (),
	if (exists($cred_new/credentialRenewalDate)) then
	  (if (exists($cred_old/credentialRenewalDate)) then (delete node $cred_old/credentialRenewalDate) else (),
	  insert node $cred_new/credentialRenewalDate into $cred_old)
	else (),
	if (exists($cred_new/extension[@urn='urn:who.int:hrh:mds' and @type='photograph']/image)) then
	  (if (exists($cred_old/extension[@urn='urn:who.int:hrh:mds' and @type='photograph'])) then (delete node $cred_old/extension[@urn='urn:who.int:hrh:mds' and @type='photograph']) else (),
	  insert node $cred_new/extension[@urn='urn:who.int:hrh:mds' and @type='photograph'] into $cred_old	   )
	else (),

	csd_blu:wrap_updating_providers($provs3)
       )
  else 	csd_blu:wrap_updating_providers(())


</pre></span>
      </div>
    </div>
  </body>
</html>
